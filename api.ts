/* tslint:disable */
/* eslint-disable */
/**
 * EVE Swagger Interface
 * An OpenAPI for EVE Online
 *
 * The version of the OpenAPI document: 1.12
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 * Bad request model
 * @export
 * @interface BadRequest
 */
export interface BadRequest {
  /**
   * Bad request message
   * @type {string}
   * @memberof BadRequest
   */
  error: string;
}
/**
 * Unprocessable entity
 * @export
 * @interface DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity
 */
export interface DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity {
  /**
   * Unprocessable entity message
   * @type {string}
   * @memberof DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity
   */
  error?: string;
}
/**
 * Not found
 * @export
 * @interface DeleteFleetsFleetIdMembersMemberIdNotFound
 */
export interface DeleteFleetsFleetIdMembersMemberIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof DeleteFleetsFleetIdMembersMemberIdNotFound
   */
  error?: string;
}
/**
 * Not found
 * @export
 * @interface DeleteFleetsFleetIdSquadsSquadIdNotFound
 */
export interface DeleteFleetsFleetIdSquadsSquadIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof DeleteFleetsFleetIdSquadsSquadIdNotFound
   */
  error?: string;
}
/**
 * Not found
 * @export
 * @interface DeleteFleetsFleetIdWingsWingIdNotFound
 */
export interface DeleteFleetsFleetIdWingsWingIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof DeleteFleetsFleetIdWingsWingIdNotFound
   */
  error?: string;
}
/**
 * Error limited model
 * @export
 * @interface ErrorLimited
 */
export interface ErrorLimited {
  /**
   * Error limited message
   * @type {string}
   * @memberof ErrorLimited
   */
  error: string;
}
/**
 * Forbidden model
 * @export
 * @interface Forbidden
 */
export interface Forbidden {
  /**
   * Forbidden message
   * @type {string}
   * @memberof Forbidden
   */
  error: string;
  /**
   * status code received from SSO
   * @type {number}
   * @memberof Forbidden
   */
  sso_status?: number;
}
/**
 * Gateway timeout model
 * @export
 * @interface GatewayTimeout
 */
export interface GatewayTimeout {
  /**
   * Gateway timeout message
   * @type {string}
   * @memberof GatewayTimeout
   */
  error: string;
  /**
   * number of seconds the request was given
   * @type {number}
   * @memberof GatewayTimeout
   */
  timeout?: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetAlliancesAllianceIdContacts200Ok
 */
export interface GetAlliancesAllianceIdContacts200Ok {
  /**
   * contact_id integer
   * @type {number}
   * @memberof GetAlliancesAllianceIdContacts200Ok
   */
  contact_id: number;
  /**
   * contact_type string
   * @type {string}
   * @memberof GetAlliancesAllianceIdContacts200Ok
   */
  contact_type: GetAlliancesAllianceIdContacts200OkContactTypeEnum;
  /**
   * label_ids array
   * @type {Array<number>}
   * @memberof GetAlliancesAllianceIdContacts200Ok
   */
  label_ids?: Array<number>;
  /**
   * Standing of the contact
   * @type {number}
   * @memberof GetAlliancesAllianceIdContacts200Ok
   */
  standing: number;
}

export const GetAlliancesAllianceIdContacts200OkContactTypeEnum = {
  CHARACTER: "character",
  CORPORATION: "corporation",
  ALLIANCE: "alliance",
  FACTION: "faction",
} as const;

export type GetAlliancesAllianceIdContacts200OkContactTypeEnum =
  typeof GetAlliancesAllianceIdContacts200OkContactTypeEnum[keyof typeof GetAlliancesAllianceIdContacts200OkContactTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetAlliancesAllianceIdContactsLabels200Ok
 */
export interface GetAlliancesAllianceIdContactsLabels200Ok {
  /**
   * label_id integer
   * @type {number}
   * @memberof GetAlliancesAllianceIdContactsLabels200Ok
   */
  label_id: number;
  /**
   * label_name string
   * @type {string}
   * @memberof GetAlliancesAllianceIdContactsLabels200Ok
   */
  label_name: string;
}
/**
 * No image server for this datasource
 * @export
 * @interface GetAlliancesAllianceIdIconsNotFound
 */
export interface GetAlliancesAllianceIdIconsNotFound {
  /**
   * error message
   * @type {string}
   * @memberof GetAlliancesAllianceIdIconsNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetAlliancesAllianceIdIconsOk
 */
export interface GetAlliancesAllianceIdIconsOk {
  /**
   * px128x128 string
   * @type {string}
   * @memberof GetAlliancesAllianceIdIconsOk
   */
  px128x128?: string;
  /**
   * px64x64 string
   * @type {string}
   * @memberof GetAlliancesAllianceIdIconsOk
   */
  px64x64?: string;
}
/**
 * Not found
 * @export
 * @interface GetAlliancesAllianceIdNotFound
 */
export interface GetAlliancesAllianceIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetAlliancesAllianceIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetAlliancesAllianceIdOk
 */
export interface GetAlliancesAllianceIdOk {
  /**
   * ID of the corporation that created the alliance
   * @type {number}
   * @memberof GetAlliancesAllianceIdOk
   */
  creator_corporation_id: number;
  /**
   * ID of the character that created the alliance
   * @type {number}
   * @memberof GetAlliancesAllianceIdOk
   */
  creator_id: number;
  /**
   * date_founded string
   * @type {string}
   * @memberof GetAlliancesAllianceIdOk
   */
  date_founded: string;
  /**
   * the executor corporation ID, if this alliance is not closed
   * @type {number}
   * @memberof GetAlliancesAllianceIdOk
   */
  executor_corporation_id?: number;
  /**
   * Faction ID this alliance is fighting for, if this alliance is enlisted in factional warfare
   * @type {number}
   * @memberof GetAlliancesAllianceIdOk
   */
  faction_id?: number;
  /**
   * the full name of the alliance
   * @type {string}
   * @memberof GetAlliancesAllianceIdOk
   */
  name: string;
  /**
   * the short name of the alliance
   * @type {string}
   * @memberof GetAlliancesAllianceIdOk
   */
  ticker: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdAgentsResearch200Ok
 */
export interface GetCharactersCharacterIdAgentsResearch200Ok {
  /**
   * agent_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdAgentsResearch200Ok
   */
  agent_id: number;
  /**
   * points_per_day number
   * @type {number}
   * @memberof GetCharactersCharacterIdAgentsResearch200Ok
   */
  points_per_day: number;
  /**
   * remainder_points number
   * @type {number}
   * @memberof GetCharactersCharacterIdAgentsResearch200Ok
   */
  remainder_points: number;
  /**
   * skill_type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdAgentsResearch200Ok
   */
  skill_type_id: number;
  /**
   * started_at string
   * @type {string}
   * @memberof GetCharactersCharacterIdAgentsResearch200Ok
   */
  started_at: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdAssets200Ok
 */
export interface GetCharactersCharacterIdAssets200Ok {
  /**
   * is_blueprint_copy boolean
   * @type {boolean}
   * @memberof GetCharactersCharacterIdAssets200Ok
   */
  is_blueprint_copy?: boolean;
  /**
   * is_singleton boolean
   * @type {boolean}
   * @memberof GetCharactersCharacterIdAssets200Ok
   */
  is_singleton: boolean;
  /**
   * item_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdAssets200Ok
   */
  item_id: number;
  /**
   * location_flag string
   * @type {string}
   * @memberof GetCharactersCharacterIdAssets200Ok
   */
  location_flag: GetCharactersCharacterIdAssets200OkLocationFlagEnum;
  /**
   * location_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdAssets200Ok
   */
  location_id: number;
  /**
   * location_type string
   * @type {string}
   * @memberof GetCharactersCharacterIdAssets200Ok
   */
  location_type: GetCharactersCharacterIdAssets200OkLocationTypeEnum;
  /**
   * quantity integer
   * @type {number}
   * @memberof GetCharactersCharacterIdAssets200Ok
   */
  quantity: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdAssets200Ok
   */
  type_id: number;
}

export const GetCharactersCharacterIdAssets200OkLocationFlagEnum = {
  ASSET_SAFETY: "AssetSafety",
  AUTO_FIT: "AutoFit",
  BOOSTER_BAY: "BoosterBay",
  CARGO: "Cargo",
  CORPSE_BAY: "CorpseBay",
  DELIVERIES: "Deliveries",
  DRONE_BAY: "DroneBay",
  FIGHTER_BAY: "FighterBay",
  FIGHTER_TUBE0: "FighterTube0",
  FIGHTER_TUBE1: "FighterTube1",
  FIGHTER_TUBE2: "FighterTube2",
  FIGHTER_TUBE3: "FighterTube3",
  FIGHTER_TUBE4: "FighterTube4",
  FLEET_HANGAR: "FleetHangar",
  FRIGATE_ESCAPE_BAY: "FrigateEscapeBay",
  HANGAR: "Hangar",
  HANGAR_ALL: "HangarAll",
  HI_SLOT0: "HiSlot0",
  HI_SLOT1: "HiSlot1",
  HI_SLOT2: "HiSlot2",
  HI_SLOT3: "HiSlot3",
  HI_SLOT4: "HiSlot4",
  HI_SLOT5: "HiSlot5",
  HI_SLOT6: "HiSlot6",
  HI_SLOT7: "HiSlot7",
  HIDDEN_MODIFIERS: "HiddenModifiers",
  IMPLANT: "Implant",
  LO_SLOT0: "LoSlot0",
  LO_SLOT1: "LoSlot1",
  LO_SLOT2: "LoSlot2",
  LO_SLOT3: "LoSlot3",
  LO_SLOT4: "LoSlot4",
  LO_SLOT5: "LoSlot5",
  LO_SLOT6: "LoSlot6",
  LO_SLOT7: "LoSlot7",
  LOCKED: "Locked",
  MED_SLOT0: "MedSlot0",
  MED_SLOT1: "MedSlot1",
  MED_SLOT2: "MedSlot2",
  MED_SLOT3: "MedSlot3",
  MED_SLOT4: "MedSlot4",
  MED_SLOT5: "MedSlot5",
  MED_SLOT6: "MedSlot6",
  MED_SLOT7: "MedSlot7",
  QUAFE_BAY: "QuafeBay",
  RIG_SLOT0: "RigSlot0",
  RIG_SLOT1: "RigSlot1",
  RIG_SLOT2: "RigSlot2",
  RIG_SLOT3: "RigSlot3",
  RIG_SLOT4: "RigSlot4",
  RIG_SLOT5: "RigSlot5",
  RIG_SLOT6: "RigSlot6",
  RIG_SLOT7: "RigSlot7",
  SHIP_HANGAR: "ShipHangar",
  SKILL: "Skill",
  SPECIALIZED_AMMO_HOLD: "SpecializedAmmoHold",
  SPECIALIZED_ASTEROID_HOLD: "SpecializedAsteroidHold",
  SPECIALIZED_COMMAND_CENTER_HOLD: "SpecializedCommandCenterHold",
  SPECIALIZED_FUEL_BAY: "SpecializedFuelBay",
  SPECIALIZED_GAS_HOLD: "SpecializedGasHold",
  SPECIALIZED_ICE_HOLD: "SpecializedIceHold",
  SPECIALIZED_INDUSTRIAL_SHIP_HOLD: "SpecializedIndustrialShipHold",
  SPECIALIZED_LARGE_SHIP_HOLD: "SpecializedLargeShipHold",
  SPECIALIZED_MATERIAL_BAY: "SpecializedMaterialBay",
  SPECIALIZED_MEDIUM_SHIP_HOLD: "SpecializedMediumShipHold",
  SPECIALIZED_MINERAL_HOLD: "SpecializedMineralHold",
  SPECIALIZED_ORE_HOLD: "SpecializedOreHold",
  SPECIALIZED_PLANETARY_COMMODITIES_HOLD: "SpecializedPlanetaryCommoditiesHold",
  SPECIALIZED_SALVAGE_HOLD: "SpecializedSalvageHold",
  SPECIALIZED_SHIP_HOLD: "SpecializedShipHold",
  SPECIALIZED_SMALL_SHIP_HOLD: "SpecializedSmallShipHold",
  STRUCTURE_DEED_BAY: "StructureDeedBay",
  SUB_SYSTEM_BAY: "SubSystemBay",
  SUB_SYSTEM_SLOT0: "SubSystemSlot0",
  SUB_SYSTEM_SLOT1: "SubSystemSlot1",
  SUB_SYSTEM_SLOT2: "SubSystemSlot2",
  SUB_SYSTEM_SLOT3: "SubSystemSlot3",
  SUB_SYSTEM_SLOT4: "SubSystemSlot4",
  SUB_SYSTEM_SLOT5: "SubSystemSlot5",
  SUB_SYSTEM_SLOT6: "SubSystemSlot6",
  SUB_SYSTEM_SLOT7: "SubSystemSlot7",
  UNLOCKED: "Unlocked",
  WARDROBE: "Wardrobe",
} as const;

export type GetCharactersCharacterIdAssets200OkLocationFlagEnum =
  typeof GetCharactersCharacterIdAssets200OkLocationFlagEnum[keyof typeof GetCharactersCharacterIdAssets200OkLocationFlagEnum];
export const GetCharactersCharacterIdAssets200OkLocationTypeEnum = {
  STATION: "station",
  SOLAR_SYSTEM: "solar_system",
  ITEM: "item",
  OTHER: "other",
} as const;

export type GetCharactersCharacterIdAssets200OkLocationTypeEnum =
  typeof GetCharactersCharacterIdAssets200OkLocationTypeEnum[keyof typeof GetCharactersCharacterIdAssets200OkLocationTypeEnum];

/**
 * Requested page does not exist
 * @export
 * @interface GetCharactersCharacterIdAssetsNotFound
 */
export interface GetCharactersCharacterIdAssetsNotFound {
  /**
   * error message
   * @type {string}
   * @memberof GetCharactersCharacterIdAssetsNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdAttributesOk
 */
export interface GetCharactersCharacterIdAttributesOk {
  /**
   * Neural remapping cooldown after a character uses remap accrued over time
   * @type {string}
   * @memberof GetCharactersCharacterIdAttributesOk
   */
  accrued_remap_cooldown_date?: string;
  /**
   * Number of available bonus character neural remaps
   * @type {number}
   * @memberof GetCharactersCharacterIdAttributesOk
   */
  bonus_remaps?: number;
  /**
   * charisma integer
   * @type {number}
   * @memberof GetCharactersCharacterIdAttributesOk
   */
  charisma: number;
  /**
   * intelligence integer
   * @type {number}
   * @memberof GetCharactersCharacterIdAttributesOk
   */
  intelligence: number;
  /**
   * Datetime of last neural remap, including usage of bonus remaps
   * @type {string}
   * @memberof GetCharactersCharacterIdAttributesOk
   */
  last_remap_date?: string;
  /**
   * memory integer
   * @type {number}
   * @memberof GetCharactersCharacterIdAttributesOk
   */
  memory: number;
  /**
   * perception integer
   * @type {number}
   * @memberof GetCharactersCharacterIdAttributesOk
   */
  perception: number;
  /**
   * willpower integer
   * @type {number}
   * @memberof GetCharactersCharacterIdAttributesOk
   */
  willpower: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdBlueprints200Ok
 */
export interface GetCharactersCharacterIdBlueprints200Ok {
  /**
   * Unique ID for this item.
   * @type {number}
   * @memberof GetCharactersCharacterIdBlueprints200Ok
   */
  item_id: number;
  /**
   * Type of the location_id
   * @type {string}
   * @memberof GetCharactersCharacterIdBlueprints200Ok
   */
  location_flag: GetCharactersCharacterIdBlueprints200OkLocationFlagEnum;
  /**
   * References a station, a ship or an item_id if this blueprint is located within a container. If the return value is an item_id, then the Character AssetList API must be queried to find the container using the given item_id to determine the correct location of the Blueprint.
   * @type {number}
   * @memberof GetCharactersCharacterIdBlueprints200Ok
   */
  location_id: number;
  /**
   * Material Efficiency Level of the blueprint.
   * @type {number}
   * @memberof GetCharactersCharacterIdBlueprints200Ok
   */
  material_efficiency: number;
  /**
   * A range of numbers with a minimum of -2 and no maximum value where -1 is an original and -2 is a copy. It can be a positive integer if it is a stack of blueprint originals fresh from the market (e.g. no activities performed on them yet).
   * @type {number}
   * @memberof GetCharactersCharacterIdBlueprints200Ok
   */
  quantity: number;
  /**
   * Number of runs remaining if the blueprint is a copy, -1 if it is an original.
   * @type {number}
   * @memberof GetCharactersCharacterIdBlueprints200Ok
   */
  runs: number;
  /**
   * Time Efficiency Level of the blueprint.
   * @type {number}
   * @memberof GetCharactersCharacterIdBlueprints200Ok
   */
  time_efficiency: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdBlueprints200Ok
   */
  type_id: number;
}

export const GetCharactersCharacterIdBlueprints200OkLocationFlagEnum = {
  AUTO_FIT: "AutoFit",
  CARGO: "Cargo",
  CORPSE_BAY: "CorpseBay",
  DRONE_BAY: "DroneBay",
  FLEET_HANGAR: "FleetHangar",
  DELIVERIES: "Deliveries",
  HIDDEN_MODIFIERS: "HiddenModifiers",
  HANGAR: "Hangar",
  HANGAR_ALL: "HangarAll",
  LO_SLOT0: "LoSlot0",
  LO_SLOT1: "LoSlot1",
  LO_SLOT2: "LoSlot2",
  LO_SLOT3: "LoSlot3",
  LO_SLOT4: "LoSlot4",
  LO_SLOT5: "LoSlot5",
  LO_SLOT6: "LoSlot6",
  LO_SLOT7: "LoSlot7",
  MED_SLOT0: "MedSlot0",
  MED_SLOT1: "MedSlot1",
  MED_SLOT2: "MedSlot2",
  MED_SLOT3: "MedSlot3",
  MED_SLOT4: "MedSlot4",
  MED_SLOT5: "MedSlot5",
  MED_SLOT6: "MedSlot6",
  MED_SLOT7: "MedSlot7",
  HI_SLOT0: "HiSlot0",
  HI_SLOT1: "HiSlot1",
  HI_SLOT2: "HiSlot2",
  HI_SLOT3: "HiSlot3",
  HI_SLOT4: "HiSlot4",
  HI_SLOT5: "HiSlot5",
  HI_SLOT6: "HiSlot6",
  HI_SLOT7: "HiSlot7",
  ASSET_SAFETY: "AssetSafety",
  LOCKED: "Locked",
  UNLOCKED: "Unlocked",
  IMPLANT: "Implant",
  QUAFE_BAY: "QuafeBay",
  RIG_SLOT0: "RigSlot0",
  RIG_SLOT1: "RigSlot1",
  RIG_SLOT2: "RigSlot2",
  RIG_SLOT3: "RigSlot3",
  RIG_SLOT4: "RigSlot4",
  RIG_SLOT5: "RigSlot5",
  RIG_SLOT6: "RigSlot6",
  RIG_SLOT7: "RigSlot7",
  SHIP_HANGAR: "ShipHangar",
  SPECIALIZED_FUEL_BAY: "SpecializedFuelBay",
  SPECIALIZED_ORE_HOLD: "SpecializedOreHold",
  SPECIALIZED_GAS_HOLD: "SpecializedGasHold",
  SPECIALIZED_MINERAL_HOLD: "SpecializedMineralHold",
  SPECIALIZED_SALVAGE_HOLD: "SpecializedSalvageHold",
  SPECIALIZED_SHIP_HOLD: "SpecializedShipHold",
  SPECIALIZED_SMALL_SHIP_HOLD: "SpecializedSmallShipHold",
  SPECIALIZED_MEDIUM_SHIP_HOLD: "SpecializedMediumShipHold",
  SPECIALIZED_LARGE_SHIP_HOLD: "SpecializedLargeShipHold",
  SPECIALIZED_INDUSTRIAL_SHIP_HOLD: "SpecializedIndustrialShipHold",
  SPECIALIZED_AMMO_HOLD: "SpecializedAmmoHold",
  SPECIALIZED_COMMAND_CENTER_HOLD: "SpecializedCommandCenterHold",
  SPECIALIZED_PLANETARY_COMMODITIES_HOLD: "SpecializedPlanetaryCommoditiesHold",
  SPECIALIZED_MATERIAL_BAY: "SpecializedMaterialBay",
  SUB_SYSTEM_SLOT0: "SubSystemSlot0",
  SUB_SYSTEM_SLOT1: "SubSystemSlot1",
  SUB_SYSTEM_SLOT2: "SubSystemSlot2",
  SUB_SYSTEM_SLOT3: "SubSystemSlot3",
  SUB_SYSTEM_SLOT4: "SubSystemSlot4",
  SUB_SYSTEM_SLOT5: "SubSystemSlot5",
  SUB_SYSTEM_SLOT6: "SubSystemSlot6",
  SUB_SYSTEM_SLOT7: "SubSystemSlot7",
  FIGHTER_BAY: "FighterBay",
  FIGHTER_TUBE0: "FighterTube0",
  FIGHTER_TUBE1: "FighterTube1",
  FIGHTER_TUBE2: "FighterTube2",
  FIGHTER_TUBE3: "FighterTube3",
  FIGHTER_TUBE4: "FighterTube4",
  MODULE: "Module",
} as const;

export type GetCharactersCharacterIdBlueprints200OkLocationFlagEnum =
  typeof GetCharactersCharacterIdBlueprints200OkLocationFlagEnum[keyof typeof GetCharactersCharacterIdBlueprints200OkLocationFlagEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdBookmarks200Ok
 */
export interface GetCharactersCharacterIdBookmarks200Ok {
  /**
   * bookmark_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdBookmarks200Ok
   */
  bookmark_id: number;
  /**
   *
   * @type {GetCharactersCharacterIdBookmarksCoordinates}
   * @memberof GetCharactersCharacterIdBookmarks200Ok
   */
  coordinates?: GetCharactersCharacterIdBookmarksCoordinates;
  /**
   * created string
   * @type {string}
   * @memberof GetCharactersCharacterIdBookmarks200Ok
   */
  created: string;
  /**
   * creator_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdBookmarks200Ok
   */
  creator_id: number;
  /**
   * folder_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdBookmarks200Ok
   */
  folder_id?: number;
  /**
   *
   * @type {GetCharactersCharacterIdBookmarksItem}
   * @memberof GetCharactersCharacterIdBookmarks200Ok
   */
  item?: GetCharactersCharacterIdBookmarksItem;
  /**
   * label string
   * @type {string}
   * @memberof GetCharactersCharacterIdBookmarks200Ok
   */
  label: string;
  /**
   * location_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdBookmarks200Ok
   */
  location_id: number;
  /**
   * notes string
   * @type {string}
   * @memberof GetCharactersCharacterIdBookmarks200Ok
   */
  notes: string;
}
/**
 * Optional object that is returned if a bookmark was made on a planet or a random location in space.
 * @export
 * @interface GetCharactersCharacterIdBookmarksCoordinates
 */
export interface GetCharactersCharacterIdBookmarksCoordinates {
  /**
   * x number
   * @type {number}
   * @memberof GetCharactersCharacterIdBookmarksCoordinates
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof GetCharactersCharacterIdBookmarksCoordinates
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof GetCharactersCharacterIdBookmarksCoordinates
   */
  z: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdBookmarksFolders200Ok
 */
export interface GetCharactersCharacterIdBookmarksFolders200Ok {
  /**
   * folder_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdBookmarksFolders200Ok
   */
  folder_id: number;
  /**
   * name string
   * @type {string}
   * @memberof GetCharactersCharacterIdBookmarksFolders200Ok
   */
  name: string;
}
/**
 * Optional object that is returned if a bookmark was made on a particular item.
 * @export
 * @interface GetCharactersCharacterIdBookmarksItem
 */
export interface GetCharactersCharacterIdBookmarksItem {
  /**
   * item_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdBookmarksItem
   */
  item_id: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdBookmarksItem
   */
  type_id: number;
}
/**
 * event
 * @export
 * @interface GetCharactersCharacterIdCalendar200Ok
 */
export interface GetCharactersCharacterIdCalendar200Ok {
  /**
   * event_date string
   * @type {string}
   * @memberof GetCharactersCharacterIdCalendar200Ok
   */
  event_date?: string;
  /**
   * event_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdCalendar200Ok
   */
  event_id?: number;
  /**
   * event_response string
   * @type {string}
   * @memberof GetCharactersCharacterIdCalendar200Ok
   */
  event_response?: GetCharactersCharacterIdCalendar200OkEventResponseEnum;
  /**
   * importance integer
   * @type {number}
   * @memberof GetCharactersCharacterIdCalendar200Ok
   */
  importance?: number;
  /**
   * title string
   * @type {string}
   * @memberof GetCharactersCharacterIdCalendar200Ok
   */
  title?: string;
}

export const GetCharactersCharacterIdCalendar200OkEventResponseEnum = {
  DECLINED: "declined",
  NOT_RESPONDED: "not_responded",
  ACCEPTED: "accepted",
  TENTATIVE: "tentative",
} as const;

export type GetCharactersCharacterIdCalendar200OkEventResponseEnum =
  typeof GetCharactersCharacterIdCalendar200OkEventResponseEnum[keyof typeof GetCharactersCharacterIdCalendar200OkEventResponseEnum];

/**
 * character_id and response of an attendee
 * @export
 * @interface GetCharactersCharacterIdCalendarEventIdAttendees200Ok
 */
export interface GetCharactersCharacterIdCalendarEventIdAttendees200Ok {
  /**
   * character_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdCalendarEventIdAttendees200Ok
   */
  character_id?: number;
  /**
   * event_response string
   * @type {string}
   * @memberof GetCharactersCharacterIdCalendarEventIdAttendees200Ok
   */
  event_response?: GetCharactersCharacterIdCalendarEventIdAttendees200OkEventResponseEnum;
}

export const GetCharactersCharacterIdCalendarEventIdAttendees200OkEventResponseEnum =
  {
    DECLINED: "declined",
    NOT_RESPONDED: "not_responded",
    ACCEPTED: "accepted",
    TENTATIVE: "tentative",
  } as const;

export type GetCharactersCharacterIdCalendarEventIdAttendees200OkEventResponseEnum =
  typeof GetCharactersCharacterIdCalendarEventIdAttendees200OkEventResponseEnum[keyof typeof GetCharactersCharacterIdCalendarEventIdAttendees200OkEventResponseEnum];

/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdCalendarEventIdAttendeesNotFound
 */
export interface GetCharactersCharacterIdCalendarEventIdAttendeesNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetCharactersCharacterIdCalendarEventIdAttendeesNotFound
   */
  error?: string;
}
/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdCalendarEventIdNotFound
 */
export interface GetCharactersCharacterIdCalendarEventIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetCharactersCharacterIdCalendarEventIdNotFound
   */
  error?: string;
}
/**
 * Full details of a specific event
 * @export
 * @interface GetCharactersCharacterIdCalendarEventIdOk
 */
export interface GetCharactersCharacterIdCalendarEventIdOk {
  /**
   * date string
   * @type {string}
   * @memberof GetCharactersCharacterIdCalendarEventIdOk
   */
  date: string;
  /**
   * Length in minutes
   * @type {number}
   * @memberof GetCharactersCharacterIdCalendarEventIdOk
   */
  duration: number;
  /**
   * event_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdCalendarEventIdOk
   */
  event_id: number;
  /**
   * importance integer
   * @type {number}
   * @memberof GetCharactersCharacterIdCalendarEventIdOk
   */
  importance: number;
  /**
   * owner_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdCalendarEventIdOk
   */
  owner_id: number;
  /**
   * owner_name string
   * @type {string}
   * @memberof GetCharactersCharacterIdCalendarEventIdOk
   */
  owner_name: string;
  /**
   * owner_type string
   * @type {string}
   * @memberof GetCharactersCharacterIdCalendarEventIdOk
   */
  owner_type: GetCharactersCharacterIdCalendarEventIdOkOwnerTypeEnum;
  /**
   * response string
   * @type {string}
   * @memberof GetCharactersCharacterIdCalendarEventIdOk
   */
  response: string;
  /**
   * text string
   * @type {string}
   * @memberof GetCharactersCharacterIdCalendarEventIdOk
   */
  text: string;
  /**
   * title string
   * @type {string}
   * @memberof GetCharactersCharacterIdCalendarEventIdOk
   */
  title: string;
}

export const GetCharactersCharacterIdCalendarEventIdOkOwnerTypeEnum = {
  EVE_SERVER: "eve_server",
  CORPORATION: "corporation",
  FACTION: "faction",
  CHARACTER: "character",
  ALLIANCE: "alliance",
} as const;

export type GetCharactersCharacterIdCalendarEventIdOkOwnerTypeEnum =
  typeof GetCharactersCharacterIdCalendarEventIdOkOwnerTypeEnum[keyof typeof GetCharactersCharacterIdCalendarEventIdOkOwnerTypeEnum];

/**
 * home_location object
 * @export
 * @interface GetCharactersCharacterIdClonesHomeLocation
 */
export interface GetCharactersCharacterIdClonesHomeLocation {
  /**
   * location_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdClonesHomeLocation
   */
  location_id?: number;
  /**
   * location_type string
   * @type {string}
   * @memberof GetCharactersCharacterIdClonesHomeLocation
   */
  location_type?: GetCharactersCharacterIdClonesHomeLocationLocationTypeEnum;
}

export const GetCharactersCharacterIdClonesHomeLocationLocationTypeEnum = {
  STATION: "station",
  STRUCTURE: "structure",
} as const;

export type GetCharactersCharacterIdClonesHomeLocationLocationTypeEnum =
  typeof GetCharactersCharacterIdClonesHomeLocationLocationTypeEnum[keyof typeof GetCharactersCharacterIdClonesHomeLocationLocationTypeEnum];

/**
 * jump_clone object
 * @export
 * @interface GetCharactersCharacterIdClonesJumpClone
 */
export interface GetCharactersCharacterIdClonesJumpClone {
  /**
   * implants array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdClonesJumpClone
   */
  implants: Array<number>;
  /**
   * jump_clone_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdClonesJumpClone
   */
  jump_clone_id: number;
  /**
   * location_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdClonesJumpClone
   */
  location_id: number;
  /**
   * location_type string
   * @type {string}
   * @memberof GetCharactersCharacterIdClonesJumpClone
   */
  location_type: GetCharactersCharacterIdClonesJumpCloneLocationTypeEnum;
  /**
   * name string
   * @type {string}
   * @memberof GetCharactersCharacterIdClonesJumpClone
   */
  name?: string;
}

export const GetCharactersCharacterIdClonesJumpCloneLocationTypeEnum = {
  STATION: "station",
  STRUCTURE: "structure",
} as const;

export type GetCharactersCharacterIdClonesJumpCloneLocationTypeEnum =
  typeof GetCharactersCharacterIdClonesJumpCloneLocationTypeEnum[keyof typeof GetCharactersCharacterIdClonesJumpCloneLocationTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdClonesOk
 */
export interface GetCharactersCharacterIdClonesOk {
  /**
   *
   * @type {GetCharactersCharacterIdClonesHomeLocation}
   * @memberof GetCharactersCharacterIdClonesOk
   */
  home_location?: GetCharactersCharacterIdClonesHomeLocation;
  /**
   * jump_clones array
   * @type {Array<GetCharactersCharacterIdClonesJumpClone>}
   * @memberof GetCharactersCharacterIdClonesOk
   */
  jump_clones: Array<GetCharactersCharacterIdClonesJumpClone>;
  /**
   * last_clone_jump_date string
   * @type {string}
   * @memberof GetCharactersCharacterIdClonesOk
   */
  last_clone_jump_date?: string;
  /**
   * last_station_change_date string
   * @type {string}
   * @memberof GetCharactersCharacterIdClonesOk
   */
  last_station_change_date?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdContacts200Ok
 */
export interface GetCharactersCharacterIdContacts200Ok {
  /**
   * contact_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdContacts200Ok
   */
  contact_id: number;
  /**
   * contact_type string
   * @type {string}
   * @memberof GetCharactersCharacterIdContacts200Ok
   */
  contact_type: GetCharactersCharacterIdContacts200OkContactTypeEnum;
  /**
   * Whether this contact is in the blocked list. Note a missing value denotes unknown, not true or false
   * @type {boolean}
   * @memberof GetCharactersCharacterIdContacts200Ok
   */
  is_blocked?: boolean;
  /**
   * Whether this contact is being watched
   * @type {boolean}
   * @memberof GetCharactersCharacterIdContacts200Ok
   */
  is_watched?: boolean;
  /**
   * label_ids array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdContacts200Ok
   */
  label_ids?: Array<number>;
  /**
   * Standing of the contact
   * @type {number}
   * @memberof GetCharactersCharacterIdContacts200Ok
   */
  standing: number;
}

export const GetCharactersCharacterIdContacts200OkContactTypeEnum = {
  CHARACTER: "character",
  CORPORATION: "corporation",
  ALLIANCE: "alliance",
  FACTION: "faction",
} as const;

export type GetCharactersCharacterIdContacts200OkContactTypeEnum =
  typeof GetCharactersCharacterIdContacts200OkContactTypeEnum[keyof typeof GetCharactersCharacterIdContacts200OkContactTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdContactsLabels200Ok
 */
export interface GetCharactersCharacterIdContactsLabels200Ok {
  /**
   * label_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdContactsLabels200Ok
   */
  label_id: number;
  /**
   * label_name string
   * @type {string}
   * @memberof GetCharactersCharacterIdContactsLabels200Ok
   */
  label_name: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdContracts200Ok
 */
export interface GetCharactersCharacterIdContracts200Ok {
  /**
   * Who will accept the contract
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  acceptor_id: number;
  /**
   * ID to whom the contract is assigned, can be alliance, corporation or character ID
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  assignee_id: number;
  /**
   * To whom the contract is available
   * @type {string}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  availability: GetCharactersCharacterIdContracts200OkAvailabilityEnum;
  /**
   * Buyout price (for Auctions only)
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  buyout?: number;
  /**
   * Collateral price (for Couriers only)
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  collateral?: number;
  /**
   * contract_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  contract_id: number;
  /**
   * Date of confirmation of contract
   * @type {string}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  date_accepted?: string;
  /**
   * Date of completed of contract
   * @type {string}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  date_completed?: string;
  /**
   * Expiration date of the contract
   * @type {string}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  date_expired: string;
  /**
   * Сreation date of the contract
   * @type {string}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  date_issued: string;
  /**
   * Number of days to perform the contract
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  days_to_complete?: number;
  /**
   * End location ID (for Couriers contract)
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  end_location_id?: number;
  /**
   * true if the contract was issued on behalf of the issuer\'s corporation
   * @type {boolean}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  for_corporation: boolean;
  /**
   * Character\'s corporation ID for the issuer
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  issuer_corporation_id: number;
  /**
   * Character ID for the issuer
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  issuer_id: number;
  /**
   * Price of contract (for ItemsExchange and Auctions)
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  price?: number;
  /**
   * Remuneration for contract (for Couriers only)
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  reward?: number;
  /**
   * Start location ID (for Couriers contract)
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  start_location_id?: number;
  /**
   * Status of the the contract
   * @type {string}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  status: GetCharactersCharacterIdContracts200OkStatusEnum;
  /**
   * Title of the contract
   * @type {string}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  title?: string;
  /**
   * Type of the contract
   * @type {string}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  type: GetCharactersCharacterIdContracts200OkTypeEnum;
  /**
   * Volume of items in the contract
   * @type {number}
   * @memberof GetCharactersCharacterIdContracts200Ok
   */
  volume?: number;
}

export const GetCharactersCharacterIdContracts200OkAvailabilityEnum = {
  PUBLIC: "public",
  PERSONAL: "personal",
  CORPORATION: "corporation",
  ALLIANCE: "alliance",
} as const;

export type GetCharactersCharacterIdContracts200OkAvailabilityEnum =
  typeof GetCharactersCharacterIdContracts200OkAvailabilityEnum[keyof typeof GetCharactersCharacterIdContracts200OkAvailabilityEnum];
export const GetCharactersCharacterIdContracts200OkStatusEnum = {
  OUTSTANDING: "outstanding",
  IN_PROGRESS: "in_progress",
  FINISHED_ISSUER: "finished_issuer",
  FINISHED_CONTRACTOR: "finished_contractor",
  FINISHED: "finished",
  CANCELLED: "cancelled",
  REJECTED: "rejected",
  FAILED: "failed",
  DELETED: "deleted",
  REVERSED: "reversed",
} as const;

export type GetCharactersCharacterIdContracts200OkStatusEnum =
  typeof GetCharactersCharacterIdContracts200OkStatusEnum[keyof typeof GetCharactersCharacterIdContracts200OkStatusEnum];
export const GetCharactersCharacterIdContracts200OkTypeEnum = {
  UNKNOWN: "unknown",
  ITEM_EXCHANGE: "item_exchange",
  AUCTION: "auction",
  COURIER: "courier",
  LOAN: "loan",
} as const;

export type GetCharactersCharacterIdContracts200OkTypeEnum =
  typeof GetCharactersCharacterIdContracts200OkTypeEnum[keyof typeof GetCharactersCharacterIdContracts200OkTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdContractsContractIdBids200Ok
 */
export interface GetCharactersCharacterIdContractsContractIdBids200Ok {
  /**
   * The amount bid, in ISK
   * @type {number}
   * @memberof GetCharactersCharacterIdContractsContractIdBids200Ok
   */
  amount: number;
  /**
   * Unique ID for the bid
   * @type {number}
   * @memberof GetCharactersCharacterIdContractsContractIdBids200Ok
   */
  bid_id: number;
  /**
   * Character ID of the bidder
   * @type {number}
   * @memberof GetCharactersCharacterIdContractsContractIdBids200Ok
   */
  bidder_id: number;
  /**
   * Datetime when the bid was placed
   * @type {string}
   * @memberof GetCharactersCharacterIdContractsContractIdBids200Ok
   */
  date_bid: string;
}
/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdContractsContractIdBidsNotFound
 */
export interface GetCharactersCharacterIdContractsContractIdBidsNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetCharactersCharacterIdContractsContractIdBidsNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdContractsContractIdItems200Ok
 */
export interface GetCharactersCharacterIdContractsContractIdItems200Ok {
  /**
   * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract
   * @type {boolean}
   * @memberof GetCharactersCharacterIdContractsContractIdItems200Ok
   */
  is_included: boolean;
  /**
   * is_singleton boolean
   * @type {boolean}
   * @memberof GetCharactersCharacterIdContractsContractIdItems200Ok
   */
  is_singleton: boolean;
  /**
   * Number of items in the stack
   * @type {number}
   * @memberof GetCharactersCharacterIdContractsContractIdItems200Ok
   */
  quantity: number;
  /**
   * -1 indicates that the item is a singleton (non-stackable). If the item happens to be a Blueprint, -1 is an Original and -2 is a Blueprint Copy
   * @type {number}
   * @memberof GetCharactersCharacterIdContractsContractIdItems200Ok
   */
  raw_quantity?: number;
  /**
   * Unique ID for the item
   * @type {number}
   * @memberof GetCharactersCharacterIdContractsContractIdItems200Ok
   */
  record_id: number;
  /**
   * Type ID for item
   * @type {number}
   * @memberof GetCharactersCharacterIdContractsContractIdItems200Ok
   */
  type_id: number;
}
/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdContractsContractIdItemsNotFound
 */
export interface GetCharactersCharacterIdContractsContractIdItemsNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetCharactersCharacterIdContractsContractIdItemsNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdCorporationhistory200Ok
 */
export interface GetCharactersCharacterIdCorporationhistory200Ok {
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdCorporationhistory200Ok
   */
  corporation_id: number;
  /**
   * True if the corporation has been deleted
   * @type {boolean}
   * @memberof GetCharactersCharacterIdCorporationhistory200Ok
   */
  is_deleted?: boolean;
  /**
   * An incrementing ID that can be used to canonically establish order of records in cases where dates may be ambiguous
   * @type {number}
   * @memberof GetCharactersCharacterIdCorporationhistory200Ok
   */
  record_id: number;
  /**
   * start_date string
   * @type {string}
   * @memberof GetCharactersCharacterIdCorporationhistory200Ok
   */
  start_date: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdFatigueOk
 */
export interface GetCharactersCharacterIdFatigueOk {
  /**
   * Character\'s jump fatigue expiry
   * @type {string}
   * @memberof GetCharactersCharacterIdFatigueOk
   */
  jump_fatigue_expire_date?: string;
  /**
   * Character\'s last jump activation
   * @type {string}
   * @memberof GetCharactersCharacterIdFatigueOk
   */
  last_jump_date?: string;
  /**
   * Character\'s last jump update
   * @type {string}
   * @memberof GetCharactersCharacterIdFatigueOk
   */
  last_update_date?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdFittings200Ok
 */
export interface GetCharactersCharacterIdFittings200Ok {
  /**
   * description string
   * @type {string}
   * @memberof GetCharactersCharacterIdFittings200Ok
   */
  description: string;
  /**
   * fitting_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdFittings200Ok
   */
  fitting_id: number;
  /**
   * items array
   * @type {Array<GetCharactersCharacterIdFittingsItem>}
   * @memberof GetCharactersCharacterIdFittings200Ok
   */
  items: Array<GetCharactersCharacterIdFittingsItem>;
  /**
   * name string
   * @type {string}
   * @memberof GetCharactersCharacterIdFittings200Ok
   */
  name: string;
  /**
   * ship_type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdFittings200Ok
   */
  ship_type_id: number;
}
/**
 * item object
 * @export
 * @interface GetCharactersCharacterIdFittingsItem
 */
export interface GetCharactersCharacterIdFittingsItem {
  /**
   * flag string
   * @type {string}
   * @memberof GetCharactersCharacterIdFittingsItem
   */
  flag: GetCharactersCharacterIdFittingsItemFlagEnum;
  /**
   * quantity integer
   * @type {number}
   * @memberof GetCharactersCharacterIdFittingsItem
   */
  quantity: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdFittingsItem
   */
  type_id: number;
}

export const GetCharactersCharacterIdFittingsItemFlagEnum = {
  CARGO: "Cargo",
  DRONE_BAY: "DroneBay",
  FIGHTER_BAY: "FighterBay",
  HI_SLOT0: "HiSlot0",
  HI_SLOT1: "HiSlot1",
  HI_SLOT2: "HiSlot2",
  HI_SLOT3: "HiSlot3",
  HI_SLOT4: "HiSlot4",
  HI_SLOT5: "HiSlot5",
  HI_SLOT6: "HiSlot6",
  HI_SLOT7: "HiSlot7",
  INVALID: "Invalid",
  LO_SLOT0: "LoSlot0",
  LO_SLOT1: "LoSlot1",
  LO_SLOT2: "LoSlot2",
  LO_SLOT3: "LoSlot3",
  LO_SLOT4: "LoSlot4",
  LO_SLOT5: "LoSlot5",
  LO_SLOT6: "LoSlot6",
  LO_SLOT7: "LoSlot7",
  MED_SLOT0: "MedSlot0",
  MED_SLOT1: "MedSlot1",
  MED_SLOT2: "MedSlot2",
  MED_SLOT3: "MedSlot3",
  MED_SLOT4: "MedSlot4",
  MED_SLOT5: "MedSlot5",
  MED_SLOT6: "MedSlot6",
  MED_SLOT7: "MedSlot7",
  RIG_SLOT0: "RigSlot0",
  RIG_SLOT1: "RigSlot1",
  RIG_SLOT2: "RigSlot2",
  SERVICE_SLOT0: "ServiceSlot0",
  SERVICE_SLOT1: "ServiceSlot1",
  SERVICE_SLOT2: "ServiceSlot2",
  SERVICE_SLOT3: "ServiceSlot3",
  SERVICE_SLOT4: "ServiceSlot4",
  SERVICE_SLOT5: "ServiceSlot5",
  SERVICE_SLOT6: "ServiceSlot6",
  SERVICE_SLOT7: "ServiceSlot7",
  SUB_SYSTEM_SLOT0: "SubSystemSlot0",
  SUB_SYSTEM_SLOT1: "SubSystemSlot1",
  SUB_SYSTEM_SLOT2: "SubSystemSlot2",
  SUB_SYSTEM_SLOT3: "SubSystemSlot3",
} as const;

export type GetCharactersCharacterIdFittingsItemFlagEnum =
  typeof GetCharactersCharacterIdFittingsItemFlagEnum[keyof typeof GetCharactersCharacterIdFittingsItemFlagEnum];

/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdFleetNotFound
 */
export interface GetCharactersCharacterIdFleetNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetCharactersCharacterIdFleetNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdFleetOk
 */
export interface GetCharactersCharacterIdFleetOk {
  /**
   * The character\'s current fleet ID
   * @type {number}
   * @memberof GetCharactersCharacterIdFleetOk
   */
  fleet_id: number;
  /**
   * Member’s role in fleet
   * @type {string}
   * @memberof GetCharactersCharacterIdFleetOk
   */
  role: GetCharactersCharacterIdFleetOkRoleEnum;
  /**
   * ID of the squad the member is in. If not applicable, will be set to -1
   * @type {number}
   * @memberof GetCharactersCharacterIdFleetOk
   */
  squad_id: number;
  /**
   * ID of the wing the member is in. If not applicable, will be set to -1
   * @type {number}
   * @memberof GetCharactersCharacterIdFleetOk
   */
  wing_id: number;
}

export const GetCharactersCharacterIdFleetOkRoleEnum = {
  FLEET_COMMANDER: "fleet_commander",
  SQUAD_COMMANDER: "squad_commander",
  SQUAD_MEMBER: "squad_member",
  WING_COMMANDER: "wing_commander",
} as const;

export type GetCharactersCharacterIdFleetOkRoleEnum =
  typeof GetCharactersCharacterIdFleetOkRoleEnum[keyof typeof GetCharactersCharacterIdFleetOkRoleEnum];

/**
 * Summary of kills done by the given character against enemy factions
 * @export
 * @interface GetCharactersCharacterIdFwStatsKills
 */
export interface GetCharactersCharacterIdFwStatsKills {
  /**
   * Last week\'s total number of kills by a given character against enemy factions
   * @type {number}
   * @memberof GetCharactersCharacterIdFwStatsKills
   */
  last_week: number;
  /**
   * Total number of kills by a given character against enemy factions since the character enlisted
   * @type {number}
   * @memberof GetCharactersCharacterIdFwStatsKills
   */
  total: number;
  /**
   * Yesterday\'s total number of kills by a given character against enemy factions
   * @type {number}
   * @memberof GetCharactersCharacterIdFwStatsKills
   */
  yesterday: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdFwStatsOk
 */
export interface GetCharactersCharacterIdFwStatsOk {
  /**
   * The given character\'s current faction rank
   * @type {number}
   * @memberof GetCharactersCharacterIdFwStatsOk
   */
  current_rank?: number;
  /**
   * The enlistment date of the given character into faction warfare. Will not be included if character is not enlisted in faction warfare
   * @type {string}
   * @memberof GetCharactersCharacterIdFwStatsOk
   */
  enlisted_on?: string;
  /**
   * The faction the given character is enlisted to fight for. Will not be included if character is not enlisted in faction warfare
   * @type {number}
   * @memberof GetCharactersCharacterIdFwStatsOk
   */
  faction_id?: number;
  /**
   * The given character\'s highest faction rank achieved
   * @type {number}
   * @memberof GetCharactersCharacterIdFwStatsOk
   */
  highest_rank?: number;
  /**
   *
   * @type {GetCharactersCharacterIdFwStatsKills}
   * @memberof GetCharactersCharacterIdFwStatsOk
   */
  kills: GetCharactersCharacterIdFwStatsKills;
  /**
   *
   * @type {GetCharactersCharacterIdFwStatsVictoryPoints}
   * @memberof GetCharactersCharacterIdFwStatsOk
   */
  victory_points: GetCharactersCharacterIdFwStatsVictoryPoints;
}
/**
 * Summary of victory points gained by the given character for the enlisted faction
 * @export
 * @interface GetCharactersCharacterIdFwStatsVictoryPoints
 */
export interface GetCharactersCharacterIdFwStatsVictoryPoints {
  /**
   * Last week\'s victory points gained by the given character
   * @type {number}
   * @memberof GetCharactersCharacterIdFwStatsVictoryPoints
   */
  last_week: number;
  /**
   * Total victory points gained since the given character enlisted
   * @type {number}
   * @memberof GetCharactersCharacterIdFwStatsVictoryPoints
   */
  total: number;
  /**
   * Yesterday\'s victory points gained by the given character
   * @type {number}
   * @memberof GetCharactersCharacterIdFwStatsVictoryPoints
   */
  yesterday: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdIndustryJobs200Ok
 */
export interface GetCharactersCharacterIdIndustryJobs200Ok {
  /**
   * Job activity ID
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  activity_id: number;
  /**
   * blueprint_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  blueprint_id: number;
  /**
   * Location ID of the location from which the blueprint was installed. Normally a station ID, but can also be an asset (e.g. container) or corporation facility
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  blueprint_location_id: number;
  /**
   * blueprint_type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  blueprint_type_id: number;
  /**
   * ID of the character which completed this job
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  completed_character_id?: number;
  /**
   * Date and time when this job was completed
   * @type {string}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  completed_date?: string;
  /**
   * The sume of job installation fee and industry facility tax
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  cost?: number;
  /**
   * Job duration in seconds
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  duration: number;
  /**
   * Date and time when this job finished
   * @type {string}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  end_date: string;
  /**
   * ID of the facility where this job is running
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  facility_id: number;
  /**
   * ID of the character which installed this job
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  installer_id: number;
  /**
   * Unique job ID
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  job_id: number;
  /**
   * Number of runs blueprint is licensed for
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  licensed_runs?: number;
  /**
   * Location ID of the location to which the output of the job will be delivered. Normally a station ID, but can also be a corporation facility
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  output_location_id: number;
  /**
   * Date and time when this job was paused (i.e. time when the facility where this job was installed went offline)
   * @type {string}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  pause_date?: string;
  /**
   * Chance of success for invention
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  probability?: number;
  /**
   * Type ID of product (manufactured, copied or invented)
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  product_type_id?: number;
  /**
   * Number of runs for a manufacturing job, or number of copies to make for a blueprint copy
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  runs: number;
  /**
   * Date and time when this job started
   * @type {string}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  start_date: string;
  /**
   * ID of the station where industry facility is located
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  station_id: number;
  /**
   * status string
   * @type {string}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  status: GetCharactersCharacterIdIndustryJobs200OkStatusEnum;
  /**
   * Number of successful runs for this job. Equal to runs unless this is an invention job
   * @type {number}
   * @memberof GetCharactersCharacterIdIndustryJobs200Ok
   */
  successful_runs?: number;
}

export const GetCharactersCharacterIdIndustryJobs200OkStatusEnum = {
  ACTIVE: "active",
  CANCELLED: "cancelled",
  DELIVERED: "delivered",
  PAUSED: "paused",
  READY: "ready",
  REVERTED: "reverted",
} as const;

export type GetCharactersCharacterIdIndustryJobs200OkStatusEnum =
  typeof GetCharactersCharacterIdIndustryJobs200OkStatusEnum[keyof typeof GetCharactersCharacterIdIndustryJobs200OkStatusEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdKillmailsRecent200Ok
 */
export interface GetCharactersCharacterIdKillmailsRecent200Ok {
  /**
   * A hash of this killmail
   * @type {string}
   * @memberof GetCharactersCharacterIdKillmailsRecent200Ok
   */
  killmail_hash: string;
  /**
   * ID of this killmail
   * @type {number}
   * @memberof GetCharactersCharacterIdKillmailsRecent200Ok
   */
  killmail_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdLocationOk
 */
export interface GetCharactersCharacterIdLocationOk {
  /**
   * solar_system_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdLocationOk
   */
  solar_system_id: number;
  /**
   * station_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdLocationOk
   */
  station_id?: number;
  /**
   * structure_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdLocationOk
   */
  structure_id?: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdLoyaltyPoints200Ok
 */
export interface GetCharactersCharacterIdLoyaltyPoints200Ok {
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdLoyaltyPoints200Ok
   */
  corporation_id: number;
  /**
   * loyalty_points integer
   * @type {number}
   * @memberof GetCharactersCharacterIdLoyaltyPoints200Ok
   */
  loyalty_points: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdMail200Ok
 */
export interface GetCharactersCharacterIdMail200Ok {
  /**
   * From whom the mail was sent
   * @type {number}
   * @memberof GetCharactersCharacterIdMail200Ok
   */
  from?: number;
  /**
   * is_read boolean
   * @type {boolean}
   * @memberof GetCharactersCharacterIdMail200Ok
   */
  is_read?: boolean;
  /**
   * labels array
   * @type {Set<number>}
   * @memberof GetCharactersCharacterIdMail200Ok
   */
  labels?: Set<number>;
  /**
   * mail_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMail200Ok
   */
  mail_id?: number;
  /**
   * Recipients of the mail
   * @type {Set<GetCharactersCharacterIdMailRecipient>}
   * @memberof GetCharactersCharacterIdMail200Ok
   */
  recipients?: Set<GetCharactersCharacterIdMailRecipient>;
  /**
   * Mail subject
   * @type {string}
   * @memberof GetCharactersCharacterIdMail200Ok
   */
  subject?: string;
  /**
   * When the mail was sent
   * @type {string}
   * @memberof GetCharactersCharacterIdMail200Ok
   */
  timestamp?: string;
}
/**
 * label object
 * @export
 * @interface GetCharactersCharacterIdMailLabelsLabel
 */
export interface GetCharactersCharacterIdMailLabelsLabel {
  /**
   * color string
   * @type {string}
   * @memberof GetCharactersCharacterIdMailLabelsLabel
   */
  color?: GetCharactersCharacterIdMailLabelsLabelColorEnum;
  /**
   * label_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMailLabelsLabel
   */
  label_id?: number;
  /**
   * name string
   * @type {string}
   * @memberof GetCharactersCharacterIdMailLabelsLabel
   */
  name?: string;
  /**
   * unread_count integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMailLabelsLabel
   */
  unread_count?: number;
}

export const GetCharactersCharacterIdMailLabelsLabelColorEnum = {
  _0000FE: "#0000fe",
  _006634: "#006634",
  _0099FF: "#0099ff",
  _00FF33: "#00ff33",
  _01FFFF: "#01ffff",
  _349800: "#349800",
  _660066: "#660066",
  _666666: "#666666",
  _999999: "#999999",
  _99FFFF: "#99ffff",
  _9A0000: "#9a0000",
  CCFF9A: "#ccff9a",
  E6E6E6: "#e6e6e6",
  FE0000: "#fe0000",
  FF6600: "#ff6600",
  FFFF01: "#ffff01",
  FFFFCD: "#ffffcd",
  FFFFFF: "#ffffff",
} as const;

export type GetCharactersCharacterIdMailLabelsLabelColorEnum =
  typeof GetCharactersCharacterIdMailLabelsLabelColorEnum[keyof typeof GetCharactersCharacterIdMailLabelsLabelColorEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdMailLabelsOk
 */
export interface GetCharactersCharacterIdMailLabelsOk {
  /**
   * labels array
   * @type {Array<GetCharactersCharacterIdMailLabelsLabel>}
   * @memberof GetCharactersCharacterIdMailLabelsOk
   */
  labels?: Array<GetCharactersCharacterIdMailLabelsLabel>;
  /**
   * total_unread_count integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMailLabelsOk
   */
  total_unread_count?: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdMailLists200Ok
 */
export interface GetCharactersCharacterIdMailLists200Ok {
  /**
   * Mailing list ID
   * @type {number}
   * @memberof GetCharactersCharacterIdMailLists200Ok
   */
  mailing_list_id: number;
  /**
   * name string
   * @type {string}
   * @memberof GetCharactersCharacterIdMailLists200Ok
   */
  name: string;
}
/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdMailMailIdNotFound
 */
export interface GetCharactersCharacterIdMailMailIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetCharactersCharacterIdMailMailIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdMailMailIdOk
 */
export interface GetCharactersCharacterIdMailMailIdOk {
  /**
   * Mail\'s body
   * @type {string}
   * @memberof GetCharactersCharacterIdMailMailIdOk
   */
  body?: string;
  /**
   * From whom the mail was sent
   * @type {number}
   * @memberof GetCharactersCharacterIdMailMailIdOk
   */
  from?: number;
  /**
   * Labels attached to the mail
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdMailMailIdOk
   */
  labels?: Array<number>;
  /**
   * Whether the mail is flagged as read
   * @type {boolean}
   * @memberof GetCharactersCharacterIdMailMailIdOk
   */
  read?: boolean;
  /**
   * Recipients of the mail
   * @type {Set<GetCharactersCharacterIdMailMailIdRecipient>}
   * @memberof GetCharactersCharacterIdMailMailIdOk
   */
  recipients?: Set<GetCharactersCharacterIdMailMailIdRecipient>;
  /**
   * Mail subject
   * @type {string}
   * @memberof GetCharactersCharacterIdMailMailIdOk
   */
  subject?: string;
  /**
   * When the mail was sent
   * @type {string}
   * @memberof GetCharactersCharacterIdMailMailIdOk
   */
  timestamp?: string;
}
/**
 * recipient object
 * @export
 * @interface GetCharactersCharacterIdMailMailIdRecipient
 */
export interface GetCharactersCharacterIdMailMailIdRecipient {
  /**
   * recipient_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMailMailIdRecipient
   */
  recipient_id: number;
  /**
   * recipient_type string
   * @type {string}
   * @memberof GetCharactersCharacterIdMailMailIdRecipient
   */
  recipient_type: GetCharactersCharacterIdMailMailIdRecipientRecipientTypeEnum;
}

export const GetCharactersCharacterIdMailMailIdRecipientRecipientTypeEnum = {
  ALLIANCE: "alliance",
  CHARACTER: "character",
  CORPORATION: "corporation",
  MAILING_LIST: "mailing_list",
} as const;

export type GetCharactersCharacterIdMailMailIdRecipientRecipientTypeEnum =
  typeof GetCharactersCharacterIdMailMailIdRecipientRecipientTypeEnum[keyof typeof GetCharactersCharacterIdMailMailIdRecipientRecipientTypeEnum];

/**
 * recipient object
 * @export
 * @interface GetCharactersCharacterIdMailRecipient
 */
export interface GetCharactersCharacterIdMailRecipient {
  /**
   * recipient_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMailRecipient
   */
  recipient_id: number;
  /**
   * recipient_type string
   * @type {string}
   * @memberof GetCharactersCharacterIdMailRecipient
   */
  recipient_type: GetCharactersCharacterIdMailRecipientRecipientTypeEnum;
}

export const GetCharactersCharacterIdMailRecipientRecipientTypeEnum = {
  ALLIANCE: "alliance",
  CHARACTER: "character",
  CORPORATION: "corporation",
  MAILING_LIST: "mailing_list",
} as const;

export type GetCharactersCharacterIdMailRecipientRecipientTypeEnum =
  typeof GetCharactersCharacterIdMailRecipientRecipientTypeEnum[keyof typeof GetCharactersCharacterIdMailRecipientRecipientTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdMedals200Ok
 */
export interface GetCharactersCharacterIdMedals200Ok {
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMedals200Ok
   */
  corporation_id: number;
  /**
   * date string
   * @type {string}
   * @memberof GetCharactersCharacterIdMedals200Ok
   */
  date: string;
  /**
   * description string
   * @type {string}
   * @memberof GetCharactersCharacterIdMedals200Ok
   */
  description: string;
  /**
   * graphics array
   * @type {Array<GetCharactersCharacterIdMedalsGraphic>}
   * @memberof GetCharactersCharacterIdMedals200Ok
   */
  graphics: Array<GetCharactersCharacterIdMedalsGraphic>;
  /**
   * issuer_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMedals200Ok
   */
  issuer_id: number;
  /**
   * medal_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMedals200Ok
   */
  medal_id: number;
  /**
   * reason string
   * @type {string}
   * @memberof GetCharactersCharacterIdMedals200Ok
   */
  reason: string;
  /**
   * status string
   * @type {string}
   * @memberof GetCharactersCharacterIdMedals200Ok
   */
  status: GetCharactersCharacterIdMedals200OkStatusEnum;
  /**
   * title string
   * @type {string}
   * @memberof GetCharactersCharacterIdMedals200Ok
   */
  title: string;
}

export const GetCharactersCharacterIdMedals200OkStatusEnum = {
  PUBLIC: "public",
  PRIVATE: "private",
} as const;

export type GetCharactersCharacterIdMedals200OkStatusEnum =
  typeof GetCharactersCharacterIdMedals200OkStatusEnum[keyof typeof GetCharactersCharacterIdMedals200OkStatusEnum];

/**
 * graphic object
 * @export
 * @interface GetCharactersCharacterIdMedalsGraphic
 */
export interface GetCharactersCharacterIdMedalsGraphic {
  /**
   * color integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMedalsGraphic
   */
  color?: number;
  /**
   * graphic string
   * @type {string}
   * @memberof GetCharactersCharacterIdMedalsGraphic
   */
  graphic: string;
  /**
   * layer integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMedalsGraphic
   */
  layer: number;
  /**
   * part integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMedalsGraphic
   */
  part: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdMining200Ok
 */
export interface GetCharactersCharacterIdMining200Ok {
  /**
   * date string
   * @type {string}
   * @memberof GetCharactersCharacterIdMining200Ok
   */
  date: string;
  /**
   * quantity integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMining200Ok
   */
  quantity: number;
  /**
   * solar_system_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMining200Ok
   */
  solar_system_id: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdMining200Ok
   */
  type_id: number;
}
/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdNotFound
 */
export interface GetCharactersCharacterIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetCharactersCharacterIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdNotifications200Ok
 */
export interface GetCharactersCharacterIdNotifications200Ok {
  /**
   * is_read boolean
   * @type {boolean}
   * @memberof GetCharactersCharacterIdNotifications200Ok
   */
  is_read?: boolean;
  /**
   * notification_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdNotifications200Ok
   */
  notification_id: number;
  /**
   * sender_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdNotifications200Ok
   */
  sender_id: number;
  /**
   * sender_type string
   * @type {string}
   * @memberof GetCharactersCharacterIdNotifications200Ok
   */
  sender_type: GetCharactersCharacterIdNotifications200OkSenderTypeEnum;
  /**
   * text string
   * @type {string}
   * @memberof GetCharactersCharacterIdNotifications200Ok
   */
  text?: string;
  /**
   * timestamp string
   * @type {string}
   * @memberof GetCharactersCharacterIdNotifications200Ok
   */
  timestamp: string;
  /**
   * type string
   * @type {string}
   * @memberof GetCharactersCharacterIdNotifications200Ok
   */
  type: GetCharactersCharacterIdNotifications200OkTypeEnum;
}

export const GetCharactersCharacterIdNotifications200OkSenderTypeEnum = {
  CHARACTER: "character",
  CORPORATION: "corporation",
  ALLIANCE: "alliance",
  FACTION: "faction",
  OTHER: "other",
} as const;

export type GetCharactersCharacterIdNotifications200OkSenderTypeEnum =
  typeof GetCharactersCharacterIdNotifications200OkSenderTypeEnum[keyof typeof GetCharactersCharacterIdNotifications200OkSenderTypeEnum];
export const GetCharactersCharacterIdNotifications200OkTypeEnum = {
  ACCEPTED_ALLY: "AcceptedAlly",
  ACCEPTED_SURRENDER: "AcceptedSurrender",
  AGENT_RETIRED_TRIGRAVIAN: "AgentRetiredTrigravian",
  ALL_ANCHORING_MSG: "AllAnchoringMsg",
  ALL_MAINTENANCE_BILL_MSG: "AllMaintenanceBillMsg",
  ALL_STRUC_INVULNERABLE_MSG: "AllStrucInvulnerableMsg",
  ALL_STRUCT_VULNERABLE_MSG: "AllStructVulnerableMsg",
  ALL_WAR_CORP_JOINED_ALLIANCE_MSG: "AllWarCorpJoinedAllianceMsg",
  ALL_WAR_DECLARED_MSG: "AllWarDeclaredMsg",
  ALL_WAR_INVALIDATED_MSG: "AllWarInvalidatedMsg",
  ALL_WAR_RETRACTED_MSG: "AllWarRetractedMsg",
  ALL_WAR_SURRENDER_MSG: "AllWarSurrenderMsg",
  ALLIANCE_CAPITAL_CHANGED: "AllianceCapitalChanged",
  ALLIANCE_WAR_DECLARED_V2: "AllianceWarDeclaredV2",
  ALLY_CONTRACT_CANCELLED: "AllyContractCancelled",
  ALLY_JOINED_WAR_AGGRESSOR_MSG: "AllyJoinedWarAggressorMsg",
  ALLY_JOINED_WAR_ALLY_MSG: "AllyJoinedWarAllyMsg",
  ALLY_JOINED_WAR_DEFENDER_MSG: "AllyJoinedWarDefenderMsg",
  BATTLE_PUNISH_FRIENDLY_FIRE: "BattlePunishFriendlyFire",
  BILL_OUT_OF_MONEY_MSG: "BillOutOfMoneyMsg",
  BILL_PAID_CORP_ALL_MSG: "BillPaidCorpAllMsg",
  BOUNTY_CLAIM_MSG: "BountyClaimMsg",
  BOUNTY_ESS_SHARED: "BountyESSShared",
  BOUNTY_ESS_TAKEN: "BountyESSTaken",
  BOUNTY_PLACED_ALLIANCE: "BountyPlacedAlliance",
  BOUNTY_PLACED_CHAR: "BountyPlacedChar",
  BOUNTY_PLACED_CORP: "BountyPlacedCorp",
  BOUNTY_YOUR_BOUNTY_CLAIMED: "BountyYourBountyClaimed",
  BUDDY_CONNECT_CONTACT_ADD: "BuddyConnectContactAdd",
  CHAR_APP_ACCEPT_MSG: "CharAppAcceptMsg",
  CHAR_APP_REJECT_MSG: "CharAppRejectMsg",
  CHAR_APP_WITHDRAW_MSG: "CharAppWithdrawMsg",
  CHAR_LEFT_CORP_MSG: "CharLeftCorpMsg",
  CHAR_MEDAL_MSG: "CharMedalMsg",
  CHAR_TERMINATION_MSG: "CharTerminationMsg",
  CLONE_ACTIVATION_MSG: "CloneActivationMsg",
  CLONE_ACTIVATION_MSG2: "CloneActivationMsg2",
  CLONE_MOVED_MSG: "CloneMovedMsg",
  CLONE_REVOKED_MSG1: "CloneRevokedMsg1",
  CLONE_REVOKED_MSG2: "CloneRevokedMsg2",
  COMBAT_OPERATION_FINISHED: "CombatOperationFinished",
  CONTACT_ADD: "ContactAdd",
  CONTACT_EDIT: "ContactEdit",
  CONTAINER_PASSWORD_MSG: "ContainerPasswordMsg",
  CONTRACT_REGION_CHANGED_TO_POCHVEN: "ContractRegionChangedToPochven",
  CORP_ALL_BILL_MSG: "CorpAllBillMsg",
  CORP_APP_ACCEPT_MSG: "CorpAppAcceptMsg",
  CORP_APP_INVITED_MSG: "CorpAppInvitedMsg",
  CORP_APP_NEW_MSG: "CorpAppNewMsg",
  CORP_APP_REJECT_CUSTOM_MSG: "CorpAppRejectCustomMsg",
  CORP_APP_REJECT_MSG: "CorpAppRejectMsg",
  CORP_BECAME_WAR_ELIGIBLE: "CorpBecameWarEligible",
  CORP_DIVIDEND_MSG: "CorpDividendMsg",
  CORP_FRIENDLY_FIRE_DISABLE_TIMER_COMPLETED:
    "CorpFriendlyFireDisableTimerCompleted",
  CORP_FRIENDLY_FIRE_DISABLE_TIMER_STARTED:
    "CorpFriendlyFireDisableTimerStarted",
  CORP_FRIENDLY_FIRE_ENABLE_TIMER_COMPLETED:
    "CorpFriendlyFireEnableTimerCompleted",
  CORP_FRIENDLY_FIRE_ENABLE_TIMER_STARTED: "CorpFriendlyFireEnableTimerStarted",
  CORP_KICKED: "CorpKicked",
  CORP_LIQUIDATION_MSG: "CorpLiquidationMsg",
  CORP_NEW_CEO_MSG: "CorpNewCEOMsg",
  CORP_NEWS_MSG: "CorpNewsMsg",
  CORP_NO_LONGER_WAR_ELIGIBLE: "CorpNoLongerWarEligible",
  CORP_OFFICE_EXPIRATION_MSG: "CorpOfficeExpirationMsg",
  CORP_STRUCT_LOST_MSG: "CorpStructLostMsg",
  CORP_TAX_CHANGE_MSG: "CorpTaxChangeMsg",
  CORP_VOTE_CEO_REVOKED_MSG: "CorpVoteCEORevokedMsg",
  CORP_VOTE_MSG: "CorpVoteMsg",
  CORP_WAR_DECLARED_MSG: "CorpWarDeclaredMsg",
  CORP_WAR_DECLARED_V2: "CorpWarDeclaredV2",
  CORP_WAR_FIGHTING_LEGAL_MSG: "CorpWarFightingLegalMsg",
  CORP_WAR_INVALIDATED_MSG: "CorpWarInvalidatedMsg",
  CORP_WAR_RETRACTED_MSG: "CorpWarRetractedMsg",
  CORP_WAR_SURRENDER_MSG: "CorpWarSurrenderMsg",
  CUSTOMS_MSG: "CustomsMsg",
  DECLARE_WAR: "DeclareWar",
  DISTRICT_ATTACKED: "DistrictAttacked",
  DUST_APP_ACCEPTED_MSG: "DustAppAcceptedMsg",
  ESS_MAIN_BANK_LINK: "ESSMainBankLink",
  ENTOSIS_CAPTURE_STARTED: "EntosisCaptureStarted",
  EXPERT_SYSTEM_EXPIRED: "ExpertSystemExpired",
  EXPERT_SYSTEM_EXPIRY_IMMINENT: "ExpertSystemExpiryImminent",
  FW_ALLIANCE_KICK_MSG: "FWAllianceKickMsg",
  FW_ALLIANCE_WARNING_MSG: "FWAllianceWarningMsg",
  FW_CHAR_KICK_MSG: "FWCharKickMsg",
  FW_CHAR_RANK_GAIN_MSG: "FWCharRankGainMsg",
  FW_CHAR_RANK_LOSS_MSG: "FWCharRankLossMsg",
  FW_CHAR_WARNING_MSG: "FWCharWarningMsg",
  FW_CORP_JOIN_MSG: "FWCorpJoinMsg",
  FW_CORP_KICK_MSG: "FWCorpKickMsg",
  FW_CORP_LEAVE_MSG: "FWCorpLeaveMsg",
  FW_CORP_WARNING_MSG: "FWCorpWarningMsg",
  FAC_WAR_CORP_JOIN_REQUEST_MSG: "FacWarCorpJoinRequestMsg",
  FAC_WAR_CORP_JOIN_WITHDRAW_MSG: "FacWarCorpJoinWithdrawMsg",
  FAC_WAR_CORP_LEAVE_REQUEST_MSG: "FacWarCorpLeaveRequestMsg",
  FAC_WAR_CORP_LEAVE_WITHDRAW_MSG: "FacWarCorpLeaveWithdrawMsg",
  FAC_WAR_LP_DISQUALIFIED_EVENT: "FacWarLPDisqualifiedEvent",
  FAC_WAR_LP_DISQUALIFIED_KILL: "FacWarLPDisqualifiedKill",
  FAC_WAR_LP_PAYOUT_EVENT: "FacWarLPPayoutEvent",
  FAC_WAR_LP_PAYOUT_KILL: "FacWarLPPayoutKill",
  GAME_TIME_ADDED: "GameTimeAdded",
  GAME_TIME_RECEIVED: "GameTimeReceived",
  GAME_TIME_SENT: "GameTimeSent",
  GIFT_RECEIVED: "GiftReceived",
  I_HUB_DESTROYED_BY_BILL_FAILURE: "IHubDestroyedByBillFailure",
  INCURSION_COMPLETED_MSG: "IncursionCompletedMsg",
  INDUSTRY_OPERATION_FINISHED: "IndustryOperationFinished",
  INDUSTRY_TEAM_AUCTION_LOST: "IndustryTeamAuctionLost",
  INDUSTRY_TEAM_AUCTION_WON: "IndustryTeamAuctionWon",
  INFRASTRUCTURE_HUB_BILL_ABOUT_TO_EXPIRE: "InfrastructureHubBillAboutToExpire",
  INSURANCE_EXPIRATION_MSG: "InsuranceExpirationMsg",
  INSURANCE_FIRST_SHIP_MSG: "InsuranceFirstShipMsg",
  INSURANCE_INVALIDATED_MSG: "InsuranceInvalidatedMsg",
  INSURANCE_ISSUED_MSG: "InsuranceIssuedMsg",
  INSURANCE_PAYOUT_MSG: "InsurancePayoutMsg",
  INVASION_COMPLETED_MSG: "InvasionCompletedMsg",
  INVASION_SYSTEM_LOGIN: "InvasionSystemLogin",
  INVASION_SYSTEM_START: "InvasionSystemStart",
  JUMP_CLONE_DELETED_MSG1: "JumpCloneDeletedMsg1",
  JUMP_CLONE_DELETED_MSG2: "JumpCloneDeletedMsg2",
  KILL_REPORT_FINAL_BLOW: "KillReportFinalBlow",
  KILL_REPORT_VICTIM: "KillReportVictim",
  KILL_RIGHT_AVAILABLE: "KillRightAvailable",
  KILL_RIGHT_AVAILABLE_OPEN: "KillRightAvailableOpen",
  KILL_RIGHT_EARNED: "KillRightEarned",
  KILL_RIGHT_UNAVAILABLE: "KillRightUnavailable",
  KILL_RIGHT_UNAVAILABLE_OPEN: "KillRightUnavailableOpen",
  KILL_RIGHT_USED: "KillRightUsed",
  LOCATE_CHAR_MSG: "LocateCharMsg",
  MADE_WAR_MUTUAL: "MadeWarMutual",
  MERC_OFFER_RETRACTED_MSG: "MercOfferRetractedMsg",
  MERC_OFFERED_NEGOTIATION_MSG: "MercOfferedNegotiationMsg",
  MISSION_CANCELED_TRIGLAVIAN: "MissionCanceledTriglavian",
  MISSION_OFFER_EXPIRATION_MSG: "MissionOfferExpirationMsg",
  MISSION_TIMEOUT_MSG: "MissionTimeoutMsg",
  MOONMINING_AUTOMATIC_FRACTURE: "MoonminingAutomaticFracture",
  MOONMINING_EXTRACTION_CANCELLED: "MoonminingExtractionCancelled",
  MOONMINING_EXTRACTION_FINISHED: "MoonminingExtractionFinished",
  MOONMINING_EXTRACTION_STARTED: "MoonminingExtractionStarted",
  MOONMINING_LASER_FIRED: "MoonminingLaserFired",
  MUTUAL_WAR_EXPIRED: "MutualWarExpired",
  MUTUAL_WAR_INVITE_ACCEPTED: "MutualWarInviteAccepted",
  MUTUAL_WAR_INVITE_REJECTED: "MutualWarInviteRejected",
  MUTUAL_WAR_INVITE_SENT: "MutualWarInviteSent",
  NPC_STANDINGS_GAINED: "NPCStandingsGained",
  NPC_STANDINGS_LOST: "NPCStandingsLost",
  OFFER_TO_ALLY_RETRACTED: "OfferToAllyRetracted",
  OFFERED_SURRENDER: "OfferedSurrender",
  OFFERED_TO_ALLY: "OfferedToAlly",
  OFFICE_LEASE_CANCELED_INSUFFICIENT_STANDINGS:
    "OfficeLeaseCanceledInsufficientStandings",
  OLD_LSC_MESSAGES: "OldLscMessages",
  OPERATION_FINISHED: "OperationFinished",
  ORBITAL_ATTACKED: "OrbitalAttacked",
  ORBITAL_REINFORCED: "OrbitalReinforced",
  OWNERSHIP_TRANSFERRED: "OwnershipTransferred",
  RAFFLE_CREATED: "RaffleCreated",
  RAFFLE_EXPIRED: "RaffleExpired",
  RAFFLE_FINISHED: "RaffleFinished",
  REIMBURSEMENT_MSG: "ReimbursementMsg",
  RESEARCH_MISSION_AVAILABLE_MSG: "ResearchMissionAvailableMsg",
  RETRACTS_WAR: "RetractsWar",
  SEASONAL_CHALLENGE_COMPLETED: "SeasonalChallengeCompleted",
  SOV_ALL_CLAIM_AQUIRED_MSG: "SovAllClaimAquiredMsg",
  SOV_ALL_CLAIM_LOST_MSG: "SovAllClaimLostMsg",
  SOV_COMMAND_NODE_EVENT_STARTED: "SovCommandNodeEventStarted",
  SOV_CORP_BILL_LATE_MSG: "SovCorpBillLateMsg",
  SOV_CORP_CLAIM_FAIL_MSG: "SovCorpClaimFailMsg",
  SOV_DISRUPTOR_MSG: "SovDisruptorMsg",
  SOV_STATION_ENTERED_FREEPORT: "SovStationEnteredFreeport",
  SOV_STRUCTURE_DESTROYED: "SovStructureDestroyed",
  SOV_STRUCTURE_REINFORCED: "SovStructureReinforced",
  SOV_STRUCTURE_SELF_DESTRUCT_CANCEL: "SovStructureSelfDestructCancel",
  SOV_STRUCTURE_SELF_DESTRUCT_FINISHED: "SovStructureSelfDestructFinished",
  SOV_STRUCTURE_SELF_DESTRUCT_REQUESTED: "SovStructureSelfDestructRequested",
  SOVEREIGNTY_IH_DAMAGE_MSG: "SovereigntyIHDamageMsg",
  SOVEREIGNTY_SBU_DAMAGE_MSG: "SovereigntySBUDamageMsg",
  SOVEREIGNTY_TCU_DAMAGE_MSG: "SovereigntyTCUDamageMsg",
  STATION_AGGRESSION_MSG1: "StationAggressionMsg1",
  STATION_AGGRESSION_MSG2: "StationAggressionMsg2",
  STATION_CONQUER_MSG: "StationConquerMsg",
  STATION_SERVICE_DISABLED: "StationServiceDisabled",
  STATION_SERVICE_ENABLED: "StationServiceEnabled",
  STATION_STATE_CHANGE_MSG: "StationStateChangeMsg",
  STORY_LINE_MISSION_AVAILABLE_MSG: "StoryLineMissionAvailableMsg",
  STRUCTURE_ANCHORING: "StructureAnchoring",
  STRUCTURE_COURIER_CONTRACT_CHANGED: "StructureCourierContractChanged",
  STRUCTURE_DESTROYED: "StructureDestroyed",
  STRUCTURE_FUEL_ALERT: "StructureFuelAlert",
  STRUCTURE_IMPENDING_ABANDONMENT_ASSETS_AT_RISK:
    "StructureImpendingAbandonmentAssetsAtRisk",
  STRUCTURE_ITEMS_DELIVERED: "StructureItemsDelivered",
  STRUCTURE_ITEMS_MOVED_TO_SAFETY: "StructureItemsMovedToSafety",
  STRUCTURE_LOST_ARMOR: "StructureLostArmor",
  STRUCTURE_LOST_SHIELDS: "StructureLostShields",
  STRUCTURE_ONLINE: "StructureOnline",
  STRUCTURE_SERVICES_OFFLINE: "StructureServicesOffline",
  STRUCTURE_UNANCHORING: "StructureUnanchoring",
  STRUCTURE_UNDER_ATTACK: "StructureUnderAttack",
  STRUCTURE_WENT_HIGH_POWER: "StructureWentHighPower",
  STRUCTURE_WENT_LOW_POWER: "StructureWentLowPower",
  STRUCTURES_JOBS_CANCELLED: "StructuresJobsCancelled",
  STRUCTURES_JOBS_PAUSED: "StructuresJobsPaused",
  STRUCTURES_REINFORCEMENT_CHANGED: "StructuresReinforcementChanged",
  TOWER_ALERT_MSG: "TowerAlertMsg",
  TOWER_RESOURCE_ALERT_MSG: "TowerResourceAlertMsg",
  TRANSACTION_REVERSAL_MSG: "TransactionReversalMsg",
  TUTORIAL_MSG: "TutorialMsg",
  WAR_ADOPTED: "WarAdopted ",
  WAR_ALLY_INHERITED: "WarAllyInherited",
  WAR_ALLY_OFFER_DECLINED_MSG: "WarAllyOfferDeclinedMsg",
  WAR_CONCORD_INVALIDATES: "WarConcordInvalidates",
  WAR_DECLARED: "WarDeclared",
  WAR_ENDED_HQ_SECURITY_DROP: "WarEndedHqSecurityDrop",
  WAR_HQ_REMOVED_FROM_SPACE: "WarHQRemovedFromSpace",
  WAR_INHERITED: "WarInherited",
  WAR_INVALID: "WarInvalid",
  WAR_RETRACTED: "WarRetracted",
  WAR_RETRACTED_BY_CONCORD: "WarRetractedByConcord",
  WAR_SURRENDER_DECLINED_MSG: "WarSurrenderDeclinedMsg",
  WAR_SURRENDER_OFFER_MSG: "WarSurrenderOfferMsg",
} as const;

export type GetCharactersCharacterIdNotifications200OkTypeEnum =
  typeof GetCharactersCharacterIdNotifications200OkTypeEnum[keyof typeof GetCharactersCharacterIdNotifications200OkTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdNotificationsContacts200Ok
 */
export interface GetCharactersCharacterIdNotificationsContacts200Ok {
  /**
   * message string
   * @type {string}
   * @memberof GetCharactersCharacterIdNotificationsContacts200Ok
   */
  message: string;
  /**
   * notification_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdNotificationsContacts200Ok
   */
  notification_id: number;
  /**
   * send_date string
   * @type {string}
   * @memberof GetCharactersCharacterIdNotificationsContacts200Ok
   */
  send_date: string;
  /**
   * sender_character_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdNotificationsContacts200Ok
   */
  sender_character_id: number;
  /**
   * A number representing the standing level the receiver has been added at by the sender. The standing levels are as follows: -10 -> Terrible | -5 -> Bad |  0 -> Neutral |  5 -> Good |  10 -> Excellent
   * @type {number}
   * @memberof GetCharactersCharacterIdNotificationsContacts200Ok
   */
  standing_level: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdOk
 */
export interface GetCharactersCharacterIdOk {
  /**
   * The character\'s alliance ID
   * @type {number}
   * @memberof GetCharactersCharacterIdOk
   */
  alliance_id?: number;
  /**
   * Creation date of the character
   * @type {string}
   * @memberof GetCharactersCharacterIdOk
   */
  birthday: string;
  /**
   * bloodline_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdOk
   */
  bloodline_id: number;
  /**
   * The character\'s corporation ID
   * @type {number}
   * @memberof GetCharactersCharacterIdOk
   */
  corporation_id: number;
  /**
   * description string
   * @type {string}
   * @memberof GetCharactersCharacterIdOk
   */
  description?: string;
  /**
   * ID of the faction the character is fighting for, if the character is enlisted in Factional Warfare
   * @type {number}
   * @memberof GetCharactersCharacterIdOk
   */
  faction_id?: number;
  /**
   * gender string
   * @type {string}
   * @memberof GetCharactersCharacterIdOk
   */
  gender: GetCharactersCharacterIdOkGenderEnum;
  /**
   * name string
   * @type {string}
   * @memberof GetCharactersCharacterIdOk
   */
  name: string;
  /**
   * race_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdOk
   */
  race_id: number;
  /**
   * security_status number
   * @type {number}
   * @memberof GetCharactersCharacterIdOk
   */
  security_status?: number;
  /**
   * The individual title of the character
   * @type {string}
   * @memberof GetCharactersCharacterIdOk
   */
  title?: string;
}

export const GetCharactersCharacterIdOkGenderEnum = {
  FEMALE: "female",
  MALE: "male",
} as const;

export type GetCharactersCharacterIdOkGenderEnum =
  typeof GetCharactersCharacterIdOkGenderEnum[keyof typeof GetCharactersCharacterIdOkGenderEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdOnlineOk
 */
export interface GetCharactersCharacterIdOnlineOk {
  /**
   * Timestamp of the last login
   * @type {string}
   * @memberof GetCharactersCharacterIdOnlineOk
   */
  last_login?: string;
  /**
   * Timestamp of the last logout
   * @type {string}
   * @memberof GetCharactersCharacterIdOnlineOk
   */
  last_logout?: string;
  /**
   * Total number of times the character has logged in
   * @type {number}
   * @memberof GetCharactersCharacterIdOnlineOk
   */
  logins?: number;
  /**
   * If the character is online
   * @type {boolean}
   * @memberof GetCharactersCharacterIdOnlineOk
   */
  online: boolean;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdOpportunities200Ok
 */
export interface GetCharactersCharacterIdOpportunities200Ok {
  /**
   * completed_at string
   * @type {string}
   * @memberof GetCharactersCharacterIdOpportunities200Ok
   */
  completed_at: string;
  /**
   * task_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdOpportunities200Ok
   */
  task_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdOrders200Ok
 */
export interface GetCharactersCharacterIdOrders200Ok {
  /**
   * Number of days for which order is valid (starting from the issued date). An order expires at time issued + duration
   * @type {number}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  duration: number;
  /**
   * For buy orders, the amount of ISK in escrow
   * @type {number}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  escrow?: number;
  /**
   * True if the order is a bid (buy) order
   * @type {boolean}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  is_buy_order?: boolean;
  /**
   * Signifies whether the buy/sell order was placed on behalf of a corporation.
   * @type {boolean}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  is_corporation: boolean;
  /**
   * Date and time when this order was issued
   * @type {string}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  issued: string;
  /**
   * ID of the location where order was placed
   * @type {number}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  location_id: number;
  /**
   * For buy orders, the minimum quantity that will be accepted in a matching sell order
   * @type {number}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  min_volume?: number;
  /**
   * Unique order ID
   * @type {number}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  order_id: number;
  /**
   * Cost per unit for this order
   * @type {number}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  price: number;
  /**
   * Valid order range, numbers are ranges in jumps
   * @type {string}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  range: GetCharactersCharacterIdOrders200OkRangeEnum;
  /**
   * ID of the region where order was placed
   * @type {number}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  region_id: number;
  /**
   * The type ID of the item transacted in this order
   * @type {number}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  type_id: number;
  /**
   * Quantity of items still required or offered
   * @type {number}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  volume_remain: number;
  /**
   * Quantity of items required or offered at time order was placed
   * @type {number}
   * @memberof GetCharactersCharacterIdOrders200Ok
   */
  volume_total: number;
}

export const GetCharactersCharacterIdOrders200OkRangeEnum = {
  _1: "1",
  _10: "10",
  _2: "2",
  _20: "20",
  _3: "3",
  _30: "30",
  _4: "4",
  _40: "40",
  _5: "5",
  REGION: "region",
  SOLARSYSTEM: "solarsystem",
  STATION: "station",
} as const;

export type GetCharactersCharacterIdOrders200OkRangeEnum =
  typeof GetCharactersCharacterIdOrders200OkRangeEnum[keyof typeof GetCharactersCharacterIdOrders200OkRangeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdOrdersHistory200Ok
 */
export interface GetCharactersCharacterIdOrdersHistory200Ok {
  /**
   * Number of days the order was valid for (starting from the issued date). An order expires at time issued + duration
   * @type {number}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  duration: number;
  /**
   * For buy orders, the amount of ISK in escrow
   * @type {number}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  escrow?: number;
  /**
   * True if the order is a bid (buy) order
   * @type {boolean}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  is_buy_order?: boolean;
  /**
   * Signifies whether the buy/sell order was placed on behalf of a corporation.
   * @type {boolean}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  is_corporation: boolean;
  /**
   * Date and time when this order was issued
   * @type {string}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  issued: string;
  /**
   * ID of the location where order was placed
   * @type {number}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  location_id: number;
  /**
   * For buy orders, the minimum quantity that will be accepted in a matching sell order
   * @type {number}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  min_volume?: number;
  /**
   * Unique order ID
   * @type {number}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  order_id: number;
  /**
   * Cost per unit for this order
   * @type {number}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  price: number;
  /**
   * Valid order range, numbers are ranges in jumps
   * @type {string}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  range: GetCharactersCharacterIdOrdersHistory200OkRangeEnum;
  /**
   * ID of the region where order was placed
   * @type {number}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  region_id: number;
  /**
   * Current order state
   * @type {string}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  state: GetCharactersCharacterIdOrdersHistory200OkStateEnum;
  /**
   * The type ID of the item transacted in this order
   * @type {number}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  type_id: number;
  /**
   * Quantity of items still required or offered
   * @type {number}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  volume_remain: number;
  /**
   * Quantity of items required or offered at time order was placed
   * @type {number}
   * @memberof GetCharactersCharacterIdOrdersHistory200Ok
   */
  volume_total: number;
}

export const GetCharactersCharacterIdOrdersHistory200OkRangeEnum = {
  _1: "1",
  _10: "10",
  _2: "2",
  _20: "20",
  _3: "3",
  _30: "30",
  _4: "4",
  _40: "40",
  _5: "5",
  REGION: "region",
  SOLARSYSTEM: "solarsystem",
  STATION: "station",
} as const;

export type GetCharactersCharacterIdOrdersHistory200OkRangeEnum =
  typeof GetCharactersCharacterIdOrdersHistory200OkRangeEnum[keyof typeof GetCharactersCharacterIdOrdersHistory200OkRangeEnum];
export const GetCharactersCharacterIdOrdersHistory200OkStateEnum = {
  CANCELLED: "cancelled",
  EXPIRED: "expired",
} as const;

export type GetCharactersCharacterIdOrdersHistory200OkStateEnum =
  typeof GetCharactersCharacterIdOrdersHistory200OkStateEnum[keyof typeof GetCharactersCharacterIdOrdersHistory200OkStateEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdPlanets200Ok
 */
export interface GetCharactersCharacterIdPlanets200Ok {
  /**
   * last_update string
   * @type {string}
   * @memberof GetCharactersCharacterIdPlanets200Ok
   */
  last_update: string;
  /**
   * num_pins integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanets200Ok
   */
  num_pins: number;
  /**
   * owner_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanets200Ok
   */
  owner_id: number;
  /**
   * planet_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanets200Ok
   */
  planet_id: number;
  /**
   * planet_type string
   * @type {string}
   * @memberof GetCharactersCharacterIdPlanets200Ok
   */
  planet_type: GetCharactersCharacterIdPlanets200OkPlanetTypeEnum;
  /**
   * solar_system_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanets200Ok
   */
  solar_system_id: number;
  /**
   * upgrade_level integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanets200Ok
   */
  upgrade_level: number;
}

export const GetCharactersCharacterIdPlanets200OkPlanetTypeEnum = {
  TEMPERATE: "temperate",
  BARREN: "barren",
  OCEANIC: "oceanic",
  ICE: "ice",
  GAS: "gas",
  LAVA: "lava",
  STORM: "storm",
  PLASMA: "plasma",
} as const;

export type GetCharactersCharacterIdPlanets200OkPlanetTypeEnum =
  typeof GetCharactersCharacterIdPlanets200OkPlanetTypeEnum[keyof typeof GetCharactersCharacterIdPlanets200OkPlanetTypeEnum];

/**
 * content object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdContent
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdContent {
  /**
   * amount integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdContent
   */
  amount: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdContent
   */
  type_id: number;
}
/**
 * extractor_details object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails {
  /**
   * in seconds
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails
   */
  cycle_time?: number;
  /**
   * head_radius number
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails
   */
  head_radius?: number;
  /**
   * heads array
   * @type {Array<GetCharactersCharacterIdPlanetsPlanetIdHead>}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails
   */
  heads: Array<GetCharactersCharacterIdPlanetsPlanetIdHead>;
  /**
   * product_type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails
   */
  product_type_id?: number;
  /**
   * qty_per_cycle integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails
   */
  qty_per_cycle?: number;
}
/**
 * factory_details object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails {
  /**
   * schematic_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails
   */
  schematic_id: number;
}
/**
 * head object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdHead
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdHead {
  /**
   * head_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdHead
   */
  head_id: number;
  /**
   * latitude number
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdHead
   */
  latitude: number;
  /**
   * longitude number
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdHead
   */
  longitude: number;
}
/**
 * link object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdLink
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdLink {
  /**
   * destination_pin_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdLink
   */
  destination_pin_id: number;
  /**
   * link_level integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdLink
   */
  link_level: number;
  /**
   * source_pin_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdLink
   */
  source_pin_id: number;
}
/**
 * Colony not found
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdNotFound
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdNotFound {
  /**
   * error message
   * @type {string}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdOk
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdOk {
  /**
   * links array
   * @type {Array<GetCharactersCharacterIdPlanetsPlanetIdLink>}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdOk
   */
  links: Array<GetCharactersCharacterIdPlanetsPlanetIdLink>;
  /**
   * pins array
   * @type {Array<GetCharactersCharacterIdPlanetsPlanetIdPin>}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdOk
   */
  pins: Array<GetCharactersCharacterIdPlanetsPlanetIdPin>;
  /**
   * routes array
   * @type {Array<GetCharactersCharacterIdPlanetsPlanetIdRoute>}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdOk
   */
  routes: Array<GetCharactersCharacterIdPlanetsPlanetIdRoute>;
}
/**
 * pin object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdPin
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdPin {
  /**
   * contents array
   * @type {Array<GetCharactersCharacterIdPlanetsPlanetIdContent>}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
   */
  contents?: Array<GetCharactersCharacterIdPlanetsPlanetIdContent>;
  /**
   * expiry_time string
   * @type {string}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
   */
  expiry_time?: string;
  /**
   *
   * @type {GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
   */
  extractor_details?: GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails;
  /**
   *
   * @type {GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
   */
  factory_details?: GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails;
  /**
   * install_time string
   * @type {string}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
   */
  install_time?: string;
  /**
   * last_cycle_start string
   * @type {string}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
   */
  last_cycle_start?: string;
  /**
   * latitude number
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
   */
  latitude: number;
  /**
   * longitude number
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
   */
  longitude: number;
  /**
   * pin_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
   */
  pin_id: number;
  /**
   * schematic_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
   */
  schematic_id?: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
   */
  type_id: number;
}
/**
 * route object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdRoute
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdRoute {
  /**
   * content_type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdRoute
   */
  content_type_id: number;
  /**
   * destination_pin_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdRoute
   */
  destination_pin_id: number;
  /**
   * quantity number
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdRoute
   */
  quantity: number;
  /**
   * route_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdRoute
   */
  route_id: number;
  /**
   * source_pin_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdRoute
   */
  source_pin_id: number;
  /**
   * list of pin ID waypoints
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdPlanetsPlanetIdRoute
   */
  waypoints?: Array<number>;
}
/**
 * No image server for this datasource
 * @export
 * @interface GetCharactersCharacterIdPortraitNotFound
 */
export interface GetCharactersCharacterIdPortraitNotFound {
  /**
   * error message
   * @type {string}
   * @memberof GetCharactersCharacterIdPortraitNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdPortraitOk
 */
export interface GetCharactersCharacterIdPortraitOk {
  /**
   * px128x128 string
   * @type {string}
   * @memberof GetCharactersCharacterIdPortraitOk
   */
  px128x128?: string;
  /**
   * px256x256 string
   * @type {string}
   * @memberof GetCharactersCharacterIdPortraitOk
   */
  px256x256?: string;
  /**
   * px512x512 string
   * @type {string}
   * @memberof GetCharactersCharacterIdPortraitOk
   */
  px512x512?: string;
  /**
   * px64x64 string
   * @type {string}
   * @memberof GetCharactersCharacterIdPortraitOk
   */
  px64x64?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdRolesOk
 */
export interface GetCharactersCharacterIdRolesOk {
  /**
   * roles array
   * @type {Array<string>}
   * @memberof GetCharactersCharacterIdRolesOk
   */
  roles?: Array<GetCharactersCharacterIdRolesOkRolesEnum>;
  /**
   * roles_at_base array
   * @type {Array<string>}
   * @memberof GetCharactersCharacterIdRolesOk
   */
  roles_at_base?: Array<GetCharactersCharacterIdRolesOkRolesAtBaseEnum>;
  /**
   * roles_at_hq array
   * @type {Array<string>}
   * @memberof GetCharactersCharacterIdRolesOk
   */
  roles_at_hq?: Array<GetCharactersCharacterIdRolesOkRolesAtHqEnum>;
  /**
   * roles_at_other array
   * @type {Array<string>}
   * @memberof GetCharactersCharacterIdRolesOk
   */
  roles_at_other?: Array<GetCharactersCharacterIdRolesOkRolesAtOtherEnum>;
}

export const GetCharactersCharacterIdRolesOkRolesEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCharactersCharacterIdRolesOkRolesEnum =
  typeof GetCharactersCharacterIdRolesOkRolesEnum[keyof typeof GetCharactersCharacterIdRolesOkRolesEnum];
export const GetCharactersCharacterIdRolesOkRolesAtBaseEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCharactersCharacterIdRolesOkRolesAtBaseEnum =
  typeof GetCharactersCharacterIdRolesOkRolesAtBaseEnum[keyof typeof GetCharactersCharacterIdRolesOkRolesAtBaseEnum];
export const GetCharactersCharacterIdRolesOkRolesAtHqEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCharactersCharacterIdRolesOkRolesAtHqEnum =
  typeof GetCharactersCharacterIdRolesOkRolesAtHqEnum[keyof typeof GetCharactersCharacterIdRolesOkRolesAtHqEnum];
export const GetCharactersCharacterIdRolesOkRolesAtOtherEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCharactersCharacterIdRolesOkRolesAtOtherEnum =
  typeof GetCharactersCharacterIdRolesOkRolesAtOtherEnum[keyof typeof GetCharactersCharacterIdRolesOkRolesAtOtherEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdSearchOk
 */
export interface GetCharactersCharacterIdSearchOk {
  /**
   * agent array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdSearchOk
   */
  agent?: Array<number>;
  /**
   * alliance array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdSearchOk
   */
  alliance?: Array<number>;
  /**
   * character array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdSearchOk
   */
  character?: Array<number>;
  /**
   * constellation array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdSearchOk
   */
  constellation?: Array<number>;
  /**
   * corporation array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdSearchOk
   */
  corporation?: Array<number>;
  /**
   * faction array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdSearchOk
   */
  faction?: Array<number>;
  /**
   * inventory_type array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdSearchOk
   */
  inventory_type?: Array<number>;
  /**
   * region array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdSearchOk
   */
  region?: Array<number>;
  /**
   * solar_system array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdSearchOk
   */
  solar_system?: Array<number>;
  /**
   * station array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdSearchOk
   */
  station?: Array<number>;
  /**
   * structure array
   * @type {Array<number>}
   * @memberof GetCharactersCharacterIdSearchOk
   */
  structure?: Array<number>;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdShipOk
 */
export interface GetCharactersCharacterIdShipOk {
  /**
   * Item id\'s are unique to a ship and persist until it is repackaged. This value can be used to track repeated uses of a ship, or detect when a pilot changes into a different instance of the same ship type.
   * @type {number}
   * @memberof GetCharactersCharacterIdShipOk
   */
  ship_item_id: number;
  /**
   * ship_name string
   * @type {string}
   * @memberof GetCharactersCharacterIdShipOk
   */
  ship_name: string;
  /**
   * ship_type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdShipOk
   */
  ship_type_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdSkillqueue200Ok
 */
export interface GetCharactersCharacterIdSkillqueue200Ok {
  /**
   * Date on which training of the skill will complete. Omitted if the skill queue is paused.
   * @type {string}
   * @memberof GetCharactersCharacterIdSkillqueue200Ok
   */
  finish_date?: string;
  /**
   * finished_level integer
   * @type {number}
   * @memberof GetCharactersCharacterIdSkillqueue200Ok
   */
  finished_level: number;
  /**
   * level_end_sp integer
   * @type {number}
   * @memberof GetCharactersCharacterIdSkillqueue200Ok
   */
  level_end_sp?: number;
  /**
   * Amount of SP that was in the skill when it started training it\'s current level. Used to calculate % of current level complete.
   * @type {number}
   * @memberof GetCharactersCharacterIdSkillqueue200Ok
   */
  level_start_sp?: number;
  /**
   * queue_position integer
   * @type {number}
   * @memberof GetCharactersCharacterIdSkillqueue200Ok
   */
  queue_position: number;
  /**
   * skill_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdSkillqueue200Ok
   */
  skill_id: number;
  /**
   * start_date string
   * @type {string}
   * @memberof GetCharactersCharacterIdSkillqueue200Ok
   */
  start_date?: string;
  /**
   * training_start_sp integer
   * @type {number}
   * @memberof GetCharactersCharacterIdSkillqueue200Ok
   */
  training_start_sp?: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdSkillsOk
 */
export interface GetCharactersCharacterIdSkillsOk {
  /**
   * skills array
   * @type {Array<GetCharactersCharacterIdSkillsSkill>}
   * @memberof GetCharactersCharacterIdSkillsOk
   */
  skills: Array<GetCharactersCharacterIdSkillsSkill>;
  /**
   * total_sp integer
   * @type {number}
   * @memberof GetCharactersCharacterIdSkillsOk
   */
  total_sp: number;
  /**
   * Skill points available to be assigned
   * @type {number}
   * @memberof GetCharactersCharacterIdSkillsOk
   */
  unallocated_sp?: number;
}
/**
 * skill object
 * @export
 * @interface GetCharactersCharacterIdSkillsSkill
 */
export interface GetCharactersCharacterIdSkillsSkill {
  /**
   * active_skill_level integer
   * @type {number}
   * @memberof GetCharactersCharacterIdSkillsSkill
   */
  active_skill_level: number;
  /**
   * skill_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdSkillsSkill
   */
  skill_id: number;
  /**
   * skillpoints_in_skill integer
   * @type {number}
   * @memberof GetCharactersCharacterIdSkillsSkill
   */
  skillpoints_in_skill: number;
  /**
   * trained_skill_level integer
   * @type {number}
   * @memberof GetCharactersCharacterIdSkillsSkill
   */
  trained_skill_level: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdStandings200Ok
 */
export interface GetCharactersCharacterIdStandings200Ok {
  /**
   * from_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdStandings200Ok
   */
  from_id: number;
  /**
   * from_type string
   * @type {string}
   * @memberof GetCharactersCharacterIdStandings200Ok
   */
  from_type: GetCharactersCharacterIdStandings200OkFromTypeEnum;
  /**
   * standing number
   * @type {number}
   * @memberof GetCharactersCharacterIdStandings200Ok
   */
  standing: number;
}

export const GetCharactersCharacterIdStandings200OkFromTypeEnum = {
  AGENT: "agent",
  NPC_CORP: "npc_corp",
  FACTION: "faction",
} as const;

export type GetCharactersCharacterIdStandings200OkFromTypeEnum =
  typeof GetCharactersCharacterIdStandings200OkFromTypeEnum[keyof typeof GetCharactersCharacterIdStandings200OkFromTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdTitles200Ok
 */
export interface GetCharactersCharacterIdTitles200Ok {
  /**
   * name string
   * @type {string}
   * @memberof GetCharactersCharacterIdTitles200Ok
   */
  name?: string;
  /**
   * title_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdTitles200Ok
   */
  title_id?: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdWalletJournal200Ok
 */
export interface GetCharactersCharacterIdWalletJournal200Ok {
  /**
   * The amount of ISK given or taken from the wallet as a result of the given transaction. Positive when ISK is deposited into the wallet and negative when ISK is withdrawn
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  amount?: number;
  /**
   * Wallet balance after transaction occurred
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  balance?: number;
  /**
   * An ID that gives extra context to the particular transaction. Because of legacy reasons the context is completely different per ref_type and means different things. It is also possible to not have a context_id
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  context_id?: number;
  /**
   * The type of the given context_id if present
   * @type {string}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  context_id_type?: GetCharactersCharacterIdWalletJournal200OkContextIdTypeEnum;
  /**
   * Date and time of transaction
   * @type {string}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  date: string;
  /**
   * The reason for the transaction, mirrors what is seen in the client
   * @type {string}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  description: string;
  /**
   * The id of the first party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  first_party_id?: number;
  /**
   * Unique journal reference ID
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  id: number;
  /**
   * The user stated reason for the transaction. Only applies to some ref_types
   * @type {string}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  reason?: string;
  /**
   * \"The transaction type for the given. transaction. Different transaction types will populate different attributes.\"
   * @type {string}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  ref_type: GetCharactersCharacterIdWalletJournal200OkRefTypeEnum;
  /**
   * The id of the second party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  second_party_id?: number;
  /**
   * Tax amount received. Only applies to tax related transactions
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  tax?: number;
  /**
   * The corporation ID receiving any tax paid. Only applies to tax related transactions
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletJournal200Ok
   */
  tax_receiver_id?: number;
}

export const GetCharactersCharacterIdWalletJournal200OkContextIdTypeEnum = {
  STRUCTURE_ID: "structure_id",
  STATION_ID: "station_id",
  MARKET_TRANSACTION_ID: "market_transaction_id",
  CHARACTER_ID: "character_id",
  CORPORATION_ID: "corporation_id",
  ALLIANCE_ID: "alliance_id",
  EVE_SYSTEM: "eve_system",
  INDUSTRY_JOB_ID: "industry_job_id",
  CONTRACT_ID: "contract_id",
  PLANET_ID: "planet_id",
  SYSTEM_ID: "system_id",
  TYPE_ID: "type_id",
} as const;

export type GetCharactersCharacterIdWalletJournal200OkContextIdTypeEnum =
  typeof GetCharactersCharacterIdWalletJournal200OkContextIdTypeEnum[keyof typeof GetCharactersCharacterIdWalletJournal200OkContextIdTypeEnum];
export const GetCharactersCharacterIdWalletJournal200OkRefTypeEnum = {
  ACCELERATION_GATE_FEE: "acceleration_gate_fee",
  ADVERTISEMENT_LISTING_FEE: "advertisement_listing_fee",
  AGENT_DONATION: "agent_donation",
  AGENT_LOCATION_SERVICES: "agent_location_services",
  AGENT_MISCELLANEOUS: "agent_miscellaneous",
  AGENT_MISSION_COLLATERAL_PAID: "agent_mission_collateral_paid",
  AGENT_MISSION_COLLATERAL_REFUNDED: "agent_mission_collateral_refunded",
  AGENT_MISSION_REWARD: "agent_mission_reward",
  AGENT_MISSION_REWARD_CORPORATION_TAX: "agent_mission_reward_corporation_tax",
  AGENT_MISSION_TIME_BONUS_REWARD: "agent_mission_time_bonus_reward",
  AGENT_MISSION_TIME_BONUS_REWARD_CORPORATION_TAX:
    "agent_mission_time_bonus_reward_corporation_tax",
  AGENT_SECURITY_SERVICES: "agent_security_services",
  AGENT_SERVICES_RENDERED: "agent_services_rendered",
  AGENTS_PREWARD: "agents_preward",
  ALLIANCE_MAINTAINANCE_FEE: "alliance_maintainance_fee",
  ALLIANCE_REGISTRATION_FEE: "alliance_registration_fee",
  ASSET_SAFETY_RECOVERY_TAX: "asset_safety_recovery_tax",
  BOUNTY: "bounty",
  BOUNTY_PRIZE: "bounty_prize",
  BOUNTY_PRIZE_CORPORATION_TAX: "bounty_prize_corporation_tax",
  BOUNTY_PRIZES: "bounty_prizes",
  BOUNTY_REIMBURSEMENT: "bounty_reimbursement",
  BOUNTY_SURCHARGE: "bounty_surcharge",
  BROKERS_FEE: "brokers_fee",
  CLONE_ACTIVATION: "clone_activation",
  CLONE_TRANSFER: "clone_transfer",
  CONTRABAND_FINE: "contraband_fine",
  CONTRACT_AUCTION_BID: "contract_auction_bid",
  CONTRACT_AUCTION_BID_CORP: "contract_auction_bid_corp",
  CONTRACT_AUCTION_BID_REFUND: "contract_auction_bid_refund",
  CONTRACT_AUCTION_SOLD: "contract_auction_sold",
  CONTRACT_BROKERS_FEE: "contract_brokers_fee",
  CONTRACT_BROKERS_FEE_CORP: "contract_brokers_fee_corp",
  CONTRACT_COLLATERAL: "contract_collateral",
  CONTRACT_COLLATERAL_DEPOSITED_CORP: "contract_collateral_deposited_corp",
  CONTRACT_COLLATERAL_PAYOUT: "contract_collateral_payout",
  CONTRACT_COLLATERAL_REFUND: "contract_collateral_refund",
  CONTRACT_DEPOSIT: "contract_deposit",
  CONTRACT_DEPOSIT_CORP: "contract_deposit_corp",
  CONTRACT_DEPOSIT_REFUND: "contract_deposit_refund",
  CONTRACT_DEPOSIT_SALES_TAX: "contract_deposit_sales_tax",
  CONTRACT_PRICE: "contract_price",
  CONTRACT_PRICE_PAYMENT_CORP: "contract_price_payment_corp",
  CONTRACT_REVERSAL: "contract_reversal",
  CONTRACT_REWARD: "contract_reward",
  CONTRACT_REWARD_DEPOSITED: "contract_reward_deposited",
  CONTRACT_REWARD_DEPOSITED_CORP: "contract_reward_deposited_corp",
  CONTRACT_REWARD_REFUND: "contract_reward_refund",
  CONTRACT_SALES_TAX: "contract_sales_tax",
  COPYING: "copying",
  CORPORATE_REWARD_PAYOUT: "corporate_reward_payout",
  CORPORATE_REWARD_TAX: "corporate_reward_tax",
  CORPORATION_ACCOUNT_WITHDRAWAL: "corporation_account_withdrawal",
  CORPORATION_BULK_PAYMENT: "corporation_bulk_payment",
  CORPORATION_DIVIDEND_PAYMENT: "corporation_dividend_payment",
  CORPORATION_LIQUIDATION: "corporation_liquidation",
  CORPORATION_LOGO_CHANGE_COST: "corporation_logo_change_cost",
  CORPORATION_PAYMENT: "corporation_payment",
  CORPORATION_REGISTRATION_FEE: "corporation_registration_fee",
  COURIER_MISSION_ESCROW: "courier_mission_escrow",
  CSPA: "cspa",
  CSPAOFFLINEREFUND: "cspaofflinerefund",
  DAILY_CHALLENGE_REWARD: "daily_challenge_reward",
  DATACORE_FEE: "datacore_fee",
  DNA_MODIFICATION_FEE: "dna_modification_fee",
  DOCKING_FEE: "docking_fee",
  DUEL_WAGER_ESCROW: "duel_wager_escrow",
  DUEL_WAGER_PAYMENT: "duel_wager_payment",
  DUEL_WAGER_REFUND: "duel_wager_refund",
  ESS_ESCROW_TRANSFER: "ess_escrow_transfer",
  EXTERNAL_TRADE_DELIVERY: "external_trade_delivery",
  EXTERNAL_TRADE_FREEZE: "external_trade_freeze",
  EXTERNAL_TRADE_THAW: "external_trade_thaw",
  FACTORY_SLOT_RENTAL_FEE: "factory_slot_rental_fee",
  FLUX_PAYOUT: "flux_payout",
  FLUX_TAX: "flux_tax",
  FLUX_TICKET_REPAYMENT: "flux_ticket_repayment",
  FLUX_TICKET_SALE: "flux_ticket_sale",
  GM_CASH_TRANSFER: "gm_cash_transfer",
  INDUSTRY_JOB_TAX: "industry_job_tax",
  INFRASTRUCTURE_HUB_MAINTENANCE: "infrastructure_hub_maintenance",
  INHERITANCE: "inheritance",
  INSURANCE: "insurance",
  ITEM_TRADER_PAYMENT: "item_trader_payment",
  JUMP_CLONE_ACTIVATION_FEE: "jump_clone_activation_fee",
  JUMP_CLONE_INSTALLATION_FEE: "jump_clone_installation_fee",
  KILL_RIGHT_FEE: "kill_right_fee",
  LP_STORE: "lp_store",
  MANUFACTURING: "manufacturing",
  MARKET_ESCROW: "market_escrow",
  MARKET_FINE_PAID: "market_fine_paid",
  MARKET_PROVIDER_TAX: "market_provider_tax",
  MARKET_TRANSACTION: "market_transaction",
  MEDAL_CREATION: "medal_creation",
  MEDAL_ISSUED: "medal_issued",
  MILESTONE_REWARD_PAYMENT: "milestone_reward_payment",
  MISSION_COMPLETION: "mission_completion",
  MISSION_COST: "mission_cost",
  MISSION_EXPIRATION: "mission_expiration",
  MISSION_REWARD: "mission_reward",
  OFFICE_RENTAL_FEE: "office_rental_fee",
  OPERATION_BONUS: "operation_bonus",
  OPPORTUNITY_REWARD: "opportunity_reward",
  PLANETARY_CONSTRUCTION: "planetary_construction",
  PLANETARY_EXPORT_TAX: "planetary_export_tax",
  PLANETARY_IMPORT_TAX: "planetary_import_tax",
  PLAYER_DONATION: "player_donation",
  PLAYER_TRADING: "player_trading",
  PROJECT_DISCOVERY_REWARD: "project_discovery_reward",
  PROJECT_DISCOVERY_TAX: "project_discovery_tax",
  REACTION: "reaction",
  REDEEMED_ISK_TOKEN: "redeemed_isk_token",
  RELEASE_OF_IMPOUNDED_PROPERTY: "release_of_impounded_property",
  REPAIR_BILL: "repair_bill",
  REPROCESSING_TAX: "reprocessing_tax",
  RESEARCHING_MATERIAL_PRODUCTIVITY: "researching_material_productivity",
  RESEARCHING_TECHNOLOGY: "researching_technology",
  RESEARCHING_TIME_PRODUCTIVITY: "researching_time_productivity",
  RESOURCE_WARS_REWARD: "resource_wars_reward",
  REVERSE_ENGINEERING: "reverse_engineering",
  SEASON_CHALLENGE_REWARD: "season_challenge_reward",
  SECURITY_PROCESSING_FEE: "security_processing_fee",
  SHARES: "shares",
  SKILL_PURCHASE: "skill_purchase",
  SOVEREIGNITY_BILL: "sovereignity_bill",
  STORE_PURCHASE: "store_purchase",
  STORE_PURCHASE_REFUND: "store_purchase_refund",
  STRUCTURE_GATE_JUMP: "structure_gate_jump",
  TRANSACTION_TAX: "transaction_tax",
  UPKEEP_ADJUSTMENT_FEE: "upkeep_adjustment_fee",
  WAR_ALLY_CONTRACT: "war_ally_contract",
  WAR_FEE: "war_fee",
  WAR_FEE_SURRENDER: "war_fee_surrender",
} as const;

export type GetCharactersCharacterIdWalletJournal200OkRefTypeEnum =
  typeof GetCharactersCharacterIdWalletJournal200OkRefTypeEnum[keyof typeof GetCharactersCharacterIdWalletJournal200OkRefTypeEnum];

/**
 * wallet transaction
 * @export
 * @interface GetCharactersCharacterIdWalletTransactions200Ok
 */
export interface GetCharactersCharacterIdWalletTransactions200Ok {
  /**
   * client_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletTransactions200Ok
   */
  client_id: number;
  /**
   * Date and time of transaction
   * @type {string}
   * @memberof GetCharactersCharacterIdWalletTransactions200Ok
   */
  date: string;
  /**
   * is_buy boolean
   * @type {boolean}
   * @memberof GetCharactersCharacterIdWalletTransactions200Ok
   */
  is_buy: boolean;
  /**
   * is_personal boolean
   * @type {boolean}
   * @memberof GetCharactersCharacterIdWalletTransactions200Ok
   */
  is_personal: boolean;
  /**
   * journal_ref_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletTransactions200Ok
   */
  journal_ref_id: number;
  /**
   * location_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletTransactions200Ok
   */
  location_id: number;
  /**
   * quantity integer
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletTransactions200Ok
   */
  quantity: number;
  /**
   * Unique transaction ID
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletTransactions200Ok
   */
  transaction_id: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletTransactions200Ok
   */
  type_id: number;
  /**
   * Amount paid per unit
   * @type {number}
   * @memberof GetCharactersCharacterIdWalletTransactions200Ok
   */
  unit_price: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetContractsPublicBidsContractId200Ok
 */
export interface GetContractsPublicBidsContractId200Ok {
  /**
   * The amount bid, in ISK
   * @type {number}
   * @memberof GetContractsPublicBidsContractId200Ok
   */
  amount: number;
  /**
   * Unique ID for the bid
   * @type {number}
   * @memberof GetContractsPublicBidsContractId200Ok
   */
  bid_id: number;
  /**
   * Datetime when the bid was placed
   * @type {string}
   * @memberof GetContractsPublicBidsContractId200Ok
   */
  date_bid: string;
}
/**
 * Forbidden
 * @export
 * @interface GetContractsPublicBidsContractIdForbidden
 */
export interface GetContractsPublicBidsContractIdForbidden {
  /**
   * Forbidden message
   * @type {string}
   * @memberof GetContractsPublicBidsContractIdForbidden
   */
  error?: string;
}
/**
 * Not found
 * @export
 * @interface GetContractsPublicBidsContractIdNotFound
 */
export interface GetContractsPublicBidsContractIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetContractsPublicBidsContractIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetContractsPublicItemsContractId200Ok
 */
export interface GetContractsPublicItemsContractId200Ok {
  /**
   * is_blueprint_copy boolean
   * @type {boolean}
   * @memberof GetContractsPublicItemsContractId200Ok
   */
  is_blueprint_copy?: boolean;
  /**
   * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract
   * @type {boolean}
   * @memberof GetContractsPublicItemsContractId200Ok
   */
  is_included: boolean;
  /**
   * Unique ID for the item being sold. Not present if item is being requested by contract rather than sold with contract
   * @type {number}
   * @memberof GetContractsPublicItemsContractId200Ok
   */
  item_id?: number;
  /**
   * Material Efficiency Level of the blueprint
   * @type {number}
   * @memberof GetContractsPublicItemsContractId200Ok
   */
  material_efficiency?: number;
  /**
   * Number of items in the stack
   * @type {number}
   * @memberof GetContractsPublicItemsContractId200Ok
   */
  quantity: number;
  /**
   * Unique ID for the item, used by the contract system
   * @type {number}
   * @memberof GetContractsPublicItemsContractId200Ok
   */
  record_id: number;
  /**
   * Number of runs remaining if the blueprint is a copy, -1 if it is an original
   * @type {number}
   * @memberof GetContractsPublicItemsContractId200Ok
   */
  runs?: number;
  /**
   * Time Efficiency Level of the blueprint
   * @type {number}
   * @memberof GetContractsPublicItemsContractId200Ok
   */
  time_efficiency?: number;
  /**
   * Type ID for item
   * @type {number}
   * @memberof GetContractsPublicItemsContractId200Ok
   */
  type_id: number;
}
/**
 * Forbidden
 * @export
 * @interface GetContractsPublicItemsContractIdForbidden
 */
export interface GetContractsPublicItemsContractIdForbidden {
  /**
   * Forbidden message
   * @type {string}
   * @memberof GetContractsPublicItemsContractIdForbidden
   */
  error?: string;
}
/**
 * Not found
 * @export
 * @interface GetContractsPublicItemsContractIdNotFound
 */
export interface GetContractsPublicItemsContractIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetContractsPublicItemsContractIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetContractsPublicRegionId200Ok
 */
export interface GetContractsPublicRegionId200Ok {
  /**
   * Buyout price (for Auctions only)
   * @type {number}
   * @memberof GetContractsPublicRegionId200Ok
   */
  buyout?: number;
  /**
   * Collateral price (for Couriers only)
   * @type {number}
   * @memberof GetContractsPublicRegionId200Ok
   */
  collateral?: number;
  /**
   * contract_id integer
   * @type {number}
   * @memberof GetContractsPublicRegionId200Ok
   */
  contract_id: number;
  /**
   * Expiration date of the contract
   * @type {string}
   * @memberof GetContractsPublicRegionId200Ok
   */
  date_expired: string;
  /**
   * Сreation date of the contract
   * @type {string}
   * @memberof GetContractsPublicRegionId200Ok
   */
  date_issued: string;
  /**
   * Number of days to perform the contract
   * @type {number}
   * @memberof GetContractsPublicRegionId200Ok
   */
  days_to_complete?: number;
  /**
   * End location ID (for Couriers contract)
   * @type {number}
   * @memberof GetContractsPublicRegionId200Ok
   */
  end_location_id?: number;
  /**
   * true if the contract was issued on behalf of the issuer\'s corporation
   * @type {boolean}
   * @memberof GetContractsPublicRegionId200Ok
   */
  for_corporation?: boolean;
  /**
   * Character\'s corporation ID for the issuer
   * @type {number}
   * @memberof GetContractsPublicRegionId200Ok
   */
  issuer_corporation_id: number;
  /**
   * Character ID for the issuer
   * @type {number}
   * @memberof GetContractsPublicRegionId200Ok
   */
  issuer_id: number;
  /**
   * Price of contract (for ItemsExchange and Auctions)
   * @type {number}
   * @memberof GetContractsPublicRegionId200Ok
   */
  price?: number;
  /**
   * Remuneration for contract (for Couriers only)
   * @type {number}
   * @memberof GetContractsPublicRegionId200Ok
   */
  reward?: number;
  /**
   * Start location ID (for Couriers contract)
   * @type {number}
   * @memberof GetContractsPublicRegionId200Ok
   */
  start_location_id?: number;
  /**
   * Title of the contract
   * @type {string}
   * @memberof GetContractsPublicRegionId200Ok
   */
  title?: string;
  /**
   * Type of the contract
   * @type {string}
   * @memberof GetContractsPublicRegionId200Ok
   */
  type: GetContractsPublicRegionId200OkTypeEnum;
  /**
   * Volume of items in the contract
   * @type {number}
   * @memberof GetContractsPublicRegionId200Ok
   */
  volume?: number;
}

export const GetContractsPublicRegionId200OkTypeEnum = {
  UNKNOWN: "unknown",
  ITEM_EXCHANGE: "item_exchange",
  AUCTION: "auction",
  COURIER: "courier",
  LOAN: "loan",
} as const;

export type GetContractsPublicRegionId200OkTypeEnum =
  typeof GetContractsPublicRegionId200OkTypeEnum[keyof typeof GetContractsPublicRegionId200OkTypeEnum];

/**
 * Not found
 * @export
 * @interface GetContractsPublicRegionIdNotFound
 */
export interface GetContractsPublicRegionIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetContractsPublicRegionIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationCorporationIdMiningExtractions200Ok
 */
export interface GetCorporationCorporationIdMiningExtractions200Ok {
  /**
   * The time at which the chunk being extracted will arrive and can be fractured by the moon mining drill.
   * @type {string}
   * @memberof GetCorporationCorporationIdMiningExtractions200Ok
   */
  chunk_arrival_time: string;
  /**
   * The time at which the current extraction was initiated.
   * @type {string}
   * @memberof GetCorporationCorporationIdMiningExtractions200Ok
   */
  extraction_start_time: string;
  /**
   * moon_id integer
   * @type {number}
   * @memberof GetCorporationCorporationIdMiningExtractions200Ok
   */
  moon_id: number;
  /**
   * The time at which the chunk being extracted will naturally fracture if it is not first fractured by the moon mining drill.
   * @type {string}
   * @memberof GetCorporationCorporationIdMiningExtractions200Ok
   */
  natural_decay_time: string;
  /**
   * structure_id integer
   * @type {number}
   * @memberof GetCorporationCorporationIdMiningExtractions200Ok
   */
  structure_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationCorporationIdMiningObservers200Ok
 */
export interface GetCorporationCorporationIdMiningObservers200Ok {
  /**
   * last_updated string
   * @type {string}
   * @memberof GetCorporationCorporationIdMiningObservers200Ok
   */
  last_updated: string;
  /**
   * The entity that was observing the asteroid field when it was mined.
   * @type {number}
   * @memberof GetCorporationCorporationIdMiningObservers200Ok
   */
  observer_id: number;
  /**
   * The category of the observing entity
   * @type {string}
   * @memberof GetCorporationCorporationIdMiningObservers200Ok
   */
  observer_type: GetCorporationCorporationIdMiningObservers200OkObserverTypeEnum;
}

export const GetCorporationCorporationIdMiningObservers200OkObserverTypeEnum = {
  STRUCTURE: "structure",
} as const;

export type GetCorporationCorporationIdMiningObservers200OkObserverTypeEnum =
  typeof GetCorporationCorporationIdMiningObservers200OkObserverTypeEnum[keyof typeof GetCorporationCorporationIdMiningObservers200OkObserverTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationCorporationIdMiningObserversObserverId200Ok
 */
export interface GetCorporationCorporationIdMiningObserversObserverId200Ok {
  /**
   * The character that did the mining
   * @type {number}
   * @memberof GetCorporationCorporationIdMiningObserversObserverId200Ok
   */
  character_id: number;
  /**
   * last_updated string
   * @type {string}
   * @memberof GetCorporationCorporationIdMiningObserversObserverId200Ok
   */
  last_updated: string;
  /**
   * quantity integer
   * @type {number}
   * @memberof GetCorporationCorporationIdMiningObserversObserverId200Ok
   */
  quantity: number;
  /**
   * The corporation id of the character at the time data was recorded.
   * @type {number}
   * @memberof GetCorporationCorporationIdMiningObserversObserverId200Ok
   */
  recorded_corporation_id: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCorporationCorporationIdMiningObserversObserverId200Ok
   */
  type_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdAlliancehistory200Ok
 */
export interface GetCorporationsCorporationIdAlliancehistory200Ok {
  /**
   * alliance_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdAlliancehistory200Ok
   */
  alliance_id?: number;
  /**
   * True if the alliance has been closed
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdAlliancehistory200Ok
   */
  is_deleted?: boolean;
  /**
   * An incrementing ID that can be used to canonically establish order of records in cases where dates may be ambiguous
   * @type {number}
   * @memberof GetCorporationsCorporationIdAlliancehistory200Ok
   */
  record_id: number;
  /**
   * start_date string
   * @type {string}
   * @memberof GetCorporationsCorporationIdAlliancehistory200Ok
   */
  start_date: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdAssets200Ok
 */
export interface GetCorporationsCorporationIdAssets200Ok {
  /**
   * is_blueprint_copy boolean
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdAssets200Ok
   */
  is_blueprint_copy?: boolean;
  /**
   * is_singleton boolean
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdAssets200Ok
   */
  is_singleton: boolean;
  /**
   * item_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdAssets200Ok
   */
  item_id: number;
  /**
   * location_flag string
   * @type {string}
   * @memberof GetCorporationsCorporationIdAssets200Ok
   */
  location_flag: GetCorporationsCorporationIdAssets200OkLocationFlagEnum;
  /**
   * location_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdAssets200Ok
   */
  location_id: number;
  /**
   * location_type string
   * @type {string}
   * @memberof GetCorporationsCorporationIdAssets200Ok
   */
  location_type: GetCorporationsCorporationIdAssets200OkLocationTypeEnum;
  /**
   * quantity integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdAssets200Ok
   */
  quantity: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdAssets200Ok
   */
  type_id: number;
}

export const GetCorporationsCorporationIdAssets200OkLocationFlagEnum = {
  ASSET_SAFETY: "AssetSafety",
  AUTO_FIT: "AutoFit",
  BONUS: "Bonus",
  BOOSTER: "Booster",
  BOOSTER_BAY: "BoosterBay",
  CAPSULE: "Capsule",
  CARGO: "Cargo",
  CORP_DELIVERIES: "CorpDeliveries",
  CORP_SAG1: "CorpSAG1",
  CORP_SAG2: "CorpSAG2",
  CORP_SAG3: "CorpSAG3",
  CORP_SAG4: "CorpSAG4",
  CORP_SAG5: "CorpSAG5",
  CORP_SAG6: "CorpSAG6",
  CORP_SAG7: "CorpSAG7",
  CRATE_LOOT: "CrateLoot",
  DELIVERIES: "Deliveries",
  DRONE_BAY: "DroneBay",
  DUST_BATTLE: "DustBattle",
  DUST_DATABANK: "DustDatabank",
  FIGHTER_BAY: "FighterBay",
  FIGHTER_TUBE0: "FighterTube0",
  FIGHTER_TUBE1: "FighterTube1",
  FIGHTER_TUBE2: "FighterTube2",
  FIGHTER_TUBE3: "FighterTube3",
  FIGHTER_TUBE4: "FighterTube4",
  FLEET_HANGAR: "FleetHangar",
  FRIGATE_ESCAPE_BAY: "FrigateEscapeBay",
  HANGAR: "Hangar",
  HANGAR_ALL: "HangarAll",
  HI_SLOT0: "HiSlot0",
  HI_SLOT1: "HiSlot1",
  HI_SLOT2: "HiSlot2",
  HI_SLOT3: "HiSlot3",
  HI_SLOT4: "HiSlot4",
  HI_SLOT5: "HiSlot5",
  HI_SLOT6: "HiSlot6",
  HI_SLOT7: "HiSlot7",
  HIDDEN_MODIFIERS: "HiddenModifiers",
  IMPLANT: "Implant",
  IMPOUNDED: "Impounded",
  JUNKYARD_REPROCESSED: "JunkyardReprocessed",
  JUNKYARD_TRASHED: "JunkyardTrashed",
  LO_SLOT0: "LoSlot0",
  LO_SLOT1: "LoSlot1",
  LO_SLOT2: "LoSlot2",
  LO_SLOT3: "LoSlot3",
  LO_SLOT4: "LoSlot4",
  LO_SLOT5: "LoSlot5",
  LO_SLOT6: "LoSlot6",
  LO_SLOT7: "LoSlot7",
  LOCKED: "Locked",
  MED_SLOT0: "MedSlot0",
  MED_SLOT1: "MedSlot1",
  MED_SLOT2: "MedSlot2",
  MED_SLOT3: "MedSlot3",
  MED_SLOT4: "MedSlot4",
  MED_SLOT5: "MedSlot5",
  MED_SLOT6: "MedSlot6",
  MED_SLOT7: "MedSlot7",
  OFFICE_FOLDER: "OfficeFolder",
  PILOT: "Pilot",
  PLANET_SURFACE: "PlanetSurface",
  QUAFE_BAY: "QuafeBay",
  QUANTUM_CORE_ROOM: "QuantumCoreRoom",
  REWARD: "Reward",
  RIG_SLOT0: "RigSlot0",
  RIG_SLOT1: "RigSlot1",
  RIG_SLOT2: "RigSlot2",
  RIG_SLOT3: "RigSlot3",
  RIG_SLOT4: "RigSlot4",
  RIG_SLOT5: "RigSlot5",
  RIG_SLOT6: "RigSlot6",
  RIG_SLOT7: "RigSlot7",
  SECONDARY_STORAGE: "SecondaryStorage",
  SERVICE_SLOT0: "ServiceSlot0",
  SERVICE_SLOT1: "ServiceSlot1",
  SERVICE_SLOT2: "ServiceSlot2",
  SERVICE_SLOT3: "ServiceSlot3",
  SERVICE_SLOT4: "ServiceSlot4",
  SERVICE_SLOT5: "ServiceSlot5",
  SERVICE_SLOT6: "ServiceSlot6",
  SERVICE_SLOT7: "ServiceSlot7",
  SHIP_HANGAR: "ShipHangar",
  SHIP_OFFLINE: "ShipOffline",
  SKILL: "Skill",
  SKILL_IN_TRAINING: "SkillInTraining",
  SPECIALIZED_AMMO_HOLD: "SpecializedAmmoHold",
  SPECIALIZED_ASTEROID_HOLD: "SpecializedAsteroidHold",
  SPECIALIZED_COMMAND_CENTER_HOLD: "SpecializedCommandCenterHold",
  SPECIALIZED_FUEL_BAY: "SpecializedFuelBay",
  SPECIALIZED_GAS_HOLD: "SpecializedGasHold",
  SPECIALIZED_ICE_HOLD: "SpecializedIceHold",
  SPECIALIZED_INDUSTRIAL_SHIP_HOLD: "SpecializedIndustrialShipHold",
  SPECIALIZED_LARGE_SHIP_HOLD: "SpecializedLargeShipHold",
  SPECIALIZED_MATERIAL_BAY: "SpecializedMaterialBay",
  SPECIALIZED_MEDIUM_SHIP_HOLD: "SpecializedMediumShipHold",
  SPECIALIZED_MINERAL_HOLD: "SpecializedMineralHold",
  SPECIALIZED_ORE_HOLD: "SpecializedOreHold",
  SPECIALIZED_PLANETARY_COMMODITIES_HOLD: "SpecializedPlanetaryCommoditiesHold",
  SPECIALIZED_SALVAGE_HOLD: "SpecializedSalvageHold",
  SPECIALIZED_SHIP_HOLD: "SpecializedShipHold",
  SPECIALIZED_SMALL_SHIP_HOLD: "SpecializedSmallShipHold",
  STRUCTURE_ACTIVE: "StructureActive",
  STRUCTURE_FUEL: "StructureFuel",
  STRUCTURE_INACTIVE: "StructureInactive",
  STRUCTURE_OFFLINE: "StructureOffline",
  SUB_SYSTEM_BAY: "SubSystemBay",
  SUB_SYSTEM_SLOT0: "SubSystemSlot0",
  SUB_SYSTEM_SLOT1: "SubSystemSlot1",
  SUB_SYSTEM_SLOT2: "SubSystemSlot2",
  SUB_SYSTEM_SLOT3: "SubSystemSlot3",
  SUB_SYSTEM_SLOT4: "SubSystemSlot4",
  SUB_SYSTEM_SLOT5: "SubSystemSlot5",
  SUB_SYSTEM_SLOT6: "SubSystemSlot6",
  SUB_SYSTEM_SLOT7: "SubSystemSlot7",
  UNLOCKED: "Unlocked",
  WALLET: "Wallet",
  WARDROBE: "Wardrobe",
} as const;

export type GetCorporationsCorporationIdAssets200OkLocationFlagEnum =
  typeof GetCorporationsCorporationIdAssets200OkLocationFlagEnum[keyof typeof GetCorporationsCorporationIdAssets200OkLocationFlagEnum];
export const GetCorporationsCorporationIdAssets200OkLocationTypeEnum = {
  STATION: "station",
  SOLAR_SYSTEM: "solar_system",
  ITEM: "item",
  OTHER: "other",
} as const;

export type GetCorporationsCorporationIdAssets200OkLocationTypeEnum =
  typeof GetCorporationsCorporationIdAssets200OkLocationTypeEnum[keyof typeof GetCorporationsCorporationIdAssets200OkLocationTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdBlueprints200Ok
 */
export interface GetCorporationsCorporationIdBlueprints200Ok {
  /**
   * Unique ID for this item.
   * @type {number}
   * @memberof GetCorporationsCorporationIdBlueprints200Ok
   */
  item_id: number;
  /**
   * Type of the location_id
   * @type {string}
   * @memberof GetCorporationsCorporationIdBlueprints200Ok
   */
  location_flag: GetCorporationsCorporationIdBlueprints200OkLocationFlagEnum;
  /**
   * References a station, a ship or an item_id if this blueprint is located within a container.
   * @type {number}
   * @memberof GetCorporationsCorporationIdBlueprints200Ok
   */
  location_id: number;
  /**
   * Material Efficiency Level of the blueprint.
   * @type {number}
   * @memberof GetCorporationsCorporationIdBlueprints200Ok
   */
  material_efficiency: number;
  /**
   * A range of numbers with a minimum of -2 and no maximum value where -1 is an original and -2 is a copy. It can be a positive integer if it is a stack of blueprint originals fresh from the market (e.g. no activities performed on them yet).
   * @type {number}
   * @memberof GetCorporationsCorporationIdBlueprints200Ok
   */
  quantity: number;
  /**
   * Number of runs remaining if the blueprint is a copy, -1 if it is an original.
   * @type {number}
   * @memberof GetCorporationsCorporationIdBlueprints200Ok
   */
  runs: number;
  /**
   * Time Efficiency Level of the blueprint.
   * @type {number}
   * @memberof GetCorporationsCorporationIdBlueprints200Ok
   */
  time_efficiency: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdBlueprints200Ok
   */
  type_id: number;
}

export const GetCorporationsCorporationIdBlueprints200OkLocationFlagEnum = {
  ASSET_SAFETY: "AssetSafety",
  AUTO_FIT: "AutoFit",
  BONUS: "Bonus",
  BOOSTER: "Booster",
  BOOSTER_BAY: "BoosterBay",
  CAPSULE: "Capsule",
  CARGO: "Cargo",
  CORP_DELIVERIES: "CorpDeliveries",
  CORP_SAG1: "CorpSAG1",
  CORP_SAG2: "CorpSAG2",
  CORP_SAG3: "CorpSAG3",
  CORP_SAG4: "CorpSAG4",
  CORP_SAG5: "CorpSAG5",
  CORP_SAG6: "CorpSAG6",
  CORP_SAG7: "CorpSAG7",
  CRATE_LOOT: "CrateLoot",
  DELIVERIES: "Deliveries",
  DRONE_BAY: "DroneBay",
  DUST_BATTLE: "DustBattle",
  DUST_DATABANK: "DustDatabank",
  FIGHTER_BAY: "FighterBay",
  FIGHTER_TUBE0: "FighterTube0",
  FIGHTER_TUBE1: "FighterTube1",
  FIGHTER_TUBE2: "FighterTube2",
  FIGHTER_TUBE3: "FighterTube3",
  FIGHTER_TUBE4: "FighterTube4",
  FLEET_HANGAR: "FleetHangar",
  FRIGATE_ESCAPE_BAY: "FrigateEscapeBay",
  HANGAR: "Hangar",
  HANGAR_ALL: "HangarAll",
  HI_SLOT0: "HiSlot0",
  HI_SLOT1: "HiSlot1",
  HI_SLOT2: "HiSlot2",
  HI_SLOT3: "HiSlot3",
  HI_SLOT4: "HiSlot4",
  HI_SLOT5: "HiSlot5",
  HI_SLOT6: "HiSlot6",
  HI_SLOT7: "HiSlot7",
  HIDDEN_MODIFIERS: "HiddenModifiers",
  IMPLANT: "Implant",
  IMPOUNDED: "Impounded",
  JUNKYARD_REPROCESSED: "JunkyardReprocessed",
  JUNKYARD_TRASHED: "JunkyardTrashed",
  LO_SLOT0: "LoSlot0",
  LO_SLOT1: "LoSlot1",
  LO_SLOT2: "LoSlot2",
  LO_SLOT3: "LoSlot3",
  LO_SLOT4: "LoSlot4",
  LO_SLOT5: "LoSlot5",
  LO_SLOT6: "LoSlot6",
  LO_SLOT7: "LoSlot7",
  LOCKED: "Locked",
  MED_SLOT0: "MedSlot0",
  MED_SLOT1: "MedSlot1",
  MED_SLOT2: "MedSlot2",
  MED_SLOT3: "MedSlot3",
  MED_SLOT4: "MedSlot4",
  MED_SLOT5: "MedSlot5",
  MED_SLOT6: "MedSlot6",
  MED_SLOT7: "MedSlot7",
  OFFICE_FOLDER: "OfficeFolder",
  PILOT: "Pilot",
  PLANET_SURFACE: "PlanetSurface",
  QUAFE_BAY: "QuafeBay",
  QUANTUM_CORE_ROOM: "QuantumCoreRoom",
  REWARD: "Reward",
  RIG_SLOT0: "RigSlot0",
  RIG_SLOT1: "RigSlot1",
  RIG_SLOT2: "RigSlot2",
  RIG_SLOT3: "RigSlot3",
  RIG_SLOT4: "RigSlot4",
  RIG_SLOT5: "RigSlot5",
  RIG_SLOT6: "RigSlot6",
  RIG_SLOT7: "RigSlot7",
  SECONDARY_STORAGE: "SecondaryStorage",
  SERVICE_SLOT0: "ServiceSlot0",
  SERVICE_SLOT1: "ServiceSlot1",
  SERVICE_SLOT2: "ServiceSlot2",
  SERVICE_SLOT3: "ServiceSlot3",
  SERVICE_SLOT4: "ServiceSlot4",
  SERVICE_SLOT5: "ServiceSlot5",
  SERVICE_SLOT6: "ServiceSlot6",
  SERVICE_SLOT7: "ServiceSlot7",
  SHIP_HANGAR: "ShipHangar",
  SHIP_OFFLINE: "ShipOffline",
  SKILL: "Skill",
  SKILL_IN_TRAINING: "SkillInTraining",
  SPECIALIZED_AMMO_HOLD: "SpecializedAmmoHold",
  SPECIALIZED_COMMAND_CENTER_HOLD: "SpecializedCommandCenterHold",
  SPECIALIZED_FUEL_BAY: "SpecializedFuelBay",
  SPECIALIZED_GAS_HOLD: "SpecializedGasHold",
  SPECIALIZED_INDUSTRIAL_SHIP_HOLD: "SpecializedIndustrialShipHold",
  SPECIALIZED_LARGE_SHIP_HOLD: "SpecializedLargeShipHold",
  SPECIALIZED_MATERIAL_BAY: "SpecializedMaterialBay",
  SPECIALIZED_MEDIUM_SHIP_HOLD: "SpecializedMediumShipHold",
  SPECIALIZED_MINERAL_HOLD: "SpecializedMineralHold",
  SPECIALIZED_ORE_HOLD: "SpecializedOreHold",
  SPECIALIZED_PLANETARY_COMMODITIES_HOLD: "SpecializedPlanetaryCommoditiesHold",
  SPECIALIZED_SALVAGE_HOLD: "SpecializedSalvageHold",
  SPECIALIZED_SHIP_HOLD: "SpecializedShipHold",
  SPECIALIZED_SMALL_SHIP_HOLD: "SpecializedSmallShipHold",
  STRUCTURE_ACTIVE: "StructureActive",
  STRUCTURE_FUEL: "StructureFuel",
  STRUCTURE_INACTIVE: "StructureInactive",
  STRUCTURE_OFFLINE: "StructureOffline",
  SUB_SYSTEM_BAY: "SubSystemBay",
  SUB_SYSTEM_SLOT0: "SubSystemSlot0",
  SUB_SYSTEM_SLOT1: "SubSystemSlot1",
  SUB_SYSTEM_SLOT2: "SubSystemSlot2",
  SUB_SYSTEM_SLOT3: "SubSystemSlot3",
  SUB_SYSTEM_SLOT4: "SubSystemSlot4",
  SUB_SYSTEM_SLOT5: "SubSystemSlot5",
  SUB_SYSTEM_SLOT6: "SubSystemSlot6",
  SUB_SYSTEM_SLOT7: "SubSystemSlot7",
  UNLOCKED: "Unlocked",
  WALLET: "Wallet",
  WARDROBE: "Wardrobe",
} as const;

export type GetCorporationsCorporationIdBlueprints200OkLocationFlagEnum =
  typeof GetCorporationsCorporationIdBlueprints200OkLocationFlagEnum[keyof typeof GetCorporationsCorporationIdBlueprints200OkLocationFlagEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdBookmarks200Ok
 */
export interface GetCorporationsCorporationIdBookmarks200Ok {
  /**
   * bookmark_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdBookmarks200Ok
   */
  bookmark_id: number;
  /**
   *
   * @type {GetCorporationsCorporationIdBookmarksCoordinates}
   * @memberof GetCorporationsCorporationIdBookmarks200Ok
   */
  coordinates?: GetCorporationsCorporationIdBookmarksCoordinates;
  /**
   * created string
   * @type {string}
   * @memberof GetCorporationsCorporationIdBookmarks200Ok
   */
  created: string;
  /**
   * creator_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdBookmarks200Ok
   */
  creator_id: number;
  /**
   * folder_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdBookmarks200Ok
   */
  folder_id?: number;
  /**
   *
   * @type {GetCorporationsCorporationIdBookmarksItem}
   * @memberof GetCorporationsCorporationIdBookmarks200Ok
   */
  item?: GetCorporationsCorporationIdBookmarksItem;
  /**
   * label string
   * @type {string}
   * @memberof GetCorporationsCorporationIdBookmarks200Ok
   */
  label: string;
  /**
   * location_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdBookmarks200Ok
   */
  location_id: number;
  /**
   * notes string
   * @type {string}
   * @memberof GetCorporationsCorporationIdBookmarks200Ok
   */
  notes: string;
}
/**
 * Optional object that is returned if a bookmark was made on a planet or a random location in space.
 * @export
 * @interface GetCorporationsCorporationIdBookmarksCoordinates
 */
export interface GetCorporationsCorporationIdBookmarksCoordinates {
  /**
   * x number
   * @type {number}
   * @memberof GetCorporationsCorporationIdBookmarksCoordinates
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof GetCorporationsCorporationIdBookmarksCoordinates
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof GetCorporationsCorporationIdBookmarksCoordinates
   */
  z: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdBookmarksFolders200Ok
 */
export interface GetCorporationsCorporationIdBookmarksFolders200Ok {
  /**
   * creator_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdBookmarksFolders200Ok
   */
  creator_id?: number;
  /**
   * folder_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdBookmarksFolders200Ok
   */
  folder_id: number;
  /**
   * name string
   * @type {string}
   * @memberof GetCorporationsCorporationIdBookmarksFolders200Ok
   */
  name: string;
}
/**
 * Optional object that is returned if a bookmark was made on a particular item.
 * @export
 * @interface GetCorporationsCorporationIdBookmarksItem
 */
export interface GetCorporationsCorporationIdBookmarksItem {
  /**
   * item_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdBookmarksItem
   */
  item_id: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdBookmarksItem
   */
  type_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdContacts200Ok
 */
export interface GetCorporationsCorporationIdContacts200Ok {
  /**
   * contact_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdContacts200Ok
   */
  contact_id: number;
  /**
   * contact_type string
   * @type {string}
   * @memberof GetCorporationsCorporationIdContacts200Ok
   */
  contact_type: GetCorporationsCorporationIdContacts200OkContactTypeEnum;
  /**
   * Whether this contact is being watched
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdContacts200Ok
   */
  is_watched?: boolean;
  /**
   * label_ids array
   * @type {Array<number>}
   * @memberof GetCorporationsCorporationIdContacts200Ok
   */
  label_ids?: Array<number>;
  /**
   * Standing of the contact
   * @type {number}
   * @memberof GetCorporationsCorporationIdContacts200Ok
   */
  standing: number;
}

export const GetCorporationsCorporationIdContacts200OkContactTypeEnum = {
  CHARACTER: "character",
  CORPORATION: "corporation",
  ALLIANCE: "alliance",
  FACTION: "faction",
} as const;

export type GetCorporationsCorporationIdContacts200OkContactTypeEnum =
  typeof GetCorporationsCorporationIdContacts200OkContactTypeEnum[keyof typeof GetCorporationsCorporationIdContacts200OkContactTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdContactsLabels200Ok
 */
export interface GetCorporationsCorporationIdContactsLabels200Ok {
  /**
   * label_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdContactsLabels200Ok
   */
  label_id: number;
  /**
   * label_name string
   * @type {string}
   * @memberof GetCorporationsCorporationIdContactsLabels200Ok
   */
  label_name: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdContainersLogs200Ok
 */
export interface GetCorporationsCorporationIdContainersLogs200Ok {
  /**
   * action string
   * @type {string}
   * @memberof GetCorporationsCorporationIdContainersLogs200Ok
   */
  action: GetCorporationsCorporationIdContainersLogs200OkActionEnum;
  /**
   * ID of the character who performed the action.
   * @type {number}
   * @memberof GetCorporationsCorporationIdContainersLogs200Ok
   */
  character_id: number;
  /**
   * ID of the container
   * @type {number}
   * @memberof GetCorporationsCorporationIdContainersLogs200Ok
   */
  container_id: number;
  /**
   * Type ID of the container
   * @type {number}
   * @memberof GetCorporationsCorporationIdContainersLogs200Ok
   */
  container_type_id: number;
  /**
   * location_flag string
   * @type {string}
   * @memberof GetCorporationsCorporationIdContainersLogs200Ok
   */
  location_flag: GetCorporationsCorporationIdContainersLogs200OkLocationFlagEnum;
  /**
   * location_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdContainersLogs200Ok
   */
  location_id: number;
  /**
   * Timestamp when this log was created
   * @type {string}
   * @memberof GetCorporationsCorporationIdContainersLogs200Ok
   */
  logged_at: string;
  /**
   * new_config_bitmask integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdContainersLogs200Ok
   */
  new_config_bitmask?: number;
  /**
   * old_config_bitmask integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdContainersLogs200Ok
   */
  old_config_bitmask?: number;
  /**
   * Type of password set if action is of type SetPassword or EnterPassword
   * @type {string}
   * @memberof GetCorporationsCorporationIdContainersLogs200Ok
   */
  password_type?: GetCorporationsCorporationIdContainersLogs200OkPasswordTypeEnum;
  /**
   * Quantity of the item being acted upon
   * @type {number}
   * @memberof GetCorporationsCorporationIdContainersLogs200Ok
   */
  quantity?: number;
  /**
   * Type ID of the item being acted upon
   * @type {number}
   * @memberof GetCorporationsCorporationIdContainersLogs200Ok
   */
  type_id?: number;
}

export const GetCorporationsCorporationIdContainersLogs200OkActionEnum = {
  ADD: "add",
  ASSEMBLE: "assemble",
  CONFIGURE: "configure",
  ENTER_PASSWORD: "enter_password",
  LOCK: "lock",
  MOVE: "move",
  REPACKAGE: "repackage",
  SET_NAME: "set_name",
  SET_PASSWORD: "set_password",
  UNLOCK: "unlock",
} as const;

export type GetCorporationsCorporationIdContainersLogs200OkActionEnum =
  typeof GetCorporationsCorporationIdContainersLogs200OkActionEnum[keyof typeof GetCorporationsCorporationIdContainersLogs200OkActionEnum];
export const GetCorporationsCorporationIdContainersLogs200OkLocationFlagEnum = {
  ASSET_SAFETY: "AssetSafety",
  AUTO_FIT: "AutoFit",
  BONUS: "Bonus",
  BOOSTER: "Booster",
  BOOSTER_BAY: "BoosterBay",
  CAPSULE: "Capsule",
  CARGO: "Cargo",
  CORP_DELIVERIES: "CorpDeliveries",
  CORP_SAG1: "CorpSAG1",
  CORP_SAG2: "CorpSAG2",
  CORP_SAG3: "CorpSAG3",
  CORP_SAG4: "CorpSAG4",
  CORP_SAG5: "CorpSAG5",
  CORP_SAG6: "CorpSAG6",
  CORP_SAG7: "CorpSAG7",
  CRATE_LOOT: "CrateLoot",
  DELIVERIES: "Deliveries",
  DRONE_BAY: "DroneBay",
  DUST_BATTLE: "DustBattle",
  DUST_DATABANK: "DustDatabank",
  FIGHTER_BAY: "FighterBay",
  FIGHTER_TUBE0: "FighterTube0",
  FIGHTER_TUBE1: "FighterTube1",
  FIGHTER_TUBE2: "FighterTube2",
  FIGHTER_TUBE3: "FighterTube3",
  FIGHTER_TUBE4: "FighterTube4",
  FLEET_HANGAR: "FleetHangar",
  FRIGATE_ESCAPE_BAY: "FrigateEscapeBay",
  HANGAR: "Hangar",
  HANGAR_ALL: "HangarAll",
  HI_SLOT0: "HiSlot0",
  HI_SLOT1: "HiSlot1",
  HI_SLOT2: "HiSlot2",
  HI_SLOT3: "HiSlot3",
  HI_SLOT4: "HiSlot4",
  HI_SLOT5: "HiSlot5",
  HI_SLOT6: "HiSlot6",
  HI_SLOT7: "HiSlot7",
  HIDDEN_MODIFIERS: "HiddenModifiers",
  IMPLANT: "Implant",
  IMPOUNDED: "Impounded",
  JUNKYARD_REPROCESSED: "JunkyardReprocessed",
  JUNKYARD_TRASHED: "JunkyardTrashed",
  LO_SLOT0: "LoSlot0",
  LO_SLOT1: "LoSlot1",
  LO_SLOT2: "LoSlot2",
  LO_SLOT3: "LoSlot3",
  LO_SLOT4: "LoSlot4",
  LO_SLOT5: "LoSlot5",
  LO_SLOT6: "LoSlot6",
  LO_SLOT7: "LoSlot7",
  LOCKED: "Locked",
  MED_SLOT0: "MedSlot0",
  MED_SLOT1: "MedSlot1",
  MED_SLOT2: "MedSlot2",
  MED_SLOT3: "MedSlot3",
  MED_SLOT4: "MedSlot4",
  MED_SLOT5: "MedSlot5",
  MED_SLOT6: "MedSlot6",
  MED_SLOT7: "MedSlot7",
  OFFICE_FOLDER: "OfficeFolder",
  PILOT: "Pilot",
  PLANET_SURFACE: "PlanetSurface",
  QUAFE_BAY: "QuafeBay",
  QUANTUM_CORE_ROOM: "QuantumCoreRoom",
  REWARD: "Reward",
  RIG_SLOT0: "RigSlot0",
  RIG_SLOT1: "RigSlot1",
  RIG_SLOT2: "RigSlot2",
  RIG_SLOT3: "RigSlot3",
  RIG_SLOT4: "RigSlot4",
  RIG_SLOT5: "RigSlot5",
  RIG_SLOT6: "RigSlot6",
  RIG_SLOT7: "RigSlot7",
  SECONDARY_STORAGE: "SecondaryStorage",
  SERVICE_SLOT0: "ServiceSlot0",
  SERVICE_SLOT1: "ServiceSlot1",
  SERVICE_SLOT2: "ServiceSlot2",
  SERVICE_SLOT3: "ServiceSlot3",
  SERVICE_SLOT4: "ServiceSlot4",
  SERVICE_SLOT5: "ServiceSlot5",
  SERVICE_SLOT6: "ServiceSlot6",
  SERVICE_SLOT7: "ServiceSlot7",
  SHIP_HANGAR: "ShipHangar",
  SHIP_OFFLINE: "ShipOffline",
  SKILL: "Skill",
  SKILL_IN_TRAINING: "SkillInTraining",
  SPECIALIZED_AMMO_HOLD: "SpecializedAmmoHold",
  SPECIALIZED_COMMAND_CENTER_HOLD: "SpecializedCommandCenterHold",
  SPECIALIZED_FUEL_BAY: "SpecializedFuelBay",
  SPECIALIZED_GAS_HOLD: "SpecializedGasHold",
  SPECIALIZED_INDUSTRIAL_SHIP_HOLD: "SpecializedIndustrialShipHold",
  SPECIALIZED_LARGE_SHIP_HOLD: "SpecializedLargeShipHold",
  SPECIALIZED_MATERIAL_BAY: "SpecializedMaterialBay",
  SPECIALIZED_MEDIUM_SHIP_HOLD: "SpecializedMediumShipHold",
  SPECIALIZED_MINERAL_HOLD: "SpecializedMineralHold",
  SPECIALIZED_ORE_HOLD: "SpecializedOreHold",
  SPECIALIZED_PLANETARY_COMMODITIES_HOLD: "SpecializedPlanetaryCommoditiesHold",
  SPECIALIZED_SALVAGE_HOLD: "SpecializedSalvageHold",
  SPECIALIZED_SHIP_HOLD: "SpecializedShipHold",
  SPECIALIZED_SMALL_SHIP_HOLD: "SpecializedSmallShipHold",
  STRUCTURE_ACTIVE: "StructureActive",
  STRUCTURE_FUEL: "StructureFuel",
  STRUCTURE_INACTIVE: "StructureInactive",
  STRUCTURE_OFFLINE: "StructureOffline",
  SUB_SYSTEM_BAY: "SubSystemBay",
  SUB_SYSTEM_SLOT0: "SubSystemSlot0",
  SUB_SYSTEM_SLOT1: "SubSystemSlot1",
  SUB_SYSTEM_SLOT2: "SubSystemSlot2",
  SUB_SYSTEM_SLOT3: "SubSystemSlot3",
  SUB_SYSTEM_SLOT4: "SubSystemSlot4",
  SUB_SYSTEM_SLOT5: "SubSystemSlot5",
  SUB_SYSTEM_SLOT6: "SubSystemSlot6",
  SUB_SYSTEM_SLOT7: "SubSystemSlot7",
  UNLOCKED: "Unlocked",
  WALLET: "Wallet",
  WARDROBE: "Wardrobe",
} as const;

export type GetCorporationsCorporationIdContainersLogs200OkLocationFlagEnum =
  typeof GetCorporationsCorporationIdContainersLogs200OkLocationFlagEnum[keyof typeof GetCorporationsCorporationIdContainersLogs200OkLocationFlagEnum];
export const GetCorporationsCorporationIdContainersLogs200OkPasswordTypeEnum = {
  CONFIG: "config",
  GENERAL: "general",
} as const;

export type GetCorporationsCorporationIdContainersLogs200OkPasswordTypeEnum =
  typeof GetCorporationsCorporationIdContainersLogs200OkPasswordTypeEnum[keyof typeof GetCorporationsCorporationIdContainersLogs200OkPasswordTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdContracts200Ok
 */
export interface GetCorporationsCorporationIdContracts200Ok {
  /**
   * Who will accept the contract
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  acceptor_id: number;
  /**
   * ID to whom the contract is assigned, can be corporation or character ID
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  assignee_id: number;
  /**
   * To whom the contract is available
   * @type {string}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  availability: GetCorporationsCorporationIdContracts200OkAvailabilityEnum;
  /**
   * Buyout price (for Auctions only)
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  buyout?: number;
  /**
   * Collateral price (for Couriers only)
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  collateral?: number;
  /**
   * contract_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  contract_id: number;
  /**
   * Date of confirmation of contract
   * @type {string}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  date_accepted?: string;
  /**
   * Date of completed of contract
   * @type {string}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  date_completed?: string;
  /**
   * Expiration date of the contract
   * @type {string}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  date_expired: string;
  /**
   * Сreation date of the contract
   * @type {string}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  date_issued: string;
  /**
   * Number of days to perform the contract
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  days_to_complete?: number;
  /**
   * End location ID (for Couriers contract)
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  end_location_id?: number;
  /**
   * true if the contract was issued on behalf of the issuer\'s corporation
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  for_corporation: boolean;
  /**
   * Character\'s corporation ID for the issuer
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  issuer_corporation_id: number;
  /**
   * Character ID for the issuer
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  issuer_id: number;
  /**
   * Price of contract (for ItemsExchange and Auctions)
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  price?: number;
  /**
   * Remuneration for contract (for Couriers only)
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  reward?: number;
  /**
   * Start location ID (for Couriers contract)
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  start_location_id?: number;
  /**
   * Status of the the contract
   * @type {string}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  status: GetCorporationsCorporationIdContracts200OkStatusEnum;
  /**
   * Title of the contract
   * @type {string}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  title?: string;
  /**
   * Type of the contract
   * @type {string}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  type: GetCorporationsCorporationIdContracts200OkTypeEnum;
  /**
   * Volume of items in the contract
   * @type {number}
   * @memberof GetCorporationsCorporationIdContracts200Ok
   */
  volume?: number;
}

export const GetCorporationsCorporationIdContracts200OkAvailabilityEnum = {
  PUBLIC: "public",
  PERSONAL: "personal",
  CORPORATION: "corporation",
  ALLIANCE: "alliance",
} as const;

export type GetCorporationsCorporationIdContracts200OkAvailabilityEnum =
  typeof GetCorporationsCorporationIdContracts200OkAvailabilityEnum[keyof typeof GetCorporationsCorporationIdContracts200OkAvailabilityEnum];
export const GetCorporationsCorporationIdContracts200OkStatusEnum = {
  OUTSTANDING: "outstanding",
  IN_PROGRESS: "in_progress",
  FINISHED_ISSUER: "finished_issuer",
  FINISHED_CONTRACTOR: "finished_contractor",
  FINISHED: "finished",
  CANCELLED: "cancelled",
  REJECTED: "rejected",
  FAILED: "failed",
  DELETED: "deleted",
  REVERSED: "reversed",
} as const;

export type GetCorporationsCorporationIdContracts200OkStatusEnum =
  typeof GetCorporationsCorporationIdContracts200OkStatusEnum[keyof typeof GetCorporationsCorporationIdContracts200OkStatusEnum];
export const GetCorporationsCorporationIdContracts200OkTypeEnum = {
  UNKNOWN: "unknown",
  ITEM_EXCHANGE: "item_exchange",
  AUCTION: "auction",
  COURIER: "courier",
  LOAN: "loan",
} as const;

export type GetCorporationsCorporationIdContracts200OkTypeEnum =
  typeof GetCorporationsCorporationIdContracts200OkTypeEnum[keyof typeof GetCorporationsCorporationIdContracts200OkTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdContractsContractIdBids200Ok
 */
export interface GetCorporationsCorporationIdContractsContractIdBids200Ok {
  /**
   * The amount bid, in ISK
   * @type {number}
   * @memberof GetCorporationsCorporationIdContractsContractIdBids200Ok
   */
  amount: number;
  /**
   * Unique ID for the bid
   * @type {number}
   * @memberof GetCorporationsCorporationIdContractsContractIdBids200Ok
   */
  bid_id: number;
  /**
   * Character ID of the bidder
   * @type {number}
   * @memberof GetCorporationsCorporationIdContractsContractIdBids200Ok
   */
  bidder_id: number;
  /**
   * Datetime when the bid was placed
   * @type {string}
   * @memberof GetCorporationsCorporationIdContractsContractIdBids200Ok
   */
  date_bid: string;
}
/**
 * Not found
 * @export
 * @interface GetCorporationsCorporationIdContractsContractIdBidsNotFound
 */
export interface GetCorporationsCorporationIdContractsContractIdBidsNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetCorporationsCorporationIdContractsContractIdBidsNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdContractsContractIdItems200Ok
 */
export interface GetCorporationsCorporationIdContractsContractIdItems200Ok {
  /**
   * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdContractsContractIdItems200Ok
   */
  is_included: boolean;
  /**
   * is_singleton boolean
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdContractsContractIdItems200Ok
   */
  is_singleton: boolean;
  /**
   * Number of items in the stack
   * @type {number}
   * @memberof GetCorporationsCorporationIdContractsContractIdItems200Ok
   */
  quantity: number;
  /**
   * -1 indicates that the item is a singleton (non-stackable). If the item happens to be a Blueprint, -1 is an Original and -2 is a Blueprint Copy
   * @type {number}
   * @memberof GetCorporationsCorporationIdContractsContractIdItems200Ok
   */
  raw_quantity?: number;
  /**
   * Unique ID for the item
   * @type {number}
   * @memberof GetCorporationsCorporationIdContractsContractIdItems200Ok
   */
  record_id: number;
  /**
   * Type ID for item
   * @type {number}
   * @memberof GetCorporationsCorporationIdContractsContractIdItems200Ok
   */
  type_id: number;
}
/**
 * Error 520
 * @export
 * @interface GetCorporationsCorporationIdContractsContractIdItemsError520
 */
export interface GetCorporationsCorporationIdContractsContractIdItemsError520 {
  /**
   * Error 520 message
   * @type {string}
   * @memberof GetCorporationsCorporationIdContractsContractIdItemsError520
   */
  error?: string;
}
/**
 * Not found
 * @export
 * @interface GetCorporationsCorporationIdContractsContractIdItemsNotFound
 */
export interface GetCorporationsCorporationIdContractsContractIdItemsNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetCorporationsCorporationIdContractsContractIdItemsNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdCustomsOffices200Ok
 */
export interface GetCorporationsCorporationIdCustomsOffices200Ok {
  /**
   * Only present if alliance access is allowed
   * @type {number}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  alliance_tax_rate?: number;
  /**
   * standing_level and any standing related tax rate only present when this is true
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  allow_access_with_standings: boolean;
  /**
   * allow_alliance_access boolean
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  allow_alliance_access: boolean;
  /**
   * bad_standing_tax_rate number
   * @type {number}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  bad_standing_tax_rate?: number;
  /**
   * corporation_tax_rate number
   * @type {number}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  corporation_tax_rate?: number;
  /**
   * Tax rate for entities with excellent level of standing, only present if this level is allowed, same for all other standing related tax rates
   * @type {number}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  excellent_standing_tax_rate?: number;
  /**
   * good_standing_tax_rate number
   * @type {number}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  good_standing_tax_rate?: number;
  /**
   * neutral_standing_tax_rate number
   * @type {number}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  neutral_standing_tax_rate?: number;
  /**
   * unique ID of this customs office
   * @type {number}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  office_id: number;
  /**
   * reinforce_exit_end integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  reinforce_exit_end: number;
  /**
   * Together with reinforce_exit_end, marks a 2-hour period where this customs office could exit reinforcement mode during the day after initial attack
   * @type {number}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  reinforce_exit_start: number;
  /**
   * Access is allowed only for entities with this level of standing or better
   * @type {string}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  standing_level?: GetCorporationsCorporationIdCustomsOffices200OkStandingLevelEnum;
  /**
   * ID of the solar system this customs office is located in
   * @type {number}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  system_id: number;
  /**
   * terrible_standing_tax_rate number
   * @type {number}
   * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
   */
  terrible_standing_tax_rate?: number;
}

export const GetCorporationsCorporationIdCustomsOffices200OkStandingLevelEnum =
  {
    BAD: "bad",
    EXCELLENT: "excellent",
    GOOD: "good",
    NEUTRAL: "neutral",
    TERRIBLE: "terrible",
  } as const;

export type GetCorporationsCorporationIdCustomsOffices200OkStandingLevelEnum =
  typeof GetCorporationsCorporationIdCustomsOffices200OkStandingLevelEnum[keyof typeof GetCorporationsCorporationIdCustomsOffices200OkStandingLevelEnum];

/**
 * hangar object
 * @export
 * @interface GetCorporationsCorporationIdDivisionsHangarHangar
 */
export interface GetCorporationsCorporationIdDivisionsHangarHangar {
  /**
   * division integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdDivisionsHangarHangar
   */
  division?: number;
  /**
   * name string
   * @type {string}
   * @memberof GetCorporationsCorporationIdDivisionsHangarHangar
   */
  name?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdDivisionsOk
 */
export interface GetCorporationsCorporationIdDivisionsOk {
  /**
   * hangar array
   * @type {Array<GetCorporationsCorporationIdDivisionsHangarHangar>}
   * @memberof GetCorporationsCorporationIdDivisionsOk
   */
  hangar?: Array<GetCorporationsCorporationIdDivisionsHangarHangar>;
  /**
   * wallet array
   * @type {Array<GetCorporationsCorporationIdDivisionsWalletWallet>}
   * @memberof GetCorporationsCorporationIdDivisionsOk
   */
  wallet?: Array<GetCorporationsCorporationIdDivisionsWalletWallet>;
}
/**
 * wallet object
 * @export
 * @interface GetCorporationsCorporationIdDivisionsWalletWallet
 */
export interface GetCorporationsCorporationIdDivisionsWalletWallet {
  /**
   * division integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdDivisionsWalletWallet
   */
  division?: number;
  /**
   * name string
   * @type {string}
   * @memberof GetCorporationsCorporationIdDivisionsWalletWallet
   */
  name?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdFacilities200Ok
 */
export interface GetCorporationsCorporationIdFacilities200Ok {
  /**
   * facility_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdFacilities200Ok
   */
  facility_id: number;
  /**
   * system_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdFacilities200Ok
   */
  system_id: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdFacilities200Ok
   */
  type_id: number;
}
/**
 * Summary of kills done by the given corporation against enemy factions
 * @export
 * @interface GetCorporationsCorporationIdFwStatsKills
 */
export interface GetCorporationsCorporationIdFwStatsKills {
  /**
   * Last week\'s total number of kills by members of the given corporation against enemy factions
   * @type {number}
   * @memberof GetCorporationsCorporationIdFwStatsKills
   */
  last_week: number;
  /**
   * Total number of kills by members of the given corporation against enemy factions since the corporation enlisted
   * @type {number}
   * @memberof GetCorporationsCorporationIdFwStatsKills
   */
  total: number;
  /**
   * Yesterday\'s total number of kills by members of the given corporation against enemy factions
   * @type {number}
   * @memberof GetCorporationsCorporationIdFwStatsKills
   */
  yesterday: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdFwStatsOk
 */
export interface GetCorporationsCorporationIdFwStatsOk {
  /**
   * The enlistment date of the given corporation into faction warfare. Will not be included if corporation is not enlisted in faction warfare
   * @type {string}
   * @memberof GetCorporationsCorporationIdFwStatsOk
   */
  enlisted_on?: string;
  /**
   * The faction the given corporation is enlisted to fight for. Will not be included if corporation is not enlisted in faction warfare
   * @type {number}
   * @memberof GetCorporationsCorporationIdFwStatsOk
   */
  faction_id?: number;
  /**
   *
   * @type {GetCorporationsCorporationIdFwStatsKills}
   * @memberof GetCorporationsCorporationIdFwStatsOk
   */
  kills: GetCorporationsCorporationIdFwStatsKills;
  /**
   * How many pilots the enlisted corporation has. Will not be included if corporation is not enlisted in faction warfare
   * @type {number}
   * @memberof GetCorporationsCorporationIdFwStatsOk
   */
  pilots?: number;
  /**
   *
   * @type {GetCorporationsCorporationIdFwStatsVictoryPoints}
   * @memberof GetCorporationsCorporationIdFwStatsOk
   */
  victory_points: GetCorporationsCorporationIdFwStatsVictoryPoints;
}
/**
 * Summary of victory points gained by the given corporation for the enlisted faction
 * @export
 * @interface GetCorporationsCorporationIdFwStatsVictoryPoints
 */
export interface GetCorporationsCorporationIdFwStatsVictoryPoints {
  /**
   * Last week\'s victory points gained by members of the given corporation
   * @type {number}
   * @memberof GetCorporationsCorporationIdFwStatsVictoryPoints
   */
  last_week: number;
  /**
   * Total victory points gained since the given corporation enlisted
   * @type {number}
   * @memberof GetCorporationsCorporationIdFwStatsVictoryPoints
   */
  total: number;
  /**
   * Yesterday\'s victory points gained by members of the given corporation
   * @type {number}
   * @memberof GetCorporationsCorporationIdFwStatsVictoryPoints
   */
  yesterday: number;
}
/**
 * No image server for this datasource
 * @export
 * @interface GetCorporationsCorporationIdIconsNotFound
 */
export interface GetCorporationsCorporationIdIconsNotFound {
  /**
   * error message
   * @type {string}
   * @memberof GetCorporationsCorporationIdIconsNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdIconsOk
 */
export interface GetCorporationsCorporationIdIconsOk {
  /**
   * px128x128 string
   * @type {string}
   * @memberof GetCorporationsCorporationIdIconsOk
   */
  px128x128?: string;
  /**
   * px256x256 string
   * @type {string}
   * @memberof GetCorporationsCorporationIdIconsOk
   */
  px256x256?: string;
  /**
   * px64x64 string
   * @type {string}
   * @memberof GetCorporationsCorporationIdIconsOk
   */
  px64x64?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdIndustryJobs200Ok
 */
export interface GetCorporationsCorporationIdIndustryJobs200Ok {
  /**
   * Job activity ID
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  activity_id: number;
  /**
   * blueprint_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  blueprint_id: number;
  /**
   * Location ID of the location from which the blueprint was installed. Normally a station ID, but can also be an asset (e.g. container) or corporation facility
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  blueprint_location_id: number;
  /**
   * blueprint_type_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  blueprint_type_id: number;
  /**
   * ID of the character which completed this job
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  completed_character_id?: number;
  /**
   * Date and time when this job was completed
   * @type {string}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  completed_date?: string;
  /**
   * The sume of job installation fee and industry facility tax
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  cost?: number;
  /**
   * Job duration in seconds
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  duration: number;
  /**
   * Date and time when this job finished
   * @type {string}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  end_date: string;
  /**
   * ID of the facility where this job is running
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  facility_id: number;
  /**
   * ID of the character which installed this job
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  installer_id: number;
  /**
   * Unique job ID
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  job_id: number;
  /**
   * Number of runs blueprint is licensed for
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  licensed_runs?: number;
  /**
   * ID of the location for the industry facility
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  location_id: number;
  /**
   * Location ID of the location to which the output of the job will be delivered. Normally a station ID, but can also be a corporation facility
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  output_location_id: number;
  /**
   * Date and time when this job was paused (i.e. time when the facility where this job was installed went offline)
   * @type {string}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  pause_date?: string;
  /**
   * Chance of success for invention
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  probability?: number;
  /**
   * Type ID of product (manufactured, copied or invented)
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  product_type_id?: number;
  /**
   * Number of runs for a manufacturing job, or number of copies to make for a blueprint copy
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  runs: number;
  /**
   * Date and time when this job started
   * @type {string}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  start_date: string;
  /**
   * status string
   * @type {string}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  status: GetCorporationsCorporationIdIndustryJobs200OkStatusEnum;
  /**
   * Number of successful runs for this job. Equal to runs unless this is an invention job
   * @type {number}
   * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
   */
  successful_runs?: number;
}

export const GetCorporationsCorporationIdIndustryJobs200OkStatusEnum = {
  ACTIVE: "active",
  CANCELLED: "cancelled",
  DELIVERED: "delivered",
  PAUSED: "paused",
  READY: "ready",
  REVERTED: "reverted",
} as const;

export type GetCorporationsCorporationIdIndustryJobs200OkStatusEnum =
  typeof GetCorporationsCorporationIdIndustryJobs200OkStatusEnum[keyof typeof GetCorporationsCorporationIdIndustryJobs200OkStatusEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdKillmailsRecent200Ok
 */
export interface GetCorporationsCorporationIdKillmailsRecent200Ok {
  /**
   * A hash of this killmail
   * @type {string}
   * @memberof GetCorporationsCorporationIdKillmailsRecent200Ok
   */
  killmail_hash: string;
  /**
   * ID of this killmail
   * @type {number}
   * @memberof GetCorporationsCorporationIdKillmailsRecent200Ok
   */
  killmail_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdMedals200Ok
 */
export interface GetCorporationsCorporationIdMedals200Ok {
  /**
   * created_at string
   * @type {string}
   * @memberof GetCorporationsCorporationIdMedals200Ok
   */
  created_at: string;
  /**
   * ID of the character who created this medal
   * @type {number}
   * @memberof GetCorporationsCorporationIdMedals200Ok
   */
  creator_id: number;
  /**
   * description string
   * @type {string}
   * @memberof GetCorporationsCorporationIdMedals200Ok
   */
  description: string;
  /**
   * medal_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdMedals200Ok
   */
  medal_id: number;
  /**
   * title string
   * @type {string}
   * @memberof GetCorporationsCorporationIdMedals200Ok
   */
  title: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdMedalsIssued200Ok
 */
export interface GetCorporationsCorporationIdMedalsIssued200Ok {
  /**
   * ID of the character who was rewarded this medal
   * @type {number}
   * @memberof GetCorporationsCorporationIdMedalsIssued200Ok
   */
  character_id: number;
  /**
   * issued_at string
   * @type {string}
   * @memberof GetCorporationsCorporationIdMedalsIssued200Ok
   */
  issued_at: string;
  /**
   * ID of the character who issued the medal
   * @type {number}
   * @memberof GetCorporationsCorporationIdMedalsIssued200Ok
   */
  issuer_id: number;
  /**
   * medal_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdMedalsIssued200Ok
   */
  medal_id: number;
  /**
   * reason string
   * @type {string}
   * @memberof GetCorporationsCorporationIdMedalsIssued200Ok
   */
  reason: string;
  /**
   * status string
   * @type {string}
   * @memberof GetCorporationsCorporationIdMedalsIssued200Ok
   */
  status: GetCorporationsCorporationIdMedalsIssued200OkStatusEnum;
}

export const GetCorporationsCorporationIdMedalsIssued200OkStatusEnum = {
  PRIVATE: "private",
  PUBLIC: "public",
} as const;

export type GetCorporationsCorporationIdMedalsIssued200OkStatusEnum =
  typeof GetCorporationsCorporationIdMedalsIssued200OkStatusEnum[keyof typeof GetCorporationsCorporationIdMedalsIssued200OkStatusEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdMembersTitles200Ok
 */
export interface GetCorporationsCorporationIdMembersTitles200Ok {
  /**
   * character_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdMembersTitles200Ok
   */
  character_id: number;
  /**
   * A list of title_id
   * @type {Array<number>}
   * @memberof GetCorporationsCorporationIdMembersTitles200Ok
   */
  titles: Array<number>;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdMembertracking200Ok
 */
export interface GetCorporationsCorporationIdMembertracking200Ok {
  /**
   * base_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdMembertracking200Ok
   */
  base_id?: number;
  /**
   * character_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdMembertracking200Ok
   */
  character_id: number;
  /**
   * location_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdMembertracking200Ok
   */
  location_id?: number;
  /**
   * logoff_date string
   * @type {string}
   * @memberof GetCorporationsCorporationIdMembertracking200Ok
   */
  logoff_date?: string;
  /**
   * logon_date string
   * @type {string}
   * @memberof GetCorporationsCorporationIdMembertracking200Ok
   */
  logon_date?: string;
  /**
   * ship_type_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdMembertracking200Ok
   */
  ship_type_id?: number;
  /**
   * start_date string
   * @type {string}
   * @memberof GetCorporationsCorporationIdMembertracking200Ok
   */
  start_date?: string;
}
/**
 * Not found
 * @export
 * @interface GetCorporationsCorporationIdNotFound
 */
export interface GetCorporationsCorporationIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetCorporationsCorporationIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdOk
 */
export interface GetCorporationsCorporationIdOk {
  /**
   * ID of the alliance that corporation is a member of, if any
   * @type {number}
   * @memberof GetCorporationsCorporationIdOk
   */
  alliance_id?: number;
  /**
   * ceo_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdOk
   */
  ceo_id: number;
  /**
   * creator_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdOk
   */
  creator_id: number;
  /**
   * date_founded string
   * @type {string}
   * @memberof GetCorporationsCorporationIdOk
   */
  date_founded?: string;
  /**
   * description string
   * @type {string}
   * @memberof GetCorporationsCorporationIdOk
   */
  description?: string;
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdOk
   */
  faction_id?: number;
  /**
   * home_station_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdOk
   */
  home_station_id?: number;
  /**
   * member_count integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdOk
   */
  member_count: number;
  /**
   * the full name of the corporation
   * @type {string}
   * @memberof GetCorporationsCorporationIdOk
   */
  name: string;
  /**
   * shares integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdOk
   */
  shares?: number;
  /**
   * tax_rate number
   * @type {number}
   * @memberof GetCorporationsCorporationIdOk
   */
  tax_rate: number;
  /**
   * the short name of the corporation
   * @type {string}
   * @memberof GetCorporationsCorporationIdOk
   */
  ticker: string;
  /**
   * url string
   * @type {string}
   * @memberof GetCorporationsCorporationIdOk
   */
  url?: string;
  /**
   * war_eligible boolean
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdOk
   */
  war_eligible?: boolean;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdOrders200Ok
 */
export interface GetCorporationsCorporationIdOrders200Ok {
  /**
   * Number of days for which order is valid (starting from the issued date). An order expires at time issued + duration
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  duration: number;
  /**
   * For buy orders, the amount of ISK in escrow
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  escrow?: number;
  /**
   * True if the order is a bid (buy) order
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  is_buy_order?: boolean;
  /**
   * Date and time when this order was issued
   * @type {string}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  issued: string;
  /**
   * The character who issued this order
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  issued_by: number;
  /**
   * ID of the location where order was placed
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  location_id: number;
  /**
   * For buy orders, the minimum quantity that will be accepted in a matching sell order
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  min_volume?: number;
  /**
   * Unique order ID
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  order_id: number;
  /**
   * Cost per unit for this order
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  price: number;
  /**
   * Valid order range, numbers are ranges in jumps
   * @type {string}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  range: GetCorporationsCorporationIdOrders200OkRangeEnum;
  /**
   * ID of the region where order was placed
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  region_id: number;
  /**
   * The type ID of the item transacted in this order
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  type_id: number;
  /**
   * Quantity of items still required or offered
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  volume_remain: number;
  /**
   * Quantity of items required or offered at time order was placed
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  volume_total: number;
  /**
   * The corporation wallet division used for this order.
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrders200Ok
   */
  wallet_division: number;
}

export const GetCorporationsCorporationIdOrders200OkRangeEnum = {
  _1: "1",
  _10: "10",
  _2: "2",
  _20: "20",
  _3: "3",
  _30: "30",
  _4: "4",
  _40: "40",
  _5: "5",
  REGION: "region",
  SOLARSYSTEM: "solarsystem",
  STATION: "station",
} as const;

export type GetCorporationsCorporationIdOrders200OkRangeEnum =
  typeof GetCorporationsCorporationIdOrders200OkRangeEnum[keyof typeof GetCorporationsCorporationIdOrders200OkRangeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdOrdersHistory200Ok
 */
export interface GetCorporationsCorporationIdOrdersHistory200Ok {
  /**
   * Number of days the order was valid for (starting from the issued date). An order expires at time issued + duration
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  duration: number;
  /**
   * For buy orders, the amount of ISK in escrow
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  escrow?: number;
  /**
   * True if the order is a bid (buy) order
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  is_buy_order?: boolean;
  /**
   * Date and time when this order was issued
   * @type {string}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  issued: string;
  /**
   * The character who issued this order
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  issued_by?: number;
  /**
   * ID of the location where order was placed
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  location_id: number;
  /**
   * For buy orders, the minimum quantity that will be accepted in a matching sell order
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  min_volume?: number;
  /**
   * Unique order ID
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  order_id: number;
  /**
   * Cost per unit for this order
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  price: number;
  /**
   * Valid order range, numbers are ranges in jumps
   * @type {string}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  range: GetCorporationsCorporationIdOrdersHistory200OkRangeEnum;
  /**
   * ID of the region where order was placed
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  region_id: number;
  /**
   * Current order state
   * @type {string}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  state: GetCorporationsCorporationIdOrdersHistory200OkStateEnum;
  /**
   * The type ID of the item transacted in this order
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  type_id: number;
  /**
   * Quantity of items still required or offered
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  volume_remain: number;
  /**
   * Quantity of items required or offered at time order was placed
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  volume_total: number;
  /**
   * The corporation wallet division used for this order
   * @type {number}
   * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
   */
  wallet_division: number;
}

export const GetCorporationsCorporationIdOrdersHistory200OkRangeEnum = {
  _1: "1",
  _10: "10",
  _2: "2",
  _20: "20",
  _3: "3",
  _30: "30",
  _4: "4",
  _40: "40",
  _5: "5",
  REGION: "region",
  SOLARSYSTEM: "solarsystem",
  STATION: "station",
} as const;

export type GetCorporationsCorporationIdOrdersHistory200OkRangeEnum =
  typeof GetCorporationsCorporationIdOrdersHistory200OkRangeEnum[keyof typeof GetCorporationsCorporationIdOrdersHistory200OkRangeEnum];
export const GetCorporationsCorporationIdOrdersHistory200OkStateEnum = {
  CANCELLED: "cancelled",
  EXPIRED: "expired",
} as const;

export type GetCorporationsCorporationIdOrdersHistory200OkStateEnum =
  typeof GetCorporationsCorporationIdOrdersHistory200OkStateEnum[keyof typeof GetCorporationsCorporationIdOrdersHistory200OkStateEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdRoles200Ok
 */
export interface GetCorporationsCorporationIdRoles200Ok {
  /**
   * character_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdRoles200Ok
   */
  character_id: number;
  /**
   * grantable_roles array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdRoles200Ok
   */
  grantable_roles?: Array<GetCorporationsCorporationIdRoles200OkGrantableRolesEnum>;
  /**
   * grantable_roles_at_base array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdRoles200Ok
   */
  grantable_roles_at_base?: Array<GetCorporationsCorporationIdRoles200OkGrantableRolesAtBaseEnum>;
  /**
   * grantable_roles_at_hq array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdRoles200Ok
   */
  grantable_roles_at_hq?: Array<GetCorporationsCorporationIdRoles200OkGrantableRolesAtHqEnum>;
  /**
   * grantable_roles_at_other array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdRoles200Ok
   */
  grantable_roles_at_other?: Array<GetCorporationsCorporationIdRoles200OkGrantableRolesAtOtherEnum>;
  /**
   * roles array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdRoles200Ok
   */
  roles?: Array<GetCorporationsCorporationIdRoles200OkRolesEnum>;
  /**
   * roles_at_base array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdRoles200Ok
   */
  roles_at_base?: Array<GetCorporationsCorporationIdRoles200OkRolesAtBaseEnum>;
  /**
   * roles_at_hq array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdRoles200Ok
   */
  roles_at_hq?: Array<GetCorporationsCorporationIdRoles200OkRolesAtHqEnum>;
  /**
   * roles_at_other array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdRoles200Ok
   */
  roles_at_other?: Array<GetCorporationsCorporationIdRoles200OkRolesAtOtherEnum>;
}

export const GetCorporationsCorporationIdRoles200OkGrantableRolesEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdRoles200OkGrantableRolesEnum =
  typeof GetCorporationsCorporationIdRoles200OkGrantableRolesEnum[keyof typeof GetCorporationsCorporationIdRoles200OkGrantableRolesEnum];
export const GetCorporationsCorporationIdRoles200OkGrantableRolesAtBaseEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdRoles200OkGrantableRolesAtBaseEnum =
  typeof GetCorporationsCorporationIdRoles200OkGrantableRolesAtBaseEnum[keyof typeof GetCorporationsCorporationIdRoles200OkGrantableRolesAtBaseEnum];
export const GetCorporationsCorporationIdRoles200OkGrantableRolesAtHqEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdRoles200OkGrantableRolesAtHqEnum =
  typeof GetCorporationsCorporationIdRoles200OkGrantableRolesAtHqEnum[keyof typeof GetCorporationsCorporationIdRoles200OkGrantableRolesAtHqEnum];
export const GetCorporationsCorporationIdRoles200OkGrantableRolesAtOtherEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdRoles200OkGrantableRolesAtOtherEnum =
  typeof GetCorporationsCorporationIdRoles200OkGrantableRolesAtOtherEnum[keyof typeof GetCorporationsCorporationIdRoles200OkGrantableRolesAtOtherEnum];
export const GetCorporationsCorporationIdRoles200OkRolesEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdRoles200OkRolesEnum =
  typeof GetCorporationsCorporationIdRoles200OkRolesEnum[keyof typeof GetCorporationsCorporationIdRoles200OkRolesEnum];
export const GetCorporationsCorporationIdRoles200OkRolesAtBaseEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdRoles200OkRolesAtBaseEnum =
  typeof GetCorporationsCorporationIdRoles200OkRolesAtBaseEnum[keyof typeof GetCorporationsCorporationIdRoles200OkRolesAtBaseEnum];
export const GetCorporationsCorporationIdRoles200OkRolesAtHqEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdRoles200OkRolesAtHqEnum =
  typeof GetCorporationsCorporationIdRoles200OkRolesAtHqEnum[keyof typeof GetCorporationsCorporationIdRoles200OkRolesAtHqEnum];
export const GetCorporationsCorporationIdRoles200OkRolesAtOtherEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdRoles200OkRolesAtOtherEnum =
  typeof GetCorporationsCorporationIdRoles200OkRolesAtOtherEnum[keyof typeof GetCorporationsCorporationIdRoles200OkRolesAtOtherEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdRolesHistory200Ok
 */
export interface GetCorporationsCorporationIdRolesHistory200Ok {
  /**
   * changed_at string
   * @type {string}
   * @memberof GetCorporationsCorporationIdRolesHistory200Ok
   */
  changed_at: string;
  /**
   * The character whose roles are changed
   * @type {number}
   * @memberof GetCorporationsCorporationIdRolesHistory200Ok
   */
  character_id: number;
  /**
   * ID of the character who issued this change
   * @type {number}
   * @memberof GetCorporationsCorporationIdRolesHistory200Ok
   */
  issuer_id: number;
  /**
   * new_roles array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdRolesHistory200Ok
   */
  new_roles: Array<GetCorporationsCorporationIdRolesHistory200OkNewRolesEnum>;
  /**
   * old_roles array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdRolesHistory200Ok
   */
  old_roles: Array<GetCorporationsCorporationIdRolesHistory200OkOldRolesEnum>;
  /**
   * role_type string
   * @type {string}
   * @memberof GetCorporationsCorporationIdRolesHistory200Ok
   */
  role_type: GetCorporationsCorporationIdRolesHistory200OkRoleTypeEnum;
}

export const GetCorporationsCorporationIdRolesHistory200OkNewRolesEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdRolesHistory200OkNewRolesEnum =
  typeof GetCorporationsCorporationIdRolesHistory200OkNewRolesEnum[keyof typeof GetCorporationsCorporationIdRolesHistory200OkNewRolesEnum];
export const GetCorporationsCorporationIdRolesHistory200OkOldRolesEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdRolesHistory200OkOldRolesEnum =
  typeof GetCorporationsCorporationIdRolesHistory200OkOldRolesEnum[keyof typeof GetCorporationsCorporationIdRolesHistory200OkOldRolesEnum];
export const GetCorporationsCorporationIdRolesHistory200OkRoleTypeEnum = {
  GRANTABLE_ROLES: "grantable_roles",
  GRANTABLE_ROLES_AT_BASE: "grantable_roles_at_base",
  GRANTABLE_ROLES_AT_HQ: "grantable_roles_at_hq",
  GRANTABLE_ROLES_AT_OTHER: "grantable_roles_at_other",
  ROLES: "roles",
  ROLES_AT_BASE: "roles_at_base",
  ROLES_AT_HQ: "roles_at_hq",
  ROLES_AT_OTHER: "roles_at_other",
} as const;

export type GetCorporationsCorporationIdRolesHistory200OkRoleTypeEnum =
  typeof GetCorporationsCorporationIdRolesHistory200OkRoleTypeEnum[keyof typeof GetCorporationsCorporationIdRolesHistory200OkRoleTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdShareholders200Ok
 */
export interface GetCorporationsCorporationIdShareholders200Ok {
  /**
   * share_count integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdShareholders200Ok
   */
  share_count: number;
  /**
   * shareholder_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdShareholders200Ok
   */
  shareholder_id: number;
  /**
   * shareholder_type string
   * @type {string}
   * @memberof GetCorporationsCorporationIdShareholders200Ok
   */
  shareholder_type: GetCorporationsCorporationIdShareholders200OkShareholderTypeEnum;
}

export const GetCorporationsCorporationIdShareholders200OkShareholderTypeEnum =
  {
    CHARACTER: "character",
    CORPORATION: "corporation",
  } as const;

export type GetCorporationsCorporationIdShareholders200OkShareholderTypeEnum =
  typeof GetCorporationsCorporationIdShareholders200OkShareholderTypeEnum[keyof typeof GetCorporationsCorporationIdShareholders200OkShareholderTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdStandings200Ok
 */
export interface GetCorporationsCorporationIdStandings200Ok {
  /**
   * from_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdStandings200Ok
   */
  from_id: number;
  /**
   * from_type string
   * @type {string}
   * @memberof GetCorporationsCorporationIdStandings200Ok
   */
  from_type: GetCorporationsCorporationIdStandings200OkFromTypeEnum;
  /**
   * standing number
   * @type {number}
   * @memberof GetCorporationsCorporationIdStandings200Ok
   */
  standing: number;
}

export const GetCorporationsCorporationIdStandings200OkFromTypeEnum = {
  AGENT: "agent",
  NPC_CORP: "npc_corp",
  FACTION: "faction",
} as const;

export type GetCorporationsCorporationIdStandings200OkFromTypeEnum =
  typeof GetCorporationsCorporationIdStandings200OkFromTypeEnum[keyof typeof GetCorporationsCorporationIdStandings200OkFromTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdStarbases200Ok
 */
export interface GetCorporationsCorporationIdStarbases200Ok {
  /**
   * The moon this starbase (POS) is anchored on, unanchored POSes do not have this information
   * @type {number}
   * @memberof GetCorporationsCorporationIdStarbases200Ok
   */
  moon_id?: number;
  /**
   * When the POS onlined, for starbases (POSes) in online state
   * @type {string}
   * @memberof GetCorporationsCorporationIdStarbases200Ok
   */
  onlined_since?: string;
  /**
   * When the POS will be out of reinforcement, for starbases (POSes) in reinforced state
   * @type {string}
   * @memberof GetCorporationsCorporationIdStarbases200Ok
   */
  reinforced_until?: string;
  /**
   * Unique ID for this starbase (POS)
   * @type {number}
   * @memberof GetCorporationsCorporationIdStarbases200Ok
   */
  starbase_id: number;
  /**
   * state string
   * @type {string}
   * @memberof GetCorporationsCorporationIdStarbases200Ok
   */
  state?: GetCorporationsCorporationIdStarbases200OkStateEnum;
  /**
   * The solar system this starbase (POS) is in, unanchored POSes have this information
   * @type {number}
   * @memberof GetCorporationsCorporationIdStarbases200Ok
   */
  system_id: number;
  /**
   * Starbase (POS) type
   * @type {number}
   * @memberof GetCorporationsCorporationIdStarbases200Ok
   */
  type_id: number;
  /**
   * When the POS started unanchoring, for starbases (POSes) in unanchoring state
   * @type {string}
   * @memberof GetCorporationsCorporationIdStarbases200Ok
   */
  unanchor_at?: string;
}

export const GetCorporationsCorporationIdStarbases200OkStateEnum = {
  OFFLINE: "offline",
  ONLINE: "online",
  ONLINING: "onlining",
  REINFORCED: "reinforced",
  UNANCHORING: "unanchoring",
} as const;

export type GetCorporationsCorporationIdStarbases200OkStateEnum =
  typeof GetCorporationsCorporationIdStarbases200OkStateEnum[keyof typeof GetCorporationsCorporationIdStarbases200OkStateEnum];

/**
 * fuel object
 * @export
 * @interface GetCorporationsCorporationIdStarbasesStarbaseIdFuel
 */
export interface GetCorporationsCorporationIdStarbasesStarbaseIdFuel {
  /**
   * quantity integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdFuel
   */
  quantity: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdFuel
   */
  type_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdStarbasesStarbaseIdOk
 */
export interface GetCorporationsCorporationIdStarbasesStarbaseIdOk {
  /**
   * allow_alliance_members boolean
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  allow_alliance_members: boolean;
  /**
   * allow_corporation_members boolean
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  allow_corporation_members: boolean;
  /**
   * Who can anchor starbase (POS) and its structures
   * @type {string}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  anchor: GetCorporationsCorporationIdStarbasesStarbaseIdOkAnchorEnum;
  /**
   * attack_if_at_war boolean
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  attack_if_at_war: boolean;
  /**
   * attack_if_other_security_status_dropping boolean
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  attack_if_other_security_status_dropping: boolean;
  /**
   * Starbase (POS) will attack if target\'s security standing is lower than this value
   * @type {number}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  attack_security_status_threshold?: number;
  /**
   * Starbase (POS) will attack if target\'s standing is lower than this value
   * @type {number}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  attack_standing_threshold?: number;
  /**
   * Who can take fuel blocks out of the starbase (POS)\'s fuel bay
   * @type {string}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  fuel_bay_take: GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayTakeEnum;
  /**
   * Who can view the starbase (POS)\'s fule bay. Characters either need to have required role or belong to the starbase (POS) owner\'s corporation or alliance, as described by the enum, all other access settings follows the same scheme
   * @type {string}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  fuel_bay_view: GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayViewEnum;
  /**
   * Fuel blocks and other things that will be consumed when operating a starbase (POS)
   * @type {Array<GetCorporationsCorporationIdStarbasesStarbaseIdFuel>}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  fuels?: Array<GetCorporationsCorporationIdStarbasesStarbaseIdFuel>;
  /**
   * Who can offline starbase (POS) and its structures
   * @type {string}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  offline: GetCorporationsCorporationIdStarbasesStarbaseIdOkOfflineEnum;
  /**
   * Who can online starbase (POS) and its structures
   * @type {string}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  online: GetCorporationsCorporationIdStarbasesStarbaseIdOkOnlineEnum;
  /**
   * Who can unanchor starbase (POS) and its structures
   * @type {string}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  unanchor: GetCorporationsCorporationIdStarbasesStarbaseIdOkUnanchorEnum;
  /**
   * True if the starbase (POS) is using alliance standings, otherwise using corporation\'s
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
   */
  use_alliance_standings: boolean;
}

export const GetCorporationsCorporationIdStarbasesStarbaseIdOkAnchorEnum = {
  ALLIANCE_MEMBER: "alliance_member",
  CONFIG_STARBASE_EQUIPMENT_ROLE: "config_starbase_equipment_role",
  CORPORATION_MEMBER: "corporation_member",
  STARBASE_FUEL_TECHNICIAN_ROLE: "starbase_fuel_technician_role",
} as const;

export type GetCorporationsCorporationIdStarbasesStarbaseIdOkAnchorEnum =
  typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkAnchorEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkAnchorEnum];
export const GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayTakeEnum =
  {
    ALLIANCE_MEMBER: "alliance_member",
    CONFIG_STARBASE_EQUIPMENT_ROLE: "config_starbase_equipment_role",
    CORPORATION_MEMBER: "corporation_member",
    STARBASE_FUEL_TECHNICIAN_ROLE: "starbase_fuel_technician_role",
  } as const;

export type GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayTakeEnum =
  typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayTakeEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayTakeEnum];
export const GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayViewEnum =
  {
    ALLIANCE_MEMBER: "alliance_member",
    CONFIG_STARBASE_EQUIPMENT_ROLE: "config_starbase_equipment_role",
    CORPORATION_MEMBER: "corporation_member",
    STARBASE_FUEL_TECHNICIAN_ROLE: "starbase_fuel_technician_role",
  } as const;

export type GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayViewEnum =
  typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayViewEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayViewEnum];
export const GetCorporationsCorporationIdStarbasesStarbaseIdOkOfflineEnum = {
  ALLIANCE_MEMBER: "alliance_member",
  CONFIG_STARBASE_EQUIPMENT_ROLE: "config_starbase_equipment_role",
  CORPORATION_MEMBER: "corporation_member",
  STARBASE_FUEL_TECHNICIAN_ROLE: "starbase_fuel_technician_role",
} as const;

export type GetCorporationsCorporationIdStarbasesStarbaseIdOkOfflineEnum =
  typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkOfflineEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkOfflineEnum];
export const GetCorporationsCorporationIdStarbasesStarbaseIdOkOnlineEnum = {
  ALLIANCE_MEMBER: "alliance_member",
  CONFIG_STARBASE_EQUIPMENT_ROLE: "config_starbase_equipment_role",
  CORPORATION_MEMBER: "corporation_member",
  STARBASE_FUEL_TECHNICIAN_ROLE: "starbase_fuel_technician_role",
} as const;

export type GetCorporationsCorporationIdStarbasesStarbaseIdOkOnlineEnum =
  typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkOnlineEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkOnlineEnum];
export const GetCorporationsCorporationIdStarbasesStarbaseIdOkUnanchorEnum = {
  ALLIANCE_MEMBER: "alliance_member",
  CONFIG_STARBASE_EQUIPMENT_ROLE: "config_starbase_equipment_role",
  CORPORATION_MEMBER: "corporation_member",
  STARBASE_FUEL_TECHNICIAN_ROLE: "starbase_fuel_technician_role",
} as const;

export type GetCorporationsCorporationIdStarbasesStarbaseIdOkUnanchorEnum =
  typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkUnanchorEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkUnanchorEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdStructures200Ok
 */
export interface GetCorporationsCorporationIdStructures200Ok {
  /**
   * ID of the corporation that owns the structure
   * @type {number}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  corporation_id: number;
  /**
   * Date on which the structure will run out of fuel
   * @type {string}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  fuel_expires?: string;
  /**
   * The structure name
   * @type {string}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  name?: string;
  /**
   * The date and time when the structure\'s newly requested reinforcement times (e.g. next_reinforce_hour and next_reinforce_day) will take effect
   * @type {string}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  next_reinforce_apply?: string;
  /**
   * The requested change to reinforce_hour that will take effect at the time shown by next_reinforce_apply
   * @type {number}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  next_reinforce_hour?: number;
  /**
   * The id of the ACL profile for this citadel
   * @type {number}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  profile_id: number;
  /**
   * The hour of day that determines the four hour window when the structure will randomly exit its reinforcement periods and become vulnerable to attack against its armor and/or hull. The structure will become vulnerable at a random time that is +/- 2 hours centered on the value of this property
   * @type {number}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  reinforce_hour?: number;
  /**
   * Contains a list of service upgrades, and their state
   * @type {Array<GetCorporationsCorporationIdStructuresService>}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  services?: Array<GetCorporationsCorporationIdStructuresService>;
  /**
   * state string
   * @type {string}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  state: GetCorporationsCorporationIdStructures200OkStateEnum;
  /**
   * Date at which the structure will move to it\'s next state
   * @type {string}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  state_timer_end?: string;
  /**
   * Date at which the structure entered it\'s current state
   * @type {string}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  state_timer_start?: string;
  /**
   * The Item ID of the structure
   * @type {number}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  structure_id: number;
  /**
   * The solar system the structure is in
   * @type {number}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  system_id: number;
  /**
   * The type id of the structure
   * @type {number}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  type_id: number;
  /**
   * Date at which the structure will unanchor
   * @type {string}
   * @memberof GetCorporationsCorporationIdStructures200Ok
   */
  unanchors_at?: string;
}

export const GetCorporationsCorporationIdStructures200OkStateEnum = {
  ANCHOR_VULNERABLE: "anchor_vulnerable",
  ANCHORING: "anchoring",
  ARMOR_REINFORCE: "armor_reinforce",
  ARMOR_VULNERABLE: "armor_vulnerable",
  DEPLOY_VULNERABLE: "deploy_vulnerable",
  FITTING_INVULNERABLE: "fitting_invulnerable",
  HULL_REINFORCE: "hull_reinforce",
  HULL_VULNERABLE: "hull_vulnerable",
  ONLINE_DEPRECATED: "online_deprecated",
  ONLINING_VULNERABLE: "onlining_vulnerable",
  SHIELD_VULNERABLE: "shield_vulnerable",
  UNANCHORED: "unanchored",
  UNKNOWN: "unknown",
} as const;

export type GetCorporationsCorporationIdStructures200OkStateEnum =
  typeof GetCorporationsCorporationIdStructures200OkStateEnum[keyof typeof GetCorporationsCorporationIdStructures200OkStateEnum];

/**
 * service object
 * @export
 * @interface GetCorporationsCorporationIdStructuresService
 */
export interface GetCorporationsCorporationIdStructuresService {
  /**
   * name string
   * @type {string}
   * @memberof GetCorporationsCorporationIdStructuresService
   */
  name: string;
  /**
   * state string
   * @type {string}
   * @memberof GetCorporationsCorporationIdStructuresService
   */
  state: GetCorporationsCorporationIdStructuresServiceStateEnum;
}

export const GetCorporationsCorporationIdStructuresServiceStateEnum = {
  ONLINE: "online",
  OFFLINE: "offline",
  CLEANUP: "cleanup",
} as const;

export type GetCorporationsCorporationIdStructuresServiceStateEnum =
  typeof GetCorporationsCorporationIdStructuresServiceStateEnum[keyof typeof GetCorporationsCorporationIdStructuresServiceStateEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdTitles200Ok
 */
export interface GetCorporationsCorporationIdTitles200Ok {
  /**
   * grantable_roles array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdTitles200Ok
   */
  grantable_roles?: Array<GetCorporationsCorporationIdTitles200OkGrantableRolesEnum>;
  /**
   * grantable_roles_at_base array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdTitles200Ok
   */
  grantable_roles_at_base?: Array<GetCorporationsCorporationIdTitles200OkGrantableRolesAtBaseEnum>;
  /**
   * grantable_roles_at_hq array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdTitles200Ok
   */
  grantable_roles_at_hq?: Array<GetCorporationsCorporationIdTitles200OkGrantableRolesAtHqEnum>;
  /**
   * grantable_roles_at_other array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdTitles200Ok
   */
  grantable_roles_at_other?: Array<GetCorporationsCorporationIdTitles200OkGrantableRolesAtOtherEnum>;
  /**
   * name string
   * @type {string}
   * @memberof GetCorporationsCorporationIdTitles200Ok
   */
  name?: string;
  /**
   * roles array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdTitles200Ok
   */
  roles?: Array<GetCorporationsCorporationIdTitles200OkRolesEnum>;
  /**
   * roles_at_base array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdTitles200Ok
   */
  roles_at_base?: Array<GetCorporationsCorporationIdTitles200OkRolesAtBaseEnum>;
  /**
   * roles_at_hq array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdTitles200Ok
   */
  roles_at_hq?: Array<GetCorporationsCorporationIdTitles200OkRolesAtHqEnum>;
  /**
   * roles_at_other array
   * @type {Array<string>}
   * @memberof GetCorporationsCorporationIdTitles200Ok
   */
  roles_at_other?: Array<GetCorporationsCorporationIdTitles200OkRolesAtOtherEnum>;
  /**
   * title_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdTitles200Ok
   */
  title_id?: number;
}

export const GetCorporationsCorporationIdTitles200OkGrantableRolesEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdTitles200OkGrantableRolesEnum =
  typeof GetCorporationsCorporationIdTitles200OkGrantableRolesEnum[keyof typeof GetCorporationsCorporationIdTitles200OkGrantableRolesEnum];
export const GetCorporationsCorporationIdTitles200OkGrantableRolesAtBaseEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdTitles200OkGrantableRolesAtBaseEnum =
  typeof GetCorporationsCorporationIdTitles200OkGrantableRolesAtBaseEnum[keyof typeof GetCorporationsCorporationIdTitles200OkGrantableRolesAtBaseEnum];
export const GetCorporationsCorporationIdTitles200OkGrantableRolesAtHqEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdTitles200OkGrantableRolesAtHqEnum =
  typeof GetCorporationsCorporationIdTitles200OkGrantableRolesAtHqEnum[keyof typeof GetCorporationsCorporationIdTitles200OkGrantableRolesAtHqEnum];
export const GetCorporationsCorporationIdTitles200OkGrantableRolesAtOtherEnum =
  {
    ACCOUNT_TAKE_1: "Account_Take_1",
    ACCOUNT_TAKE_2: "Account_Take_2",
    ACCOUNT_TAKE_3: "Account_Take_3",
    ACCOUNT_TAKE_4: "Account_Take_4",
    ACCOUNT_TAKE_5: "Account_Take_5",
    ACCOUNT_TAKE_6: "Account_Take_6",
    ACCOUNT_TAKE_7: "Account_Take_7",
    ACCOUNTANT: "Accountant",
    AUDITOR: "Auditor",
    COMMUNICATIONS_OFFICER: "Communications_Officer",
    CONFIG_EQUIPMENT: "Config_Equipment",
    CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
    CONTAINER_TAKE_1: "Container_Take_1",
    CONTAINER_TAKE_2: "Container_Take_2",
    CONTAINER_TAKE_3: "Container_Take_3",
    CONTAINER_TAKE_4: "Container_Take_4",
    CONTAINER_TAKE_5: "Container_Take_5",
    CONTAINER_TAKE_6: "Container_Take_6",
    CONTAINER_TAKE_7: "Container_Take_7",
    CONTRACT_MANAGER: "Contract_Manager",
    DIPLOMAT: "Diplomat",
    DIRECTOR: "Director",
    FACTORY_MANAGER: "Factory_Manager",
    FITTING_MANAGER: "Fitting_Manager",
    HANGAR_QUERY_1: "Hangar_Query_1",
    HANGAR_QUERY_2: "Hangar_Query_2",
    HANGAR_QUERY_3: "Hangar_Query_3",
    HANGAR_QUERY_4: "Hangar_Query_4",
    HANGAR_QUERY_5: "Hangar_Query_5",
    HANGAR_QUERY_6: "Hangar_Query_6",
    HANGAR_QUERY_7: "Hangar_Query_7",
    HANGAR_TAKE_1: "Hangar_Take_1",
    HANGAR_TAKE_2: "Hangar_Take_2",
    HANGAR_TAKE_3: "Hangar_Take_3",
    HANGAR_TAKE_4: "Hangar_Take_4",
    HANGAR_TAKE_5: "Hangar_Take_5",
    HANGAR_TAKE_6: "Hangar_Take_6",
    HANGAR_TAKE_7: "Hangar_Take_7",
    JUNIOR_ACCOUNTANT: "Junior_Accountant",
    PERSONNEL_MANAGER: "Personnel_Manager",
    RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
    RENT_OFFICE: "Rent_Office",
    RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
    SECURITY_OFFICER: "Security_Officer",
    STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
    STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
    STATION_MANAGER: "Station_Manager",
    TRADER: "Trader",
  } as const;

export type GetCorporationsCorporationIdTitles200OkGrantableRolesAtOtherEnum =
  typeof GetCorporationsCorporationIdTitles200OkGrantableRolesAtOtherEnum[keyof typeof GetCorporationsCorporationIdTitles200OkGrantableRolesAtOtherEnum];
export const GetCorporationsCorporationIdTitles200OkRolesEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdTitles200OkRolesEnum =
  typeof GetCorporationsCorporationIdTitles200OkRolesEnum[keyof typeof GetCorporationsCorporationIdTitles200OkRolesEnum];
export const GetCorporationsCorporationIdTitles200OkRolesAtBaseEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdTitles200OkRolesAtBaseEnum =
  typeof GetCorporationsCorporationIdTitles200OkRolesAtBaseEnum[keyof typeof GetCorporationsCorporationIdTitles200OkRolesAtBaseEnum];
export const GetCorporationsCorporationIdTitles200OkRolesAtHqEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdTitles200OkRolesAtHqEnum =
  typeof GetCorporationsCorporationIdTitles200OkRolesAtHqEnum[keyof typeof GetCorporationsCorporationIdTitles200OkRolesAtHqEnum];
export const GetCorporationsCorporationIdTitles200OkRolesAtOtherEnum = {
  ACCOUNT_TAKE_1: "Account_Take_1",
  ACCOUNT_TAKE_2: "Account_Take_2",
  ACCOUNT_TAKE_3: "Account_Take_3",
  ACCOUNT_TAKE_4: "Account_Take_4",
  ACCOUNT_TAKE_5: "Account_Take_5",
  ACCOUNT_TAKE_6: "Account_Take_6",
  ACCOUNT_TAKE_7: "Account_Take_7",
  ACCOUNTANT: "Accountant",
  AUDITOR: "Auditor",
  COMMUNICATIONS_OFFICER: "Communications_Officer",
  CONFIG_EQUIPMENT: "Config_Equipment",
  CONFIG_STARBASE_EQUIPMENT: "Config_Starbase_Equipment",
  CONTAINER_TAKE_1: "Container_Take_1",
  CONTAINER_TAKE_2: "Container_Take_2",
  CONTAINER_TAKE_3: "Container_Take_3",
  CONTAINER_TAKE_4: "Container_Take_4",
  CONTAINER_TAKE_5: "Container_Take_5",
  CONTAINER_TAKE_6: "Container_Take_6",
  CONTAINER_TAKE_7: "Container_Take_7",
  CONTRACT_MANAGER: "Contract_Manager",
  DIPLOMAT: "Diplomat",
  DIRECTOR: "Director",
  FACTORY_MANAGER: "Factory_Manager",
  FITTING_MANAGER: "Fitting_Manager",
  HANGAR_QUERY_1: "Hangar_Query_1",
  HANGAR_QUERY_2: "Hangar_Query_2",
  HANGAR_QUERY_3: "Hangar_Query_3",
  HANGAR_QUERY_4: "Hangar_Query_4",
  HANGAR_QUERY_5: "Hangar_Query_5",
  HANGAR_QUERY_6: "Hangar_Query_6",
  HANGAR_QUERY_7: "Hangar_Query_7",
  HANGAR_TAKE_1: "Hangar_Take_1",
  HANGAR_TAKE_2: "Hangar_Take_2",
  HANGAR_TAKE_3: "Hangar_Take_3",
  HANGAR_TAKE_4: "Hangar_Take_4",
  HANGAR_TAKE_5: "Hangar_Take_5",
  HANGAR_TAKE_6: "Hangar_Take_6",
  HANGAR_TAKE_7: "Hangar_Take_7",
  JUNIOR_ACCOUNTANT: "Junior_Accountant",
  PERSONNEL_MANAGER: "Personnel_Manager",
  RENT_FACTORY_FACILITY: "Rent_Factory_Facility",
  RENT_OFFICE: "Rent_Office",
  RENT_RESEARCH_FACILITY: "Rent_Research_Facility",
  SECURITY_OFFICER: "Security_Officer",
  STARBASE_DEFENSE_OPERATOR: "Starbase_Defense_Operator",
  STARBASE_FUEL_TECHNICIAN: "Starbase_Fuel_Technician",
  STATION_MANAGER: "Station_Manager",
  TRADER: "Trader",
} as const;

export type GetCorporationsCorporationIdTitles200OkRolesAtOtherEnum =
  typeof GetCorporationsCorporationIdTitles200OkRolesAtOtherEnum[keyof typeof GetCorporationsCorporationIdTitles200OkRolesAtOtherEnum];

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdWallets200Ok
 */
export interface GetCorporationsCorporationIdWallets200Ok {
  /**
   * balance number
   * @type {number}
   * @memberof GetCorporationsCorporationIdWallets200Ok
   */
  balance: number;
  /**
   * division integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdWallets200Ok
   */
  division: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdWalletsDivisionJournal200Ok
 */
export interface GetCorporationsCorporationIdWalletsDivisionJournal200Ok {
  /**
   * The amount of ISK given or taken from the wallet as a result of the given transaction. Positive when ISK is deposited into the wallet and negative when ISK is withdrawn
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  amount?: number;
  /**
   * Wallet balance after transaction occurred
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  balance?: number;
  /**
   * An ID that gives extra context to the particular transaction. Because of legacy reasons the context is completely different per ref_type and means different things. It is also possible to not have a context_id
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  context_id?: number;
  /**
   * The type of the given context_id if present
   * @type {string}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  context_id_type?: GetCorporationsCorporationIdWalletsDivisionJournal200OkContextIdTypeEnum;
  /**
   * Date and time of transaction
   * @type {string}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  date: string;
  /**
   * The reason for the transaction, mirrors what is seen in the client
   * @type {string}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  description: string;
  /**
   * The id of the first party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  first_party_id?: number;
  /**
   * Unique journal reference ID
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  id: number;
  /**
   * The user stated reason for the transaction. Only applies to some ref_types
   * @type {string}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  reason?: string;
  /**
   * \"The transaction type for the given. transaction. Different transaction types will populate different attributes. Note: If you have an existing XML API application that is using ref_types, you will need to know which string ESI ref_type maps to which integer. You can look at the following file to see string->int mappings: https://github.com/ccpgames/eve-glue/blob/master/eve_glue/wallet_journal_ref.py\"
   * @type {string}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  ref_type: GetCorporationsCorporationIdWalletsDivisionJournal200OkRefTypeEnum;
  /**
   * The id of the second party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  second_party_id?: number;
  /**
   * Tax amount received. Only applies to tax related transactions
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  tax?: number;
  /**
   * The corporation ID receiving any tax paid. Only applies to tax related transactions
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
   */
  tax_receiver_id?: number;
}

export const GetCorporationsCorporationIdWalletsDivisionJournal200OkContextIdTypeEnum =
  {
    STRUCTURE_ID: "structure_id",
    STATION_ID: "station_id",
    MARKET_TRANSACTION_ID: "market_transaction_id",
    CHARACTER_ID: "character_id",
    CORPORATION_ID: "corporation_id",
    ALLIANCE_ID: "alliance_id",
    EVE_SYSTEM: "eve_system",
    INDUSTRY_JOB_ID: "industry_job_id",
    CONTRACT_ID: "contract_id",
    PLANET_ID: "planet_id",
    SYSTEM_ID: "system_id",
    TYPE_ID: "type_id",
  } as const;

export type GetCorporationsCorporationIdWalletsDivisionJournal200OkContextIdTypeEnum =
  typeof GetCorporationsCorporationIdWalletsDivisionJournal200OkContextIdTypeEnum[keyof typeof GetCorporationsCorporationIdWalletsDivisionJournal200OkContextIdTypeEnum];
export const GetCorporationsCorporationIdWalletsDivisionJournal200OkRefTypeEnum =
  {
    ACCELERATION_GATE_FEE: "acceleration_gate_fee",
    ADVERTISEMENT_LISTING_FEE: "advertisement_listing_fee",
    AGENT_DONATION: "agent_donation",
    AGENT_LOCATION_SERVICES: "agent_location_services",
    AGENT_MISCELLANEOUS: "agent_miscellaneous",
    AGENT_MISSION_COLLATERAL_PAID: "agent_mission_collateral_paid",
    AGENT_MISSION_COLLATERAL_REFUNDED: "agent_mission_collateral_refunded",
    AGENT_MISSION_REWARD: "agent_mission_reward",
    AGENT_MISSION_REWARD_CORPORATION_TAX:
      "agent_mission_reward_corporation_tax",
    AGENT_MISSION_TIME_BONUS_REWARD: "agent_mission_time_bonus_reward",
    AGENT_MISSION_TIME_BONUS_REWARD_CORPORATION_TAX:
      "agent_mission_time_bonus_reward_corporation_tax",
    AGENT_SECURITY_SERVICES: "agent_security_services",
    AGENT_SERVICES_RENDERED: "agent_services_rendered",
    AGENTS_PREWARD: "agents_preward",
    ALLIANCE_MAINTAINANCE_FEE: "alliance_maintainance_fee",
    ALLIANCE_REGISTRATION_FEE: "alliance_registration_fee",
    ASSET_SAFETY_RECOVERY_TAX: "asset_safety_recovery_tax",
    BOUNTY: "bounty",
    BOUNTY_PRIZE: "bounty_prize",
    BOUNTY_PRIZE_CORPORATION_TAX: "bounty_prize_corporation_tax",
    BOUNTY_PRIZES: "bounty_prizes",
    BOUNTY_REIMBURSEMENT: "bounty_reimbursement",
    BOUNTY_SURCHARGE: "bounty_surcharge",
    BROKERS_FEE: "brokers_fee",
    CLONE_ACTIVATION: "clone_activation",
    CLONE_TRANSFER: "clone_transfer",
    CONTRABAND_FINE: "contraband_fine",
    CONTRACT_AUCTION_BID: "contract_auction_bid",
    CONTRACT_AUCTION_BID_CORP: "contract_auction_bid_corp",
    CONTRACT_AUCTION_BID_REFUND: "contract_auction_bid_refund",
    CONTRACT_AUCTION_SOLD: "contract_auction_sold",
    CONTRACT_BROKERS_FEE: "contract_brokers_fee",
    CONTRACT_BROKERS_FEE_CORP: "contract_brokers_fee_corp",
    CONTRACT_COLLATERAL: "contract_collateral",
    CONTRACT_COLLATERAL_DEPOSITED_CORP: "contract_collateral_deposited_corp",
    CONTRACT_COLLATERAL_PAYOUT: "contract_collateral_payout",
    CONTRACT_COLLATERAL_REFUND: "contract_collateral_refund",
    CONTRACT_DEPOSIT: "contract_deposit",
    CONTRACT_DEPOSIT_CORP: "contract_deposit_corp",
    CONTRACT_DEPOSIT_REFUND: "contract_deposit_refund",
    CONTRACT_DEPOSIT_SALES_TAX: "contract_deposit_sales_tax",
    CONTRACT_PRICE: "contract_price",
    CONTRACT_PRICE_PAYMENT_CORP: "contract_price_payment_corp",
    CONTRACT_REVERSAL: "contract_reversal",
    CONTRACT_REWARD: "contract_reward",
    CONTRACT_REWARD_DEPOSITED: "contract_reward_deposited",
    CONTRACT_REWARD_DEPOSITED_CORP: "contract_reward_deposited_corp",
    CONTRACT_REWARD_REFUND: "contract_reward_refund",
    CONTRACT_SALES_TAX: "contract_sales_tax",
    COPYING: "copying",
    CORPORATE_REWARD_PAYOUT: "corporate_reward_payout",
    CORPORATE_REWARD_TAX: "corporate_reward_tax",
    CORPORATION_ACCOUNT_WITHDRAWAL: "corporation_account_withdrawal",
    CORPORATION_BULK_PAYMENT: "corporation_bulk_payment",
    CORPORATION_DIVIDEND_PAYMENT: "corporation_dividend_payment",
    CORPORATION_LIQUIDATION: "corporation_liquidation",
    CORPORATION_LOGO_CHANGE_COST: "corporation_logo_change_cost",
    CORPORATION_PAYMENT: "corporation_payment",
    CORPORATION_REGISTRATION_FEE: "corporation_registration_fee",
    COURIER_MISSION_ESCROW: "courier_mission_escrow",
    CSPA: "cspa",
    CSPAOFFLINEREFUND: "cspaofflinerefund",
    DAILY_CHALLENGE_REWARD: "daily_challenge_reward",
    DATACORE_FEE: "datacore_fee",
    DNA_MODIFICATION_FEE: "dna_modification_fee",
    DOCKING_FEE: "docking_fee",
    DUEL_WAGER_ESCROW: "duel_wager_escrow",
    DUEL_WAGER_PAYMENT: "duel_wager_payment",
    DUEL_WAGER_REFUND: "duel_wager_refund",
    ESS_ESCROW_TRANSFER: "ess_escrow_transfer",
    EXTERNAL_TRADE_DELIVERY: "external_trade_delivery",
    EXTERNAL_TRADE_FREEZE: "external_trade_freeze",
    EXTERNAL_TRADE_THAW: "external_trade_thaw",
    FACTORY_SLOT_RENTAL_FEE: "factory_slot_rental_fee",
    FLUX_PAYOUT: "flux_payout",
    FLUX_TAX: "flux_tax",
    FLUX_TICKET_REPAYMENT: "flux_ticket_repayment",
    FLUX_TICKET_SALE: "flux_ticket_sale",
    GM_CASH_TRANSFER: "gm_cash_transfer",
    INDUSTRY_JOB_TAX: "industry_job_tax",
    INFRASTRUCTURE_HUB_MAINTENANCE: "infrastructure_hub_maintenance",
    INHERITANCE: "inheritance",
    INSURANCE: "insurance",
    ITEM_TRADER_PAYMENT: "item_trader_payment",
    JUMP_CLONE_ACTIVATION_FEE: "jump_clone_activation_fee",
    JUMP_CLONE_INSTALLATION_FEE: "jump_clone_installation_fee",
    KILL_RIGHT_FEE: "kill_right_fee",
    LP_STORE: "lp_store",
    MANUFACTURING: "manufacturing",
    MARKET_ESCROW: "market_escrow",
    MARKET_FINE_PAID: "market_fine_paid",
    MARKET_PROVIDER_TAX: "market_provider_tax",
    MARKET_TRANSACTION: "market_transaction",
    MEDAL_CREATION: "medal_creation",
    MEDAL_ISSUED: "medal_issued",
    MILESTONE_REWARD_PAYMENT: "milestone_reward_payment",
    MISSION_COMPLETION: "mission_completion",
    MISSION_COST: "mission_cost",
    MISSION_EXPIRATION: "mission_expiration",
    MISSION_REWARD: "mission_reward",
    OFFICE_RENTAL_FEE: "office_rental_fee",
    OPERATION_BONUS: "operation_bonus",
    OPPORTUNITY_REWARD: "opportunity_reward",
    PLANETARY_CONSTRUCTION: "planetary_construction",
    PLANETARY_EXPORT_TAX: "planetary_export_tax",
    PLANETARY_IMPORT_TAX: "planetary_import_tax",
    PLAYER_DONATION: "player_donation",
    PLAYER_TRADING: "player_trading",
    PROJECT_DISCOVERY_REWARD: "project_discovery_reward",
    PROJECT_DISCOVERY_TAX: "project_discovery_tax",
    REACTION: "reaction",
    REDEEMED_ISK_TOKEN: "redeemed_isk_token",
    RELEASE_OF_IMPOUNDED_PROPERTY: "release_of_impounded_property",
    REPAIR_BILL: "repair_bill",
    REPROCESSING_TAX: "reprocessing_tax",
    RESEARCHING_MATERIAL_PRODUCTIVITY: "researching_material_productivity",
    RESEARCHING_TECHNOLOGY: "researching_technology",
    RESEARCHING_TIME_PRODUCTIVITY: "researching_time_productivity",
    RESOURCE_WARS_REWARD: "resource_wars_reward",
    REVERSE_ENGINEERING: "reverse_engineering",
    SEASON_CHALLENGE_REWARD: "season_challenge_reward",
    SECURITY_PROCESSING_FEE: "security_processing_fee",
    SHARES: "shares",
    SKILL_PURCHASE: "skill_purchase",
    SOVEREIGNITY_BILL: "sovereignity_bill",
    STORE_PURCHASE: "store_purchase",
    STORE_PURCHASE_REFUND: "store_purchase_refund",
    STRUCTURE_GATE_JUMP: "structure_gate_jump",
    TRANSACTION_TAX: "transaction_tax",
    UPKEEP_ADJUSTMENT_FEE: "upkeep_adjustment_fee",
    WAR_ALLY_CONTRACT: "war_ally_contract",
    WAR_FEE: "war_fee",
    WAR_FEE_SURRENDER: "war_fee_surrender",
  } as const;

export type GetCorporationsCorporationIdWalletsDivisionJournal200OkRefTypeEnum =
  typeof GetCorporationsCorporationIdWalletsDivisionJournal200OkRefTypeEnum[keyof typeof GetCorporationsCorporationIdWalletsDivisionJournal200OkRefTypeEnum];

/**
 * wallet transaction
 * @export
 * @interface GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
 */
export interface GetCorporationsCorporationIdWalletsDivisionTransactions200Ok {
  /**
   * client_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
   */
  client_id: number;
  /**
   * Date and time of transaction
   * @type {string}
   * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
   */
  date: string;
  /**
   * is_buy boolean
   * @type {boolean}
   * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
   */
  is_buy: boolean;
  /**
   * -1 if there is no corresponding wallet journal entry
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
   */
  journal_ref_id: number;
  /**
   * location_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
   */
  location_id: number;
  /**
   * quantity integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
   */
  quantity: number;
  /**
   * Unique transaction ID
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
   */
  transaction_id: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
   */
  type_id: number;
  /**
   * Amount paid per unit
   * @type {number}
   * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
   */
  unit_price: number;
}
/**
 * Not found
 * @export
 * @interface GetDogmaAttributesAttributeIdNotFound
 */
export interface GetDogmaAttributesAttributeIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetDogmaAttributesAttributeIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetDogmaAttributesAttributeIdOk
 */
export interface GetDogmaAttributesAttributeIdOk {
  /**
   * attribute_id integer
   * @type {number}
   * @memberof GetDogmaAttributesAttributeIdOk
   */
  attribute_id: number;
  /**
   * default_value number
   * @type {number}
   * @memberof GetDogmaAttributesAttributeIdOk
   */
  default_value?: number;
  /**
   * description string
   * @type {string}
   * @memberof GetDogmaAttributesAttributeIdOk
   */
  description?: string;
  /**
   * display_name string
   * @type {string}
   * @memberof GetDogmaAttributesAttributeIdOk
   */
  display_name?: string;
  /**
   * high_is_good boolean
   * @type {boolean}
   * @memberof GetDogmaAttributesAttributeIdOk
   */
  high_is_good?: boolean;
  /**
   * icon_id integer
   * @type {number}
   * @memberof GetDogmaAttributesAttributeIdOk
   */
  icon_id?: number;
  /**
   * name string
   * @type {string}
   * @memberof GetDogmaAttributesAttributeIdOk
   */
  name?: string;
  /**
   * published boolean
   * @type {boolean}
   * @memberof GetDogmaAttributesAttributeIdOk
   */
  published?: boolean;
  /**
   * stackable boolean
   * @type {boolean}
   * @memberof GetDogmaAttributesAttributeIdOk
   */
  stackable?: boolean;
  /**
   * unit_id integer
   * @type {number}
   * @memberof GetDogmaAttributesAttributeIdOk
   */
  unit_id?: number;
}
/**
 * dogma_attribute object
 * @export
 * @interface GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute
 */
export interface GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute {
  /**
   * attribute_id integer
   * @type {number}
   * @memberof GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute
   */
  attribute_id: number;
  /**
   * value number
   * @type {number}
   * @memberof GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute
   */
  value: number;
}
/**
 * dogma_effect object
 * @export
 * @interface GetDogmaDynamicItemsTypeIdItemIdDogmaEffect
 */
export interface GetDogmaDynamicItemsTypeIdItemIdDogmaEffect {
  /**
   * effect_id integer
   * @type {number}
   * @memberof GetDogmaDynamicItemsTypeIdItemIdDogmaEffect
   */
  effect_id: number;
  /**
   * is_default boolean
   * @type {boolean}
   * @memberof GetDogmaDynamicItemsTypeIdItemIdDogmaEffect
   */
  is_default: boolean;
}
/**
 * Not found
 * @export
 * @interface GetDogmaDynamicItemsTypeIdItemIdNotFound
 */
export interface GetDogmaDynamicItemsTypeIdItemIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetDogmaDynamicItemsTypeIdItemIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetDogmaDynamicItemsTypeIdItemIdOk
 */
export interface GetDogmaDynamicItemsTypeIdItemIdOk {
  /**
   * The ID of the character who created the item
   * @type {number}
   * @memberof GetDogmaDynamicItemsTypeIdItemIdOk
   */
  created_by: number;
  /**
   * dogma_attributes array
   * @type {Array<GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute>}
   * @memberof GetDogmaDynamicItemsTypeIdItemIdOk
   */
  dogma_attributes: Array<GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute>;
  /**
   * dogma_effects array
   * @type {Array<GetDogmaDynamicItemsTypeIdItemIdDogmaEffect>}
   * @memberof GetDogmaDynamicItemsTypeIdItemIdOk
   */
  dogma_effects: Array<GetDogmaDynamicItemsTypeIdItemIdDogmaEffect>;
  /**
   * The type ID of the mutator used to generate the dynamic item.
   * @type {number}
   * @memberof GetDogmaDynamicItemsTypeIdItemIdOk
   */
  mutator_type_id: number;
  /**
   * The type ID of the source item the mutator was applied to create the dynamic item.
   * @type {number}
   * @memberof GetDogmaDynamicItemsTypeIdItemIdOk
   */
  source_type_id: number;
}
/**
 * modifier object
 * @export
 * @interface GetDogmaEffectsEffectIdModifier
 */
export interface GetDogmaEffectsEffectIdModifier {
  /**
   * domain string
   * @type {string}
   * @memberof GetDogmaEffectsEffectIdModifier
   */
  domain?: string;
  /**
   * effect_id integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdModifier
   */
  effect_id?: number;
  /**
   * func string
   * @type {string}
   * @memberof GetDogmaEffectsEffectIdModifier
   */
  func: string;
  /**
   * modified_attribute_id integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdModifier
   */
  modified_attribute_id?: number;
  /**
   * modifying_attribute_id integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdModifier
   */
  modifying_attribute_id?: number;
  /**
   * operator integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdModifier
   */
  operator?: number;
}
/**
 * Not found
 * @export
 * @interface GetDogmaEffectsEffectIdNotFound
 */
export interface GetDogmaEffectsEffectIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetDogmaEffectsEffectIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetDogmaEffectsEffectIdOk
 */
export interface GetDogmaEffectsEffectIdOk {
  /**
   * description string
   * @type {string}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  description?: string;
  /**
   * disallow_auto_repeat boolean
   * @type {boolean}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  disallow_auto_repeat?: boolean;
  /**
   * discharge_attribute_id integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  discharge_attribute_id?: number;
  /**
   * display_name string
   * @type {string}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  display_name?: string;
  /**
   * duration_attribute_id integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  duration_attribute_id?: number;
  /**
   * effect_category integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  effect_category?: number;
  /**
   * effect_id integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  effect_id: number;
  /**
   * electronic_chance boolean
   * @type {boolean}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  electronic_chance?: boolean;
  /**
   * falloff_attribute_id integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  falloff_attribute_id?: number;
  /**
   * icon_id integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  icon_id?: number;
  /**
   * is_assistance boolean
   * @type {boolean}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  is_assistance?: boolean;
  /**
   * is_offensive boolean
   * @type {boolean}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  is_offensive?: boolean;
  /**
   * is_warp_safe boolean
   * @type {boolean}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  is_warp_safe?: boolean;
  /**
   * modifiers array
   * @type {Array<GetDogmaEffectsEffectIdModifier>}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  modifiers?: Array<GetDogmaEffectsEffectIdModifier>;
  /**
   * name string
   * @type {string}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  name?: string;
  /**
   * post_expression integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  post_expression?: number;
  /**
   * pre_expression integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  pre_expression?: number;
  /**
   * published boolean
   * @type {boolean}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  published?: boolean;
  /**
   * range_attribute_id integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  range_attribute_id?: number;
  /**
   * range_chance boolean
   * @type {boolean}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  range_chance?: boolean;
  /**
   * tracking_speed_attribute_id integer
   * @type {number}
   * @memberof GetDogmaEffectsEffectIdOk
   */
  tracking_speed_attribute_id?: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetFleetsFleetIdMembers200Ok
 */
export interface GetFleetsFleetIdMembers200Ok {
  /**
   * character_id integer
   * @type {number}
   * @memberof GetFleetsFleetIdMembers200Ok
   */
  character_id: number;
  /**
   * join_time string
   * @type {string}
   * @memberof GetFleetsFleetIdMembers200Ok
   */
  join_time: string;
  /**
   * Member’s role in fleet
   * @type {string}
   * @memberof GetFleetsFleetIdMembers200Ok
   */
  role: GetFleetsFleetIdMembers200OkRoleEnum;
  /**
   * Localized role names
   * @type {string}
   * @memberof GetFleetsFleetIdMembers200Ok
   */
  role_name: string;
  /**
   * ship_type_id integer
   * @type {number}
   * @memberof GetFleetsFleetIdMembers200Ok
   */
  ship_type_id: number;
  /**
   * Solar system the member is located in
   * @type {number}
   * @memberof GetFleetsFleetIdMembers200Ok
   */
  solar_system_id: number;
  /**
   * ID of the squad the member is in. If not applicable, will be set to -1
   * @type {number}
   * @memberof GetFleetsFleetIdMembers200Ok
   */
  squad_id: number;
  /**
   * Station in which the member is docked in, if applicable
   * @type {number}
   * @memberof GetFleetsFleetIdMembers200Ok
   */
  station_id?: number;
  /**
   * Whether the member take fleet warps
   * @type {boolean}
   * @memberof GetFleetsFleetIdMembers200Ok
   */
  takes_fleet_warp: boolean;
  /**
   * ID of the wing the member is in. If not applicable, will be set to -1
   * @type {number}
   * @memberof GetFleetsFleetIdMembers200Ok
   */
  wing_id: number;
}

export const GetFleetsFleetIdMembers200OkRoleEnum = {
  FLEET_COMMANDER: "fleet_commander",
  WING_COMMANDER: "wing_commander",
  SQUAD_COMMANDER: "squad_commander",
  SQUAD_MEMBER: "squad_member",
} as const;

export type GetFleetsFleetIdMembers200OkRoleEnum =
  typeof GetFleetsFleetIdMembers200OkRoleEnum[keyof typeof GetFleetsFleetIdMembers200OkRoleEnum];

/**
 * Not found
 * @export
 * @interface GetFleetsFleetIdMembersNotFound
 */
export interface GetFleetsFleetIdMembersNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetFleetsFleetIdMembersNotFound
   */
  error?: string;
}
/**
 * Not found
 * @export
 * @interface GetFleetsFleetIdNotFound
 */
export interface GetFleetsFleetIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetFleetsFleetIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetFleetsFleetIdOk
 */
export interface GetFleetsFleetIdOk {
  /**
   * Is free-move enabled
   * @type {boolean}
   * @memberof GetFleetsFleetIdOk
   */
  is_free_move: boolean;
  /**
   * Does the fleet have an active fleet advertisement
   * @type {boolean}
   * @memberof GetFleetsFleetIdOk
   */
  is_registered: boolean;
  /**
   * Is EVE Voice enabled
   * @type {boolean}
   * @memberof GetFleetsFleetIdOk
   */
  is_voice_enabled: boolean;
  /**
   * Fleet MOTD in CCP flavoured HTML
   * @type {string}
   * @memberof GetFleetsFleetIdOk
   */
  motd: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetFleetsFleetIdWings200Ok
 */
export interface GetFleetsFleetIdWings200Ok {
  /**
   * id integer
   * @type {number}
   * @memberof GetFleetsFleetIdWings200Ok
   */
  id: number;
  /**
   * name string
   * @type {string}
   * @memberof GetFleetsFleetIdWings200Ok
   */
  name: string;
  /**
   * squads array
   * @type {Array<GetFleetsFleetIdWingsSquad>}
   * @memberof GetFleetsFleetIdWings200Ok
   */
  squads: Array<GetFleetsFleetIdWingsSquad>;
}
/**
 * Not found
 * @export
 * @interface GetFleetsFleetIdWingsNotFound
 */
export interface GetFleetsFleetIdWingsNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetFleetsFleetIdWingsNotFound
   */
  error?: string;
}
/**
 * squad object
 * @export
 * @interface GetFleetsFleetIdWingsSquad
 */
export interface GetFleetsFleetIdWingsSquad {
  /**
   * id integer
   * @type {number}
   * @memberof GetFleetsFleetIdWingsSquad
   */
  id: number;
  /**
   * name string
   * @type {string}
   * @memberof GetFleetsFleetIdWingsSquad
   */
  name: string;
}
/**
 * active_total object
 * @export
 * @interface GetFwLeaderboardsActiveTotalActiveTotal
 */
export interface GetFwLeaderboardsActiveTotalActiveTotal {
  /**
   * Amount of kills
   * @type {number}
   * @memberof GetFwLeaderboardsActiveTotalActiveTotal
   */
  amount?: number;
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsActiveTotalActiveTotal
   */
  faction_id?: number;
}
/**
 * active_total object
 * @export
 * @interface GetFwLeaderboardsActiveTotalActiveTotal1
 */
export interface GetFwLeaderboardsActiveTotalActiveTotal1 {
  /**
   * Amount of victory points
   * @type {number}
   * @memberof GetFwLeaderboardsActiveTotalActiveTotal1
   */
  amount?: number;
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsActiveTotalActiveTotal1
   */
  faction_id?: number;
}
/**
 * active_total object
 * @export
 * @interface GetFwLeaderboardsCharactersActiveTotalActiveTotal
 */
export interface GetFwLeaderboardsCharactersActiveTotalActiveTotal {
  /**
   * Amount of kills
   * @type {number}
   * @memberof GetFwLeaderboardsCharactersActiveTotalActiveTotal
   */
  amount?: number;
  /**
   * character_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsCharactersActiveTotalActiveTotal
   */
  character_id?: number;
}
/**
 * active_total object
 * @export
 * @interface GetFwLeaderboardsCharactersActiveTotalActiveTotal1
 */
export interface GetFwLeaderboardsCharactersActiveTotalActiveTotal1 {
  /**
   * Amount of victory points
   * @type {number}
   * @memberof GetFwLeaderboardsCharactersActiveTotalActiveTotal1
   */
  amount?: number;
  /**
   * character_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsCharactersActiveTotalActiveTotal1
   */
  character_id?: number;
}
/**
 * Top 100 rankings of pilots by number of kills from yesterday, last week and in total
 * @export
 * @interface GetFwLeaderboardsCharactersKills
 */
export interface GetFwLeaderboardsCharactersKills {
  /**
   * Top 100 ranking of pilots active in faction warfare by total kills. A pilot is considered \"active\" if they have participated in faction warfare in the past 14 days
   * @type {Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal>}
   * @memberof GetFwLeaderboardsCharactersKills
   */
  active_total: Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal>;
  /**
   * Top 100 ranking of pilots by kills in the past week
   * @type {Array<GetFwLeaderboardsCharactersLastWeekLastWeek>}
   * @memberof GetFwLeaderboardsCharactersKills
   */
  last_week: Array<GetFwLeaderboardsCharactersLastWeekLastWeek>;
  /**
   * Top 100 ranking of pilots by kills in the past day
   * @type {Array<GetFwLeaderboardsCharactersYesterdayYesterday>}
   * @memberof GetFwLeaderboardsCharactersKills
   */
  yesterday: Array<GetFwLeaderboardsCharactersYesterdayYesterday>;
}
/**
 * last_week object
 * @export
 * @interface GetFwLeaderboardsCharactersLastWeekLastWeek
 */
export interface GetFwLeaderboardsCharactersLastWeekLastWeek {
  /**
   * Amount of kills
   * @type {number}
   * @memberof GetFwLeaderboardsCharactersLastWeekLastWeek
   */
  amount?: number;
  /**
   * character_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsCharactersLastWeekLastWeek
   */
  character_id?: number;
}
/**
 * last_week object
 * @export
 * @interface GetFwLeaderboardsCharactersLastWeekLastWeek1
 */
export interface GetFwLeaderboardsCharactersLastWeekLastWeek1 {
  /**
   * Amount of victory points
   * @type {number}
   * @memberof GetFwLeaderboardsCharactersLastWeekLastWeek1
   */
  amount?: number;
  /**
   * character_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsCharactersLastWeekLastWeek1
   */
  character_id?: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetFwLeaderboardsCharactersOk
 */
export interface GetFwLeaderboardsCharactersOk {
  /**
   *
   * @type {GetFwLeaderboardsCharactersKills}
   * @memberof GetFwLeaderboardsCharactersOk
   */
  kills: GetFwLeaderboardsCharactersKills;
  /**
   *
   * @type {GetFwLeaderboardsCharactersVictoryPoints}
   * @memberof GetFwLeaderboardsCharactersOk
   */
  victory_points: GetFwLeaderboardsCharactersVictoryPoints;
}
/**
 * Top 100 rankings of pilots by victory points from yesterday, last week and in total
 * @export
 * @interface GetFwLeaderboardsCharactersVictoryPoints
 */
export interface GetFwLeaderboardsCharactersVictoryPoints {
  /**
   * Top 100 ranking of pilots active in faction warfare by total victory points. A pilot is considered \"active\" if they have participated in faction warfare in the past 14 days
   * @type {Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal1>}
   * @memberof GetFwLeaderboardsCharactersVictoryPoints
   */
  active_total: Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal1>;
  /**
   * Top 100 ranking of pilots by victory points in the past week
   * @type {Array<GetFwLeaderboardsCharactersLastWeekLastWeek1>}
   * @memberof GetFwLeaderboardsCharactersVictoryPoints
   */
  last_week: Array<GetFwLeaderboardsCharactersLastWeekLastWeek1>;
  /**
   * Top 100 ranking of pilots by victory points in the past day
   * @type {Array<GetFwLeaderboardsCharactersYesterdayYesterday1>}
   * @memberof GetFwLeaderboardsCharactersVictoryPoints
   */
  yesterday: Array<GetFwLeaderboardsCharactersYesterdayYesterday1>;
}
/**
 * yesterday object
 * @export
 * @interface GetFwLeaderboardsCharactersYesterdayYesterday
 */
export interface GetFwLeaderboardsCharactersYesterdayYesterday {
  /**
   * Amount of kills
   * @type {number}
   * @memberof GetFwLeaderboardsCharactersYesterdayYesterday
   */
  amount?: number;
  /**
   * character_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsCharactersYesterdayYesterday
   */
  character_id?: number;
}
/**
 * yesterday object
 * @export
 * @interface GetFwLeaderboardsCharactersYesterdayYesterday1
 */
export interface GetFwLeaderboardsCharactersYesterdayYesterday1 {
  /**
   * Amount of victory points
   * @type {number}
   * @memberof GetFwLeaderboardsCharactersYesterdayYesterday1
   */
  amount?: number;
  /**
   * character_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsCharactersYesterdayYesterday1
   */
  character_id?: number;
}
/**
 * active_total object
 * @export
 * @interface GetFwLeaderboardsCorporationsActiveTotalActiveTotal
 */
export interface GetFwLeaderboardsCorporationsActiveTotalActiveTotal {
  /**
   * Amount of kills
   * @type {number}
   * @memberof GetFwLeaderboardsCorporationsActiveTotalActiveTotal
   */
  amount?: number;
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsCorporationsActiveTotalActiveTotal
   */
  corporation_id?: number;
}
/**
 * active_total object
 * @export
 * @interface GetFwLeaderboardsCorporationsActiveTotalActiveTotal1
 */
export interface GetFwLeaderboardsCorporationsActiveTotalActiveTotal1 {
  /**
   * Amount of victory points
   * @type {number}
   * @memberof GetFwLeaderboardsCorporationsActiveTotalActiveTotal1
   */
  amount?: number;
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsCorporationsActiveTotalActiveTotal1
   */
  corporation_id?: number;
}
/**
 * Top 10 rankings of corporations by number of kills from yesterday, last week and in total
 * @export
 * @interface GetFwLeaderboardsCorporationsKills
 */
export interface GetFwLeaderboardsCorporationsKills {
  /**
   * Top 10 ranking of corporations active in faction warfare by total kills. A corporation is considered \"active\" if they have participated in faction warfare in the past 14 days
   * @type {Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal>}
   * @memberof GetFwLeaderboardsCorporationsKills
   */
  active_total: Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal>;
  /**
   * Top 10 ranking of corporations by kills in the past week
   * @type {Array<GetFwLeaderboardsCorporationsLastWeekLastWeek>}
   * @memberof GetFwLeaderboardsCorporationsKills
   */
  last_week: Array<GetFwLeaderboardsCorporationsLastWeekLastWeek>;
  /**
   * Top 10 ranking of corporations by kills in the past day
   * @type {Array<GetFwLeaderboardsCorporationsYesterdayYesterday>}
   * @memberof GetFwLeaderboardsCorporationsKills
   */
  yesterday: Array<GetFwLeaderboardsCorporationsYesterdayYesterday>;
}
/**
 * last_week object
 * @export
 * @interface GetFwLeaderboardsCorporationsLastWeekLastWeek
 */
export interface GetFwLeaderboardsCorporationsLastWeekLastWeek {
  /**
   * Amount of kills
   * @type {number}
   * @memberof GetFwLeaderboardsCorporationsLastWeekLastWeek
   */
  amount?: number;
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsCorporationsLastWeekLastWeek
   */
  corporation_id?: number;
}
/**
 * last_week object
 * @export
 * @interface GetFwLeaderboardsCorporationsLastWeekLastWeek1
 */
export interface GetFwLeaderboardsCorporationsLastWeekLastWeek1 {
  /**
   * Amount of victory points
   * @type {number}
   * @memberof GetFwLeaderboardsCorporationsLastWeekLastWeek1
   */
  amount?: number;
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsCorporationsLastWeekLastWeek1
   */
  corporation_id?: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetFwLeaderboardsCorporationsOk
 */
export interface GetFwLeaderboardsCorporationsOk {
  /**
   *
   * @type {GetFwLeaderboardsCorporationsKills}
   * @memberof GetFwLeaderboardsCorporationsOk
   */
  kills: GetFwLeaderboardsCorporationsKills;
  /**
   *
   * @type {GetFwLeaderboardsCorporationsVictoryPoints}
   * @memberof GetFwLeaderboardsCorporationsOk
   */
  victory_points: GetFwLeaderboardsCorporationsVictoryPoints;
}
/**
 * Top 10 rankings of corporations by victory points from yesterday, last week and in total
 * @export
 * @interface GetFwLeaderboardsCorporationsVictoryPoints
 */
export interface GetFwLeaderboardsCorporationsVictoryPoints {
  /**
   * Top 10 ranking of corporations active in faction warfare by total victory points. A corporation is considered \"active\" if they have participated in faction warfare in the past 14 days
   * @type {Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal1>}
   * @memberof GetFwLeaderboardsCorporationsVictoryPoints
   */
  active_total: Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal1>;
  /**
   * Top 10 ranking of corporations by victory points in the past week
   * @type {Array<GetFwLeaderboardsCorporationsLastWeekLastWeek1>}
   * @memberof GetFwLeaderboardsCorporationsVictoryPoints
   */
  last_week: Array<GetFwLeaderboardsCorporationsLastWeekLastWeek1>;
  /**
   * Top 10 ranking of corporations by victory points in the past day
   * @type {Array<GetFwLeaderboardsCorporationsYesterdayYesterday1>}
   * @memberof GetFwLeaderboardsCorporationsVictoryPoints
   */
  yesterday: Array<GetFwLeaderboardsCorporationsYesterdayYesterday1>;
}
/**
 * yesterday object
 * @export
 * @interface GetFwLeaderboardsCorporationsYesterdayYesterday
 */
export interface GetFwLeaderboardsCorporationsYesterdayYesterday {
  /**
   * Amount of kills
   * @type {number}
   * @memberof GetFwLeaderboardsCorporationsYesterdayYesterday
   */
  amount?: number;
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsCorporationsYesterdayYesterday
   */
  corporation_id?: number;
}
/**
 * yesterday object
 * @export
 * @interface GetFwLeaderboardsCorporationsYesterdayYesterday1
 */
export interface GetFwLeaderboardsCorporationsYesterdayYesterday1 {
  /**
   * Amount of victory points
   * @type {number}
   * @memberof GetFwLeaderboardsCorporationsYesterdayYesterday1
   */
  amount?: number;
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsCorporationsYesterdayYesterday1
   */
  corporation_id?: number;
}
/**
 * Top 4 rankings of factions by number of kills from yesterday, last week and in total
 * @export
 * @interface GetFwLeaderboardsKills
 */
export interface GetFwLeaderboardsKills {
  /**
   * Top 4 ranking of factions active in faction warfare by total kills. A faction is considered \"active\" if they have participated in faction warfare in the past 14 days
   * @type {Array<GetFwLeaderboardsActiveTotalActiveTotal>}
   * @memberof GetFwLeaderboardsKills
   */
  active_total: Array<GetFwLeaderboardsActiveTotalActiveTotal>;
  /**
   * Top 4 ranking of factions by kills in the past week
   * @type {Array<GetFwLeaderboardsLastWeekLastWeek>}
   * @memberof GetFwLeaderboardsKills
   */
  last_week: Array<GetFwLeaderboardsLastWeekLastWeek>;
  /**
   * Top 4 ranking of factions by kills in the past day
   * @type {Array<GetFwLeaderboardsYesterdayYesterday>}
   * @memberof GetFwLeaderboardsKills
   */
  yesterday: Array<GetFwLeaderboardsYesterdayYesterday>;
}
/**
 * last_week object
 * @export
 * @interface GetFwLeaderboardsLastWeekLastWeek
 */
export interface GetFwLeaderboardsLastWeekLastWeek {
  /**
   * Amount of kills
   * @type {number}
   * @memberof GetFwLeaderboardsLastWeekLastWeek
   */
  amount?: number;
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsLastWeekLastWeek
   */
  faction_id?: number;
}
/**
 * last_week object
 * @export
 * @interface GetFwLeaderboardsLastWeekLastWeek1
 */
export interface GetFwLeaderboardsLastWeekLastWeek1 {
  /**
   * Amount of victory points
   * @type {number}
   * @memberof GetFwLeaderboardsLastWeekLastWeek1
   */
  amount?: number;
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsLastWeekLastWeek1
   */
  faction_id?: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetFwLeaderboardsOk
 */
export interface GetFwLeaderboardsOk {
  /**
   *
   * @type {GetFwLeaderboardsKills}
   * @memberof GetFwLeaderboardsOk
   */
  kills: GetFwLeaderboardsKills;
  /**
   *
   * @type {GetFwLeaderboardsVictoryPoints}
   * @memberof GetFwLeaderboardsOk
   */
  victory_points: GetFwLeaderboardsVictoryPoints;
}
/**
 * Top 4 rankings of factions by victory points from yesterday, last week and in total
 * @export
 * @interface GetFwLeaderboardsVictoryPoints
 */
export interface GetFwLeaderboardsVictoryPoints {
  /**
   * Top 4 ranking of factions active in faction warfare by total victory points. A faction is considered \"active\" if they have participated in faction warfare in the past 14 days
   * @type {Array<GetFwLeaderboardsActiveTotalActiveTotal1>}
   * @memberof GetFwLeaderboardsVictoryPoints
   */
  active_total: Array<GetFwLeaderboardsActiveTotalActiveTotal1>;
  /**
   * Top 4 ranking of factions by victory points in the past week
   * @type {Array<GetFwLeaderboardsLastWeekLastWeek1>}
   * @memberof GetFwLeaderboardsVictoryPoints
   */
  last_week: Array<GetFwLeaderboardsLastWeekLastWeek1>;
  /**
   * Top 4 ranking of factions by victory points in the past day
   * @type {Array<GetFwLeaderboardsYesterdayYesterday1>}
   * @memberof GetFwLeaderboardsVictoryPoints
   */
  yesterday: Array<GetFwLeaderboardsYesterdayYesterday1>;
}
/**
 * yesterday object
 * @export
 * @interface GetFwLeaderboardsYesterdayYesterday
 */
export interface GetFwLeaderboardsYesterdayYesterday {
  /**
   * Amount of kills
   * @type {number}
   * @memberof GetFwLeaderboardsYesterdayYesterday
   */
  amount?: number;
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsYesterdayYesterday
   */
  faction_id?: number;
}
/**
 * yesterday object
 * @export
 * @interface GetFwLeaderboardsYesterdayYesterday1
 */
export interface GetFwLeaderboardsYesterdayYesterday1 {
  /**
   * Amount of victory points
   * @type {number}
   * @memberof GetFwLeaderboardsYesterdayYesterday1
   */
  amount?: number;
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetFwLeaderboardsYesterdayYesterday1
   */
  faction_id?: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetFwStats200Ok
 */
export interface GetFwStats200Ok {
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetFwStats200Ok
   */
  faction_id: number;
  /**
   *
   * @type {GetFwStatsKills}
   * @memberof GetFwStats200Ok
   */
  kills: GetFwStatsKills;
  /**
   * How many pilots fight for the given faction
   * @type {number}
   * @memberof GetFwStats200Ok
   */
  pilots: number;
  /**
   * The number of solar systems controlled by the given faction
   * @type {number}
   * @memberof GetFwStats200Ok
   */
  systems_controlled: number;
  /**
   *
   * @type {GetFwStatsVictoryPoints}
   * @memberof GetFwStats200Ok
   */
  victory_points: GetFwStatsVictoryPoints;
}
/**
 * Summary of kills against an enemy faction for the given faction
 * @export
 * @interface GetFwStatsKills
 */
export interface GetFwStatsKills {
  /**
   * Last week\'s total number of kills against enemy factions
   * @type {number}
   * @memberof GetFwStatsKills
   */
  last_week: number;
  /**
   * Total number of kills against enemy factions since faction warfare began
   * @type {number}
   * @memberof GetFwStatsKills
   */
  total: number;
  /**
   * Yesterday\'s total number of kills against enemy factions
   * @type {number}
   * @memberof GetFwStatsKills
   */
  yesterday: number;
}
/**
 * Summary of victory points gained for the given faction
 * @export
 * @interface GetFwStatsVictoryPoints
 */
export interface GetFwStatsVictoryPoints {
  /**
   * Last week\'s victory points gained
   * @type {number}
   * @memberof GetFwStatsVictoryPoints
   */
  last_week: number;
  /**
   * Total victory points gained since faction warfare began
   * @type {number}
   * @memberof GetFwStatsVictoryPoints
   */
  total: number;
  /**
   * Yesterday\'s victory points gained
   * @type {number}
   * @memberof GetFwStatsVictoryPoints
   */
  yesterday: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetFwSystems200Ok
 */
export interface GetFwSystems200Ok {
  /**
   * contested string
   * @type {string}
   * @memberof GetFwSystems200Ok
   */
  contested: GetFwSystems200OkContestedEnum;
  /**
   * occupier_faction_id integer
   * @type {number}
   * @memberof GetFwSystems200Ok
   */
  occupier_faction_id: number;
  /**
   * owner_faction_id integer
   * @type {number}
   * @memberof GetFwSystems200Ok
   */
  owner_faction_id: number;
  /**
   * solar_system_id integer
   * @type {number}
   * @memberof GetFwSystems200Ok
   */
  solar_system_id: number;
  /**
   * victory_points integer
   * @type {number}
   * @memberof GetFwSystems200Ok
   */
  victory_points: number;
  /**
   * victory_points_threshold integer
   * @type {number}
   * @memberof GetFwSystems200Ok
   */
  victory_points_threshold: number;
}

export const GetFwSystems200OkContestedEnum = {
  CAPTURED: "captured",
  CONTESTED: "contested",
  UNCONTESTED: "uncontested",
  VULNERABLE: "vulnerable",
} as const;

export type GetFwSystems200OkContestedEnum =
  typeof GetFwSystems200OkContestedEnum[keyof typeof GetFwSystems200OkContestedEnum];

/**
 * 200 ok object
 * @export
 * @interface GetFwWars200Ok
 */
export interface GetFwWars200Ok {
  /**
   * The faction ID of the enemy faction.
   * @type {number}
   * @memberof GetFwWars200Ok
   */
  against_id: number;
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetFwWars200Ok
   */
  faction_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetIncursions200Ok
 */
export interface GetIncursions200Ok {
  /**
   * The constellation id in which this incursion takes place
   * @type {number}
   * @memberof GetIncursions200Ok
   */
  constellation_id: number;
  /**
   * The attacking faction\'s id
   * @type {number}
   * @memberof GetIncursions200Ok
   */
  faction_id: number;
  /**
   * Whether the final encounter has boss or not
   * @type {boolean}
   * @memberof GetIncursions200Ok
   */
  has_boss: boolean;
  /**
   * A list of infested solar system ids that are a part of this incursion
   * @type {Array<number>}
   * @memberof GetIncursions200Ok
   */
  infested_solar_systems: Array<number>;
  /**
   * Influence of this incursion as a float from 0 to 1
   * @type {number}
   * @memberof GetIncursions200Ok
   */
  influence: number;
  /**
   * Staging solar system for this incursion
   * @type {number}
   * @memberof GetIncursions200Ok
   */
  staging_solar_system_id: number;
  /**
   * The state of this incursion
   * @type {string}
   * @memberof GetIncursions200Ok
   */
  state: GetIncursions200OkStateEnum;
  /**
   * The type of this incursion
   * @type {string}
   * @memberof GetIncursions200Ok
   */
  type: string;
}

export const GetIncursions200OkStateEnum = {
  WITHDRAWING: "withdrawing",
  MOBILIZING: "mobilizing",
  ESTABLISHED: "established",
} as const;

export type GetIncursions200OkStateEnum =
  typeof GetIncursions200OkStateEnum[keyof typeof GetIncursions200OkStateEnum];

/**
 * 200 ok object
 * @export
 * @interface GetIndustryFacilities200Ok
 */
export interface GetIndustryFacilities200Ok {
  /**
   * ID of the facility
   * @type {number}
   * @memberof GetIndustryFacilities200Ok
   */
  facility_id: number;
  /**
   * Owner of the facility
   * @type {number}
   * @memberof GetIndustryFacilities200Ok
   */
  owner_id: number;
  /**
   * Region ID where the facility is
   * @type {number}
   * @memberof GetIndustryFacilities200Ok
   */
  region_id: number;
  /**
   * Solar system ID where the facility is
   * @type {number}
   * @memberof GetIndustryFacilities200Ok
   */
  solar_system_id: number;
  /**
   * Tax imposed by the facility
   * @type {number}
   * @memberof GetIndustryFacilities200Ok
   */
  tax?: number;
  /**
   * Type ID of the facility
   * @type {number}
   * @memberof GetIndustryFacilities200Ok
   */
  type_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetIndustrySystems200Ok
 */
export interface GetIndustrySystems200Ok {
  /**
   * cost_indices array
   * @type {Array<GetIndustrySystemsCostIndice>}
   * @memberof GetIndustrySystems200Ok
   */
  cost_indices: Array<GetIndustrySystemsCostIndice>;
  /**
   * solar_system_id integer
   * @type {number}
   * @memberof GetIndustrySystems200Ok
   */
  solar_system_id: number;
}
/**
 * cost_indice object
 * @export
 * @interface GetIndustrySystemsCostIndice
 */
export interface GetIndustrySystemsCostIndice {
  /**
   * activity string
   * @type {string}
   * @memberof GetIndustrySystemsCostIndice
   */
  activity: GetIndustrySystemsCostIndiceActivityEnum;
  /**
   * cost_index number
   * @type {number}
   * @memberof GetIndustrySystemsCostIndice
   */
  cost_index: number;
}

export const GetIndustrySystemsCostIndiceActivityEnum = {
  COPYING: "copying",
  DUPLICATING: "duplicating",
  INVENTION: "invention",
  MANUFACTURING: "manufacturing",
  NONE: "none",
  REACTION: "reaction",
  RESEARCHING_MATERIAL_EFFICIENCY: "researching_material_efficiency",
  RESEARCHING_TECHNOLOGY: "researching_technology",
  RESEARCHING_TIME_EFFICIENCY: "researching_time_efficiency",
  REVERSE_ENGINEERING: "reverse_engineering",
} as const;

export type GetIndustrySystemsCostIndiceActivityEnum =
  typeof GetIndustrySystemsCostIndiceActivityEnum[keyof typeof GetIndustrySystemsCostIndiceActivityEnum];

/**
 * 200 ok object
 * @export
 * @interface GetInsurancePrices200Ok
 */
export interface GetInsurancePrices200Ok {
  /**
   * A list of a available insurance levels for this ship type
   * @type {Array<GetInsurancePricesLevel>}
   * @memberof GetInsurancePrices200Ok
   */
  levels: Array<GetInsurancePricesLevel>;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetInsurancePrices200Ok
   */
  type_id: number;
}
/**
 * level object
 * @export
 * @interface GetInsurancePricesLevel
 */
export interface GetInsurancePricesLevel {
  /**
   * cost number
   * @type {number}
   * @memberof GetInsurancePricesLevel
   */
  cost: number;
  /**
   * Localized insurance level
   * @type {string}
   * @memberof GetInsurancePricesLevel
   */
  name: string;
  /**
   * payout number
   * @type {number}
   * @memberof GetInsurancePricesLevel
   */
  payout: number;
}
/**
 * attacker object
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashAttacker
 */
export interface GetKillmailsKillmailIdKillmailHashAttacker {
  /**
   * alliance_id integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashAttacker
   */
  alliance_id?: number;
  /**
   * character_id integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashAttacker
   */
  character_id?: number;
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashAttacker
   */
  corporation_id?: number;
  /**
   * damage_done integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashAttacker
   */
  damage_done: number;
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashAttacker
   */
  faction_id?: number;
  /**
   * Was the attacker the one to achieve the final blow
   * @type {boolean}
   * @memberof GetKillmailsKillmailIdKillmailHashAttacker
   */
  final_blow: boolean;
  /**
   * Security status for the attacker
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashAttacker
   */
  security_status: number;
  /**
   * What ship was the attacker flying
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashAttacker
   */
  ship_type_id?: number;
  /**
   * What weapon was used by the attacker for the kill
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashAttacker
   */
  weapon_type_id?: number;
}
/**
 * item object
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashItem
 */
export interface GetKillmailsKillmailIdKillmailHashItem {
  /**
   * Flag for the location of the item
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashItem
   */
  flag: number;
  /**
   * item_type_id integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashItem
   */
  item_type_id: number;
  /**
   * items array
   * @type {Array<GetKillmailsKillmailIdKillmailHashItemsItem>}
   * @memberof GetKillmailsKillmailIdKillmailHashItem
   */
  items?: Array<GetKillmailsKillmailIdKillmailHashItemsItem>;
  /**
   * How many of the item were destroyed if any
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashItem
   */
  quantity_destroyed?: number;
  /**
   * How many of the item were dropped if any
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashItem
   */
  quantity_dropped?: number;
  /**
   * singleton integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashItem
   */
  singleton: number;
}
/**
 * item object
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashItemsItem
 */
export interface GetKillmailsKillmailIdKillmailHashItemsItem {
  /**
   * flag integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashItemsItem
   */
  flag: number;
  /**
   * item_type_id integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashItemsItem
   */
  item_type_id: number;
  /**
   * quantity_destroyed integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashItemsItem
   */
  quantity_destroyed?: number;
  /**
   * quantity_dropped integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashItemsItem
   */
  quantity_dropped?: number;
  /**
   * singleton integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashItemsItem
   */
  singleton: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashOk
 */
export interface GetKillmailsKillmailIdKillmailHashOk {
  /**
   * attackers array
   * @type {Array<GetKillmailsKillmailIdKillmailHashAttacker>}
   * @memberof GetKillmailsKillmailIdKillmailHashOk
   */
  attackers: Array<GetKillmailsKillmailIdKillmailHashAttacker>;
  /**
   * ID of the killmail
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashOk
   */
  killmail_id: number;
  /**
   * Time that the victim was killed and the killmail generated
   * @type {string}
   * @memberof GetKillmailsKillmailIdKillmailHashOk
   */
  killmail_time: string;
  /**
   * Moon if the kill took place at one
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashOk
   */
  moon_id?: number;
  /**
   * Solar system that the kill took place in
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashOk
   */
  solar_system_id: number;
  /**
   *
   * @type {GetKillmailsKillmailIdKillmailHashVictim}
   * @memberof GetKillmailsKillmailIdKillmailHashOk
   */
  victim: GetKillmailsKillmailIdKillmailHashVictim;
  /**
   * War if the killmail is generated in relation to an official war
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashOk
   */
  war_id?: number;
}
/**
 * Coordinates of the victim in Cartesian space relative to the Sun
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashPosition
 */
export interface GetKillmailsKillmailIdKillmailHashPosition {
  /**
   * x number
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashPosition
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashPosition
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashPosition
   */
  z: number;
}
/**
 * Unprocessable entity
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashUnprocessableEntity
 */
export interface GetKillmailsKillmailIdKillmailHashUnprocessableEntity {
  /**
   * Unprocessable entity message
   * @type {string}
   * @memberof GetKillmailsKillmailIdKillmailHashUnprocessableEntity
   */
  error?: string;
}
/**
 * victim object
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashVictim
 */
export interface GetKillmailsKillmailIdKillmailHashVictim {
  /**
   * alliance_id integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashVictim
   */
  alliance_id?: number;
  /**
   * character_id integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashVictim
   */
  character_id?: number;
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashVictim
   */
  corporation_id?: number;
  /**
   * How much total damage was taken by the victim
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashVictim
   */
  damage_taken: number;
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashVictim
   */
  faction_id?: number;
  /**
   * items array
   * @type {Array<GetKillmailsKillmailIdKillmailHashItem>}
   * @memberof GetKillmailsKillmailIdKillmailHashVictim
   */
  items?: Array<GetKillmailsKillmailIdKillmailHashItem>;
  /**
   *
   * @type {GetKillmailsKillmailIdKillmailHashPosition}
   * @memberof GetKillmailsKillmailIdKillmailHashVictim
   */
  position?: GetKillmailsKillmailIdKillmailHashPosition;
  /**
   * The ship that the victim was piloting and was destroyed
   * @type {number}
   * @memberof GetKillmailsKillmailIdKillmailHashVictim
   */
  ship_type_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetLoyaltyStoresCorporationIdOffers200Ok
 */
export interface GetLoyaltyStoresCorporationIdOffers200Ok {
  /**
   * Analysis kredit cost
   * @type {number}
   * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
   */
  ak_cost?: number;
  /**
   * isk_cost integer
   * @type {number}
   * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
   */
  isk_cost: number;
  /**
   * lp_cost integer
   * @type {number}
   * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
   */
  lp_cost: number;
  /**
   * offer_id integer
   * @type {number}
   * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
   */
  offer_id: number;
  /**
   * quantity integer
   * @type {number}
   * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
   */
  quantity: number;
  /**
   * required_items array
   * @type {Array<GetLoyaltyStoresCorporationIdOffersRequiredItem>}
   * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
   */
  required_items: Array<GetLoyaltyStoresCorporationIdOffersRequiredItem>;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
   */
  type_id: number;
}
/**
 * Not found
 * @export
 * @interface GetLoyaltyStoresCorporationIdOffersNotFound
 */
export interface GetLoyaltyStoresCorporationIdOffersNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetLoyaltyStoresCorporationIdOffersNotFound
   */
  error?: string;
}
/**
 * required_item object
 * @export
 * @interface GetLoyaltyStoresCorporationIdOffersRequiredItem
 */
export interface GetLoyaltyStoresCorporationIdOffersRequiredItem {
  /**
   * quantity integer
   * @type {number}
   * @memberof GetLoyaltyStoresCorporationIdOffersRequiredItem
   */
  quantity: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetLoyaltyStoresCorporationIdOffersRequiredItem
   */
  type_id: number;
}
/**
 * Not found
 * @export
 * @interface GetMarketsGroupsMarketGroupIdNotFound
 */
export interface GetMarketsGroupsMarketGroupIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetMarketsGroupsMarketGroupIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetMarketsGroupsMarketGroupIdOk
 */
export interface GetMarketsGroupsMarketGroupIdOk {
  /**
   * description string
   * @type {string}
   * @memberof GetMarketsGroupsMarketGroupIdOk
   */
  description: string;
  /**
   * market_group_id integer
   * @type {number}
   * @memberof GetMarketsGroupsMarketGroupIdOk
   */
  market_group_id: number;
  /**
   * name string
   * @type {string}
   * @memberof GetMarketsGroupsMarketGroupIdOk
   */
  name: string;
  /**
   * parent_group_id integer
   * @type {number}
   * @memberof GetMarketsGroupsMarketGroupIdOk
   */
  parent_group_id?: number;
  /**
   * types array
   * @type {Array<number>}
   * @memberof GetMarketsGroupsMarketGroupIdOk
   */
  types: Array<number>;
}
/**
 * 200 ok object
 * @export
 * @interface GetMarketsPrices200Ok
 */
export interface GetMarketsPrices200Ok {
  /**
   * adjusted_price number
   * @type {number}
   * @memberof GetMarketsPrices200Ok
   */
  adjusted_price?: number;
  /**
   * average_price number
   * @type {number}
   * @memberof GetMarketsPrices200Ok
   */
  average_price?: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetMarketsPrices200Ok
   */
  type_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetMarketsRegionIdHistory200Ok
 */
export interface GetMarketsRegionIdHistory200Ok {
  /**
   * average number
   * @type {number}
   * @memberof GetMarketsRegionIdHistory200Ok
   */
  average: number;
  /**
   * The date of this historical statistic entry
   * @type {string}
   * @memberof GetMarketsRegionIdHistory200Ok
   */
  date: string;
  /**
   * highest number
   * @type {number}
   * @memberof GetMarketsRegionIdHistory200Ok
   */
  highest: number;
  /**
   * lowest number
   * @type {number}
   * @memberof GetMarketsRegionIdHistory200Ok
   */
  lowest: number;
  /**
   * Total number of orders happened that day
   * @type {number}
   * @memberof GetMarketsRegionIdHistory200Ok
   */
  order_count: number;
  /**
   * Total
   * @type {number}
   * @memberof GetMarketsRegionIdHistory200Ok
   */
  volume: number;
}
/**
 * Error 520
 * @export
 * @interface GetMarketsRegionIdHistoryError520
 */
export interface GetMarketsRegionIdHistoryError520 {
  /**
   * Error 520 message
   * @type {string}
   * @memberof GetMarketsRegionIdHistoryError520
   */
  error?: string;
}
/**
 * Not found
 * @export
 * @interface GetMarketsRegionIdHistoryNotFound
 */
export interface GetMarketsRegionIdHistoryNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetMarketsRegionIdHistoryNotFound
   */
  error?: string;
}
/**
 * Unprocessable entity
 * @export
 * @interface GetMarketsRegionIdHistoryUnprocessableEntity
 */
export interface GetMarketsRegionIdHistoryUnprocessableEntity {
  /**
   * Unprocessable entity message
   * @type {string}
   * @memberof GetMarketsRegionIdHistoryUnprocessableEntity
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetMarketsRegionIdOrders200Ok
 */
export interface GetMarketsRegionIdOrders200Ok {
  /**
   * duration integer
   * @type {number}
   * @memberof GetMarketsRegionIdOrders200Ok
   */
  duration: number;
  /**
   * is_buy_order boolean
   * @type {boolean}
   * @memberof GetMarketsRegionIdOrders200Ok
   */
  is_buy_order: boolean;
  /**
   * issued string
   * @type {string}
   * @memberof GetMarketsRegionIdOrders200Ok
   */
  issued: string;
  /**
   * location_id integer
   * @type {number}
   * @memberof GetMarketsRegionIdOrders200Ok
   */
  location_id: number;
  /**
   * min_volume integer
   * @type {number}
   * @memberof GetMarketsRegionIdOrders200Ok
   */
  min_volume: number;
  /**
   * order_id integer
   * @type {number}
   * @memberof GetMarketsRegionIdOrders200Ok
   */
  order_id: number;
  /**
   * price number
   * @type {number}
   * @memberof GetMarketsRegionIdOrders200Ok
   */
  price: number;
  /**
   * range string
   * @type {string}
   * @memberof GetMarketsRegionIdOrders200Ok
   */
  range: GetMarketsRegionIdOrders200OkRangeEnum;
  /**
   * The solar system this order was placed
   * @type {number}
   * @memberof GetMarketsRegionIdOrders200Ok
   */
  system_id: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetMarketsRegionIdOrders200Ok
   */
  type_id: number;
  /**
   * volume_remain integer
   * @type {number}
   * @memberof GetMarketsRegionIdOrders200Ok
   */
  volume_remain: number;
  /**
   * volume_total integer
   * @type {number}
   * @memberof GetMarketsRegionIdOrders200Ok
   */
  volume_total: number;
}

export const GetMarketsRegionIdOrders200OkRangeEnum = {
  STATION: "station",
  REGION: "region",
  SOLARSYSTEM: "solarsystem",
  _1: "1",
  _2: "2",
  _3: "3",
  _4: "4",
  _5: "5",
  _10: "10",
  _20: "20",
  _30: "30",
  _40: "40",
} as const;

export type GetMarketsRegionIdOrders200OkRangeEnum =
  typeof GetMarketsRegionIdOrders200OkRangeEnum[keyof typeof GetMarketsRegionIdOrders200OkRangeEnum];

/**
 * Not found
 * @export
 * @interface GetMarketsRegionIdOrdersNotFound
 */
export interface GetMarketsRegionIdOrdersNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetMarketsRegionIdOrdersNotFound
   */
  error?: string;
}
/**
 * Unprocessable entity
 * @export
 * @interface GetMarketsRegionIdOrdersUnprocessableEntity
 */
export interface GetMarketsRegionIdOrdersUnprocessableEntity {
  /**
   * Unprocessable entity message
   * @type {string}
   * @memberof GetMarketsRegionIdOrdersUnprocessableEntity
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetMarketsStructuresStructureId200Ok
 */
export interface GetMarketsStructuresStructureId200Ok {
  /**
   * duration integer
   * @type {number}
   * @memberof GetMarketsStructuresStructureId200Ok
   */
  duration: number;
  /**
   * is_buy_order boolean
   * @type {boolean}
   * @memberof GetMarketsStructuresStructureId200Ok
   */
  is_buy_order: boolean;
  /**
   * issued string
   * @type {string}
   * @memberof GetMarketsStructuresStructureId200Ok
   */
  issued: string;
  /**
   * location_id integer
   * @type {number}
   * @memberof GetMarketsStructuresStructureId200Ok
   */
  location_id: number;
  /**
   * min_volume integer
   * @type {number}
   * @memberof GetMarketsStructuresStructureId200Ok
   */
  min_volume: number;
  /**
   * order_id integer
   * @type {number}
   * @memberof GetMarketsStructuresStructureId200Ok
   */
  order_id: number;
  /**
   * price number
   * @type {number}
   * @memberof GetMarketsStructuresStructureId200Ok
   */
  price: number;
  /**
   * range string
   * @type {string}
   * @memberof GetMarketsStructuresStructureId200Ok
   */
  range: GetMarketsStructuresStructureId200OkRangeEnum;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetMarketsStructuresStructureId200Ok
   */
  type_id: number;
  /**
   * volume_remain integer
   * @type {number}
   * @memberof GetMarketsStructuresStructureId200Ok
   */
  volume_remain: number;
  /**
   * volume_total integer
   * @type {number}
   * @memberof GetMarketsStructuresStructureId200Ok
   */
  volume_total: number;
}

export const GetMarketsStructuresStructureId200OkRangeEnum = {
  STATION: "station",
  REGION: "region",
  SOLARSYSTEM: "solarsystem",
  _1: "1",
  _2: "2",
  _3: "3",
  _4: "4",
  _5: "5",
  _10: "10",
  _20: "20",
  _30: "30",
  _40: "40",
} as const;

export type GetMarketsStructuresStructureId200OkRangeEnum =
  typeof GetMarketsStructuresStructureId200OkRangeEnum[keyof typeof GetMarketsStructuresStructureId200OkRangeEnum];

/**
 * 200 ok object
 * @export
 * @interface GetOpportunitiesGroupsGroupIdOk
 */
export interface GetOpportunitiesGroupsGroupIdOk {
  /**
   * The groups that are connected to this group on the opportunities map
   * @type {Array<number>}
   * @memberof GetOpportunitiesGroupsGroupIdOk
   */
  connected_groups: Array<number>;
  /**
   * description string
   * @type {string}
   * @memberof GetOpportunitiesGroupsGroupIdOk
   */
  description: string;
  /**
   * group_id integer
   * @type {number}
   * @memberof GetOpportunitiesGroupsGroupIdOk
   */
  group_id: number;
  /**
   * name string
   * @type {string}
   * @memberof GetOpportunitiesGroupsGroupIdOk
   */
  name: string;
  /**
   * notification string
   * @type {string}
   * @memberof GetOpportunitiesGroupsGroupIdOk
   */
  notification: string;
  /**
   * Tasks need to complete for this group
   * @type {Array<number>}
   * @memberof GetOpportunitiesGroupsGroupIdOk
   */
  required_tasks: Array<number>;
}
/**
 * 200 ok object
 * @export
 * @interface GetOpportunitiesTasksTaskIdOk
 */
export interface GetOpportunitiesTasksTaskIdOk {
  /**
   * description string
   * @type {string}
   * @memberof GetOpportunitiesTasksTaskIdOk
   */
  description: string;
  /**
   * name string
   * @type {string}
   * @memberof GetOpportunitiesTasksTaskIdOk
   */
  name: string;
  /**
   * notification string
   * @type {string}
   * @memberof GetOpportunitiesTasksTaskIdOk
   */
  notification: string;
  /**
   * task_id integer
   * @type {number}
   * @memberof GetOpportunitiesTasksTaskIdOk
   */
  task_id: number;
}
/**
 * Not found
 * @export
 * @interface GetRouteOriginDestinationNotFound
 */
export interface GetRouteOriginDestinationNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetRouteOriginDestinationNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetSovereigntyCampaigns200Ok
 */
export interface GetSovereigntyCampaigns200Ok {
  /**
   * Score for all attacking parties, only present in Defense Events.
   * @type {number}
   * @memberof GetSovereigntyCampaigns200Ok
   */
  attackers_score?: number;
  /**
   * Unique ID for this campaign.
   * @type {number}
   * @memberof GetSovereigntyCampaigns200Ok
   */
  campaign_id: number;
  /**
   * The constellation in which the campaign will take place.
   * @type {number}
   * @memberof GetSovereigntyCampaigns200Ok
   */
  constellation_id: number;
  /**
   * Defending alliance, only present in Defense Events
   * @type {number}
   * @memberof GetSovereigntyCampaigns200Ok
   */
  defender_id?: number;
  /**
   * Score for the defending alliance, only present in Defense Events.
   * @type {number}
   * @memberof GetSovereigntyCampaigns200Ok
   */
  defender_score?: number;
  /**
   * Type of event this campaign is for. tcu_defense, ihub_defense and station_defense are referred to as \"Defense Events\", station_freeport as \"Freeport Events\".
   * @type {string}
   * @memberof GetSovereigntyCampaigns200Ok
   */
  event_type: GetSovereigntyCampaigns200OkEventTypeEnum;
  /**
   * Alliance participating and their respective scores, only present in Freeport Events.
   * @type {Array<GetSovereigntyCampaignsParticipant>}
   * @memberof GetSovereigntyCampaigns200Ok
   */
  participants?: Array<GetSovereigntyCampaignsParticipant>;
  /**
   * The solar system the structure is located in.
   * @type {number}
   * @memberof GetSovereigntyCampaigns200Ok
   */
  solar_system_id: number;
  /**
   * Time the event is scheduled to start.
   * @type {string}
   * @memberof GetSovereigntyCampaigns200Ok
   */
  start_time: string;
  /**
   * The structure item ID that is related to this campaign.
   * @type {number}
   * @memberof GetSovereigntyCampaigns200Ok
   */
  structure_id: number;
}

export const GetSovereigntyCampaigns200OkEventTypeEnum = {
  TCU_DEFENSE: "tcu_defense",
  IHUB_DEFENSE: "ihub_defense",
  STATION_DEFENSE: "station_defense",
  STATION_FREEPORT: "station_freeport",
} as const;

export type GetSovereigntyCampaigns200OkEventTypeEnum =
  typeof GetSovereigntyCampaigns200OkEventTypeEnum[keyof typeof GetSovereigntyCampaigns200OkEventTypeEnum];

/**
 * participant object
 * @export
 * @interface GetSovereigntyCampaignsParticipant
 */
export interface GetSovereigntyCampaignsParticipant {
  /**
   * alliance_id integer
   * @type {number}
   * @memberof GetSovereigntyCampaignsParticipant
   */
  alliance_id: number;
  /**
   * score number
   * @type {number}
   * @memberof GetSovereigntyCampaignsParticipant
   */
  score: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetSovereigntyMap200Ok
 */
export interface GetSovereigntyMap200Ok {
  /**
   * alliance_id integer
   * @type {number}
   * @memberof GetSovereigntyMap200Ok
   */
  alliance_id?: number;
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetSovereigntyMap200Ok
   */
  corporation_id?: number;
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetSovereigntyMap200Ok
   */
  faction_id?: number;
  /**
   * system_id integer
   * @type {number}
   * @memberof GetSovereigntyMap200Ok
   */
  system_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetSovereigntyStructures200Ok
 */
export interface GetSovereigntyStructures200Ok {
  /**
   * The alliance that owns the structure.
   * @type {number}
   * @memberof GetSovereigntyStructures200Ok
   */
  alliance_id: number;
  /**
   * Solar system in which the structure is located.
   * @type {number}
   * @memberof GetSovereigntyStructures200Ok
   */
  solar_system_id: number;
  /**
   * Unique item ID for this structure.
   * @type {number}
   * @memberof GetSovereigntyStructures200Ok
   */
  structure_id: number;
  /**
   * A reference to the type of structure this is.
   * @type {number}
   * @memberof GetSovereigntyStructures200Ok
   */
  structure_type_id: number;
  /**
   * The occupancy level for the next or current vulnerability window. This takes into account all development indexes and capital system bonuses. Also known as Activity Defense Multiplier from in the client. It increases the time that attackers must spend using their entosis links on the structure.
   * @type {number}
   * @memberof GetSovereigntyStructures200Ok
   */
  vulnerability_occupancy_level?: number;
  /**
   * The time at which the next or current vulnerability window ends. At the end of a vulnerability window the next window is recalculated and locked in along with the vulnerabilityOccupancyLevel. If the structure is not in 100% entosis control of the defender, it will go in to \'overtime\' and stay vulnerable for as long as that situation persists. Only once the defenders have 100% entosis control and has the vulnerableEndTime passed does the vulnerability interval expire and a new one is calculated.
   * @type {string}
   * @memberof GetSovereigntyStructures200Ok
   */
  vulnerable_end_time?: string;
  /**
   * The next time at which the structure will become vulnerable. Or the start time of the current window if current time is between this and vulnerableEndTime.
   * @type {string}
   * @memberof GetSovereigntyStructures200Ok
   */
  vulnerable_start_time?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetStatusOk
 */
export interface GetStatusOk {
  /**
   * Current online player count
   * @type {number}
   * @memberof GetStatusOk
   */
  players: number;
  /**
   * Running version as string
   * @type {string}
   * @memberof GetStatusOk
   */
  server_version: string;
  /**
   * Server start timestamp
   * @type {string}
   * @memberof GetStatusOk
   */
  start_time: string;
  /**
   * If the server is in VIP mode
   * @type {boolean}
   * @memberof GetStatusOk
   */
  vip?: boolean;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseAncestries200Ok
 */
export interface GetUniverseAncestries200Ok {
  /**
   * The bloodline associated with this ancestry
   * @type {number}
   * @memberof GetUniverseAncestries200Ok
   */
  bloodline_id: number;
  /**
   * description string
   * @type {string}
   * @memberof GetUniverseAncestries200Ok
   */
  description: string;
  /**
   * icon_id integer
   * @type {number}
   * @memberof GetUniverseAncestries200Ok
   */
  icon_id?: number;
  /**
   * id integer
   * @type {number}
   * @memberof GetUniverseAncestries200Ok
   */
  id: number;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseAncestries200Ok
   */
  name: string;
  /**
   * short_description string
   * @type {string}
   * @memberof GetUniverseAncestries200Ok
   */
  short_description?: string;
}
/**
 * Not found
 * @export
 * @interface GetUniverseAsteroidBeltsAsteroidBeltIdNotFound
 */
export interface GetUniverseAsteroidBeltsAsteroidBeltIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseAsteroidBeltsAsteroidBeltIdOk
 */
export interface GetUniverseAsteroidBeltsAsteroidBeltIdOk {
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdOk
   */
  name: string;
  /**
   *
   * @type {GetUniverseAsteroidBeltsAsteroidBeltIdPosition}
   * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdOk
   */
  position: GetUniverseAsteroidBeltsAsteroidBeltIdPosition;
  /**
   * The solar system this asteroid belt is in
   * @type {number}
   * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdOk
   */
  system_id: number;
}
/**
 * position object
 * @export
 * @interface GetUniverseAsteroidBeltsAsteroidBeltIdPosition
 */
export interface GetUniverseAsteroidBeltsAsteroidBeltIdPosition {
  /**
   * x number
   * @type {number}
   * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdPosition
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdPosition
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdPosition
   */
  z: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseBloodlines200Ok
 */
export interface GetUniverseBloodlines200Ok {
  /**
   * bloodline_id integer
   * @type {number}
   * @memberof GetUniverseBloodlines200Ok
   */
  bloodline_id: number;
  /**
   * charisma integer
   * @type {number}
   * @memberof GetUniverseBloodlines200Ok
   */
  charisma: number;
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetUniverseBloodlines200Ok
   */
  corporation_id: number;
  /**
   * description string
   * @type {string}
   * @memberof GetUniverseBloodlines200Ok
   */
  description: string;
  /**
   * intelligence integer
   * @type {number}
   * @memberof GetUniverseBloodlines200Ok
   */
  intelligence: number;
  /**
   * memory integer
   * @type {number}
   * @memberof GetUniverseBloodlines200Ok
   */
  memory: number;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseBloodlines200Ok
   */
  name: string;
  /**
   * perception integer
   * @type {number}
   * @memberof GetUniverseBloodlines200Ok
   */
  perception: number;
  /**
   * race_id integer
   * @type {number}
   * @memberof GetUniverseBloodlines200Ok
   */
  race_id: number;
  /**
   * ship_type_id integer
   * @type {number}
   * @memberof GetUniverseBloodlines200Ok
   */
  ship_type_id: number | null;
  /**
   * willpower integer
   * @type {number}
   * @memberof GetUniverseBloodlines200Ok
   */
  willpower: number;
}
/**
 * Not found
 * @export
 * @interface GetUniverseCategoriesCategoryIdNotFound
 */
export interface GetUniverseCategoriesCategoryIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniverseCategoriesCategoryIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseCategoriesCategoryIdOk
 */
export interface GetUniverseCategoriesCategoryIdOk {
  /**
   * category_id integer
   * @type {number}
   * @memberof GetUniverseCategoriesCategoryIdOk
   */
  category_id: number;
  /**
   * groups array
   * @type {Array<number>}
   * @memberof GetUniverseCategoriesCategoryIdOk
   */
  groups: Array<number>;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseCategoriesCategoryIdOk
   */
  name: string;
  /**
   * published boolean
   * @type {boolean}
   * @memberof GetUniverseCategoriesCategoryIdOk
   */
  published: boolean;
}
/**
 * Not found
 * @export
 * @interface GetUniverseConstellationsConstellationIdNotFound
 */
export interface GetUniverseConstellationsConstellationIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniverseConstellationsConstellationIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseConstellationsConstellationIdOk
 */
export interface GetUniverseConstellationsConstellationIdOk {
  /**
   * constellation_id integer
   * @type {number}
   * @memberof GetUniverseConstellationsConstellationIdOk
   */
  constellation_id: number;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseConstellationsConstellationIdOk
   */
  name: string;
  /**
   *
   * @type {GetUniverseConstellationsConstellationIdPosition}
   * @memberof GetUniverseConstellationsConstellationIdOk
   */
  position: GetUniverseConstellationsConstellationIdPosition;
  /**
   * The region this constellation is in
   * @type {number}
   * @memberof GetUniverseConstellationsConstellationIdOk
   */
  region_id: number;
  /**
   * systems array
   * @type {Array<number>}
   * @memberof GetUniverseConstellationsConstellationIdOk
   */
  systems: Array<number>;
}
/**
 * position object
 * @export
 * @interface GetUniverseConstellationsConstellationIdPosition
 */
export interface GetUniverseConstellationsConstellationIdPosition {
  /**
   * x number
   * @type {number}
   * @memberof GetUniverseConstellationsConstellationIdPosition
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof GetUniverseConstellationsConstellationIdPosition
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof GetUniverseConstellationsConstellationIdPosition
   */
  z: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseFactions200Ok
 */
export interface GetUniverseFactions200Ok {
  /**
   * corporation_id integer
   * @type {number}
   * @memberof GetUniverseFactions200Ok
   */
  corporation_id?: number;
  /**
   * description string
   * @type {string}
   * @memberof GetUniverseFactions200Ok
   */
  description: string;
  /**
   * faction_id integer
   * @type {number}
   * @memberof GetUniverseFactions200Ok
   */
  faction_id: number;
  /**
   * is_unique boolean
   * @type {boolean}
   * @memberof GetUniverseFactions200Ok
   */
  is_unique: boolean;
  /**
   * militia_corporation_id integer
   * @type {number}
   * @memberof GetUniverseFactions200Ok
   */
  militia_corporation_id?: number;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseFactions200Ok
   */
  name: string;
  /**
   * size_factor number
   * @type {number}
   * @memberof GetUniverseFactions200Ok
   */
  size_factor: number;
  /**
   * solar_system_id integer
   * @type {number}
   * @memberof GetUniverseFactions200Ok
   */
  solar_system_id?: number;
  /**
   * station_count integer
   * @type {number}
   * @memberof GetUniverseFactions200Ok
   */
  station_count: number;
  /**
   * station_system_count integer
   * @type {number}
   * @memberof GetUniverseFactions200Ok
   */
  station_system_count: number;
}
/**
 * Not found
 * @export
 * @interface GetUniverseGraphicsGraphicIdNotFound
 */
export interface GetUniverseGraphicsGraphicIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniverseGraphicsGraphicIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseGraphicsGraphicIdOk
 */
export interface GetUniverseGraphicsGraphicIdOk {
  /**
   * collision_file string
   * @type {string}
   * @memberof GetUniverseGraphicsGraphicIdOk
   */
  collision_file?: string;
  /**
   * graphic_file string
   * @type {string}
   * @memberof GetUniverseGraphicsGraphicIdOk
   */
  graphic_file?: string;
  /**
   * graphic_id integer
   * @type {number}
   * @memberof GetUniverseGraphicsGraphicIdOk
   */
  graphic_id: number;
  /**
   * icon_folder string
   * @type {string}
   * @memberof GetUniverseGraphicsGraphicIdOk
   */
  icon_folder?: string;
  /**
   * sof_dna string
   * @type {string}
   * @memberof GetUniverseGraphicsGraphicIdOk
   */
  sof_dna?: string;
  /**
   * sof_fation_name string
   * @type {string}
   * @memberof GetUniverseGraphicsGraphicIdOk
   */
  sof_fation_name?: string;
  /**
   * sof_hull_name string
   * @type {string}
   * @memberof GetUniverseGraphicsGraphicIdOk
   */
  sof_hull_name?: string;
  /**
   * sof_race_name string
   * @type {string}
   * @memberof GetUniverseGraphicsGraphicIdOk
   */
  sof_race_name?: string;
}
/**
 * Not found
 * @export
 * @interface GetUniverseGroupsGroupIdNotFound
 */
export interface GetUniverseGroupsGroupIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniverseGroupsGroupIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseGroupsGroupIdOk
 */
export interface GetUniverseGroupsGroupIdOk {
  /**
   * category_id integer
   * @type {number}
   * @memberof GetUniverseGroupsGroupIdOk
   */
  category_id: number;
  /**
   * group_id integer
   * @type {number}
   * @memberof GetUniverseGroupsGroupIdOk
   */
  group_id: number;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseGroupsGroupIdOk
   */
  name: string;
  /**
   * published boolean
   * @type {boolean}
   * @memberof GetUniverseGroupsGroupIdOk
   */
  published: boolean;
  /**
   * types array
   * @type {Array<number>}
   * @memberof GetUniverseGroupsGroupIdOk
   */
  types: Array<number>;
}
/**
 * Not found
 * @export
 * @interface GetUniverseMoonsMoonIdNotFound
 */
export interface GetUniverseMoonsMoonIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniverseMoonsMoonIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseMoonsMoonIdOk
 */
export interface GetUniverseMoonsMoonIdOk {
  /**
   * moon_id integer
   * @type {number}
   * @memberof GetUniverseMoonsMoonIdOk
   */
  moon_id: number;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseMoonsMoonIdOk
   */
  name: string;
  /**
   *
   * @type {GetUniverseMoonsMoonIdPosition}
   * @memberof GetUniverseMoonsMoonIdOk
   */
  position: GetUniverseMoonsMoonIdPosition;
  /**
   * The solar system this moon is in
   * @type {number}
   * @memberof GetUniverseMoonsMoonIdOk
   */
  system_id: number;
}
/**
 * position object
 * @export
 * @interface GetUniverseMoonsMoonIdPosition
 */
export interface GetUniverseMoonsMoonIdPosition {
  /**
   * x number
   * @type {number}
   * @memberof GetUniverseMoonsMoonIdPosition
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof GetUniverseMoonsMoonIdPosition
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof GetUniverseMoonsMoonIdPosition
   */
  z: number;
}
/**
 * Not found
 * @export
 * @interface GetUniversePlanetsPlanetIdNotFound
 */
export interface GetUniversePlanetsPlanetIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniversePlanetsPlanetIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniversePlanetsPlanetIdOk
 */
export interface GetUniversePlanetsPlanetIdOk {
  /**
   * name string
   * @type {string}
   * @memberof GetUniversePlanetsPlanetIdOk
   */
  name: string;
  /**
   * planet_id integer
   * @type {number}
   * @memberof GetUniversePlanetsPlanetIdOk
   */
  planet_id: number;
  /**
   *
   * @type {GetUniversePlanetsPlanetIdPosition}
   * @memberof GetUniversePlanetsPlanetIdOk
   */
  position: GetUniversePlanetsPlanetIdPosition;
  /**
   * The solar system this planet is in
   * @type {number}
   * @memberof GetUniversePlanetsPlanetIdOk
   */
  system_id: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetUniversePlanetsPlanetIdOk
   */
  type_id: number;
}
/**
 * position object
 * @export
 * @interface GetUniversePlanetsPlanetIdPosition
 */
export interface GetUniversePlanetsPlanetIdPosition {
  /**
   * x number
   * @type {number}
   * @memberof GetUniversePlanetsPlanetIdPosition
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof GetUniversePlanetsPlanetIdPosition
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof GetUniversePlanetsPlanetIdPosition
   */
  z: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseRaces200Ok
 */
export interface GetUniverseRaces200Ok {
  /**
   * The alliance generally associated with this race
   * @type {number}
   * @memberof GetUniverseRaces200Ok
   */
  alliance_id: number;
  /**
   * description string
   * @type {string}
   * @memberof GetUniverseRaces200Ok
   */
  description: string;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseRaces200Ok
   */
  name: string;
  /**
   * race_id integer
   * @type {number}
   * @memberof GetUniverseRaces200Ok
   */
  race_id: number;
}
/**
 * Not found
 * @export
 * @interface GetUniverseRegionsRegionIdNotFound
 */
export interface GetUniverseRegionsRegionIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniverseRegionsRegionIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseRegionsRegionIdOk
 */
export interface GetUniverseRegionsRegionIdOk {
  /**
   * constellations array
   * @type {Array<number>}
   * @memberof GetUniverseRegionsRegionIdOk
   */
  constellations: Array<number>;
  /**
   * description string
   * @type {string}
   * @memberof GetUniverseRegionsRegionIdOk
   */
  description?: string;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseRegionsRegionIdOk
   */
  name: string;
  /**
   * region_id integer
   * @type {number}
   * @memberof GetUniverseRegionsRegionIdOk
   */
  region_id: number;
}
/**
 * Schematic not found
 * @export
 * @interface GetUniverseSchematicsSchematicIdNotFound
 */
export interface GetUniverseSchematicsSchematicIdNotFound {
  /**
   * error message
   * @type {string}
   * @memberof GetUniverseSchematicsSchematicIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseSchematicsSchematicIdOk
 */
export interface GetUniverseSchematicsSchematicIdOk {
  /**
   * Time in seconds to process a run
   * @type {number}
   * @memberof GetUniverseSchematicsSchematicIdOk
   */
  cycle_time: number;
  /**
   * schematic_name string
   * @type {string}
   * @memberof GetUniverseSchematicsSchematicIdOk
   */
  schematic_name: string;
}
/**
 * destination object
 * @export
 * @interface GetUniverseStargatesStargateIdDestination
 */
export interface GetUniverseStargatesStargateIdDestination {
  /**
   * The stargate this stargate connects to
   * @type {number}
   * @memberof GetUniverseStargatesStargateIdDestination
   */
  stargate_id: number;
  /**
   * The solar system this stargate connects to
   * @type {number}
   * @memberof GetUniverseStargatesStargateIdDestination
   */
  system_id: number;
}
/**
 * Not found
 * @export
 * @interface GetUniverseStargatesStargateIdNotFound
 */
export interface GetUniverseStargatesStargateIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniverseStargatesStargateIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseStargatesStargateIdOk
 */
export interface GetUniverseStargatesStargateIdOk {
  /**
   *
   * @type {GetUniverseStargatesStargateIdDestination}
   * @memberof GetUniverseStargatesStargateIdOk
   */
  destination: GetUniverseStargatesStargateIdDestination;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseStargatesStargateIdOk
   */
  name: string;
  /**
   *
   * @type {GetUniverseStargatesStargateIdPosition}
   * @memberof GetUniverseStargatesStargateIdOk
   */
  position: GetUniverseStargatesStargateIdPosition;
  /**
   * stargate_id integer
   * @type {number}
   * @memberof GetUniverseStargatesStargateIdOk
   */
  stargate_id: number;
  /**
   * The solar system this stargate is in
   * @type {number}
   * @memberof GetUniverseStargatesStargateIdOk
   */
  system_id: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetUniverseStargatesStargateIdOk
   */
  type_id: number;
}
/**
 * position object
 * @export
 * @interface GetUniverseStargatesStargateIdPosition
 */
export interface GetUniverseStargatesStargateIdPosition {
  /**
   * x number
   * @type {number}
   * @memberof GetUniverseStargatesStargateIdPosition
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof GetUniverseStargatesStargateIdPosition
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof GetUniverseStargatesStargateIdPosition
   */
  z: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseStarsStarIdOk
 */
export interface GetUniverseStarsStarIdOk {
  /**
   * Age of star in years
   * @type {number}
   * @memberof GetUniverseStarsStarIdOk
   */
  age: number;
  /**
   * luminosity number
   * @type {number}
   * @memberof GetUniverseStarsStarIdOk
   */
  luminosity: number;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseStarsStarIdOk
   */
  name: string;
  /**
   * radius integer
   * @type {number}
   * @memberof GetUniverseStarsStarIdOk
   */
  radius: number;
  /**
   * solar_system_id integer
   * @type {number}
   * @memberof GetUniverseStarsStarIdOk
   */
  solar_system_id: number;
  /**
   * spectral_class string
   * @type {string}
   * @memberof GetUniverseStarsStarIdOk
   */
  spectral_class: GetUniverseStarsStarIdOkSpectralClassEnum;
  /**
   * temperature integer
   * @type {number}
   * @memberof GetUniverseStarsStarIdOk
   */
  temperature: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetUniverseStarsStarIdOk
   */
  type_id: number;
}

export const GetUniverseStarsStarIdOkSpectralClassEnum = {
  K2_V: "K2 V",
  K4_V: "K4 V",
  G2_V: "G2 V",
  G8_V: "G8 V",
  M7_V: "M7 V",
  K7_V: "K7 V",
  M2_V: "M2 V",
  K5_V: "K5 V",
  M3_V: "M3 V",
  G0_V: "G0 V",
  G7_V: "G7 V",
  G3_V: "G3 V",
  F9_V: "F9 V",
  G5_V: "G5 V",
  F6_V: "F6 V",
  K8_V: "K8 V",
  K9_V: "K9 V",
  K6_V: "K6 V",
  G9_V: "G9 V",
  G6_V: "G6 V",
  G4_VI: "G4 VI",
  G4_V: "G4 V",
  F8_V: "F8 V",
  F2_V: "F2 V",
  F1_V: "F1 V",
  K3_V: "K3 V",
  F0_VI: "F0 VI",
  G1_VI: "G1 VI",
  G0_VI: "G0 VI",
  K1_V: "K1 V",
  M4_V: "M4 V",
  M1_V: "M1 V",
  M6_V: "M6 V",
  M0_V: "M0 V",
  K2_IV: "K2 IV",
  G2_VI: "G2 VI",
  K0_V: "K0 V",
  K5_IV: "K5 IV",
  F5_VI: "F5 VI",
  G6_VI: "G6 VI",
  F6_VI: "F6 VI",
  F2_IV: "F2 IV",
  G3_VI: "G3 VI",
  M8_V: "M8 V",
  F1_VI: "F1 VI",
  K1_IV: "K1 IV",
  F7_V: "F7 V",
  G5_VI: "G5 VI",
  M5_V: "M5 V",
  G7_VI: "G7 VI",
  F5_V: "F5 V",
  F4_VI: "F4 VI",
  F8_VI: "F8 VI",
  K3_IV: "K3 IV",
  F4_IV: "F4 IV",
  F0_V: "F0 V",
  G7_IV: "G7 IV",
  G8_VI: "G8 VI",
  F2_VI: "F2 VI",
  F4_V: "F4 V",
  F7_VI: "F7 VI",
  F3_V: "F3 V",
  G1_V: "G1 V",
  G9_VI: "G9 VI",
  F3_IV: "F3 IV",
  F9_VI: "F9 VI",
  M9_V: "M9 V",
  K0_IV: "K0 IV",
  F1_IV: "F1 IV",
  G4_IV: "G4 IV",
  F3_VI: "F3 VI",
  K4_IV: "K4 IV",
  G5_IV: "G5 IV",
  G3_IV: "G3 IV",
  G1_IV: "G1 IV",
  K7_IV: "K7 IV",
  G0_IV: "G0 IV",
  K6_IV: "K6 IV",
  K9_IV: "K9 IV",
  G2_IV: "G2 IV",
  F9_IV: "F9 IV",
  F0_IV: "F0 IV",
  K8_IV: "K8 IV",
  G8_IV: "G8 IV",
  F6_IV: "F6 IV",
  F5_IV: "F5 IV",
  A0: "A0",
  A0_IV: "A0IV",
  A0_IV2: "A0IV2",
} as const;

export type GetUniverseStarsStarIdOkSpectralClassEnum =
  typeof GetUniverseStarsStarIdOkSpectralClassEnum[keyof typeof GetUniverseStarsStarIdOkSpectralClassEnum];

/**
 * Not found
 * @export
 * @interface GetUniverseStationsStationIdNotFound
 */
export interface GetUniverseStationsStationIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniverseStationsStationIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseStationsStationIdOk
 */
export interface GetUniverseStationsStationIdOk {
  /**
   * max_dockable_ship_volume number
   * @type {number}
   * @memberof GetUniverseStationsStationIdOk
   */
  max_dockable_ship_volume: number;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseStationsStationIdOk
   */
  name: string;
  /**
   * office_rental_cost number
   * @type {number}
   * @memberof GetUniverseStationsStationIdOk
   */
  office_rental_cost: number;
  /**
   * ID of the corporation that controls this station
   * @type {number}
   * @memberof GetUniverseStationsStationIdOk
   */
  owner?: number;
  /**
   *
   * @type {GetUniverseStationsStationIdPosition}
   * @memberof GetUniverseStationsStationIdOk
   */
  position: GetUniverseStationsStationIdPosition;
  /**
   * race_id integer
   * @type {number}
   * @memberof GetUniverseStationsStationIdOk
   */
  race_id?: number;
  /**
   * reprocessing_efficiency number
   * @type {number}
   * @memberof GetUniverseStationsStationIdOk
   */
  reprocessing_efficiency: number;
  /**
   * reprocessing_stations_take number
   * @type {number}
   * @memberof GetUniverseStationsStationIdOk
   */
  reprocessing_stations_take: number;
  /**
   * services array
   * @type {Array<string>}
   * @memberof GetUniverseStationsStationIdOk
   */
  services: Array<GetUniverseStationsStationIdOkServicesEnum>;
  /**
   * station_id integer
   * @type {number}
   * @memberof GetUniverseStationsStationIdOk
   */
  station_id: number;
  /**
   * The solar system this station is in
   * @type {number}
   * @memberof GetUniverseStationsStationIdOk
   */
  system_id: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetUniverseStationsStationIdOk
   */
  type_id: number;
}

export const GetUniverseStationsStationIdOkServicesEnum = {
  BOUNTY_MISSIONS: "bounty-missions",
  ASSASINATION_MISSIONS: "assasination-missions",
  COURIER_MISSIONS: "courier-missions",
  INTERBUS: "interbus",
  REPROCESSING_PLANT: "reprocessing-plant",
  REFINERY: "refinery",
  MARKET: "market",
  BLACK_MARKET: "black-market",
  STOCK_EXCHANGE: "stock-exchange",
  CLONING: "cloning",
  SURGERY: "surgery",
  DNA_THERAPY: "dna-therapy",
  REPAIR_FACILITIES: "repair-facilities",
  FACTORY: "factory",
  LABRATORY: "labratory",
  GAMBLING: "gambling",
  FITTING: "fitting",
  PAINTSHOP: "paintshop",
  NEWS: "news",
  STORAGE: "storage",
  INSURANCE: "insurance",
  DOCKING: "docking",
  OFFICE_RENTAL: "office-rental",
  JUMP_CLONE_FACILITY: "jump-clone-facility",
  LOYALTY_POINT_STORE: "loyalty-point-store",
  NAVY_OFFICES: "navy-offices",
  SECURITY_OFFICES: "security-offices",
} as const;

export type GetUniverseStationsStationIdOkServicesEnum =
  typeof GetUniverseStationsStationIdOkServicesEnum[keyof typeof GetUniverseStationsStationIdOkServicesEnum];

/**
 * position object
 * @export
 * @interface GetUniverseStationsStationIdPosition
 */
export interface GetUniverseStationsStationIdPosition {
  /**
   * x number
   * @type {number}
   * @memberof GetUniverseStationsStationIdPosition
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof GetUniverseStationsStationIdPosition
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof GetUniverseStationsStationIdPosition
   */
  z: number;
}
/**
 * Not found
 * @export
 * @interface GetUniverseStructuresStructureIdNotFound
 */
export interface GetUniverseStructuresStructureIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniverseStructuresStructureIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseStructuresStructureIdOk
 */
export interface GetUniverseStructuresStructureIdOk {
  /**
   * The full name of the structure
   * @type {string}
   * @memberof GetUniverseStructuresStructureIdOk
   */
  name: string;
  /**
   * The ID of the corporation who owns this particular structure
   * @type {number}
   * @memberof GetUniverseStructuresStructureIdOk
   */
  owner_id: number;
  /**
   *
   * @type {GetUniverseStructuresStructureIdPosition}
   * @memberof GetUniverseStructuresStructureIdOk
   */
  position?: GetUniverseStructuresStructureIdPosition;
  /**
   * solar_system_id integer
   * @type {number}
   * @memberof GetUniverseStructuresStructureIdOk
   */
  solar_system_id: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetUniverseStructuresStructureIdOk
   */
  type_id?: number;
}
/**
 * Coordinates of the structure in Cartesian space relative to the Sun, in metres.
 * @export
 * @interface GetUniverseStructuresStructureIdPosition
 */
export interface GetUniverseStructuresStructureIdPosition {
  /**
   * x number
   * @type {number}
   * @memberof GetUniverseStructuresStructureIdPosition
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof GetUniverseStructuresStructureIdPosition
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof GetUniverseStructuresStructureIdPosition
   */
  z: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseSystemJumps200Ok
 */
export interface GetUniverseSystemJumps200Ok {
  /**
   * ship_jumps integer
   * @type {number}
   * @memberof GetUniverseSystemJumps200Ok
   */
  ship_jumps: number;
  /**
   * system_id integer
   * @type {number}
   * @memberof GetUniverseSystemJumps200Ok
   */
  system_id: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseSystemKills200Ok
 */
export interface GetUniverseSystemKills200Ok {
  /**
   * Number of NPC ships killed in this system
   * @type {number}
   * @memberof GetUniverseSystemKills200Ok
   */
  npc_kills: number;
  /**
   * Number of pods killed in this system
   * @type {number}
   * @memberof GetUniverseSystemKills200Ok
   */
  pod_kills: number;
  /**
   * Number of player ships killed in this system
   * @type {number}
   * @memberof GetUniverseSystemKills200Ok
   */
  ship_kills: number;
  /**
   * system_id integer
   * @type {number}
   * @memberof GetUniverseSystemKills200Ok
   */
  system_id: number;
}
/**
 * Not found
 * @export
 * @interface GetUniverseSystemsSystemIdNotFound
 */
export interface GetUniverseSystemsSystemIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniverseSystemsSystemIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseSystemsSystemIdOk
 */
export interface GetUniverseSystemsSystemIdOk {
  /**
   * The constellation this solar system is in
   * @type {number}
   * @memberof GetUniverseSystemsSystemIdOk
   */
  constellation_id: number;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseSystemsSystemIdOk
   */
  name: string;
  /**
   * planets array
   * @type {Array<GetUniverseSystemsSystemIdPlanet>}
   * @memberof GetUniverseSystemsSystemIdOk
   */
  planets?: Array<GetUniverseSystemsSystemIdPlanet>;
  /**
   *
   * @type {GetUniverseSystemsSystemIdPosition}
   * @memberof GetUniverseSystemsSystemIdOk
   */
  position: GetUniverseSystemsSystemIdPosition;
  /**
   * security_class string
   * @type {string}
   * @memberof GetUniverseSystemsSystemIdOk
   */
  security_class?: string;
  /**
   * security_status number
   * @type {number}
   * @memberof GetUniverseSystemsSystemIdOk
   */
  security_status: number;
  /**
   * star_id integer
   * @type {number}
   * @memberof GetUniverseSystemsSystemIdOk
   */
  star_id?: number;
  /**
   * stargates array
   * @type {Array<number>}
   * @memberof GetUniverseSystemsSystemIdOk
   */
  stargates?: Array<number>;
  /**
   * stations array
   * @type {Array<number>}
   * @memberof GetUniverseSystemsSystemIdOk
   */
  stations?: Array<number>;
  /**
   * system_id integer
   * @type {number}
   * @memberof GetUniverseSystemsSystemIdOk
   */
  system_id: number;
}
/**
 * planet object
 * @export
 * @interface GetUniverseSystemsSystemIdPlanet
 */
export interface GetUniverseSystemsSystemIdPlanet {
  /**
   * asteroid_belts array
   * @type {Array<number>}
   * @memberof GetUniverseSystemsSystemIdPlanet
   */
  asteroid_belts?: Array<number>;
  /**
   * moons array
   * @type {Array<number>}
   * @memberof GetUniverseSystemsSystemIdPlanet
   */
  moons?: Array<number>;
  /**
   * planet_id integer
   * @type {number}
   * @memberof GetUniverseSystemsSystemIdPlanet
   */
  planet_id: number;
}
/**
 * position object
 * @export
 * @interface GetUniverseSystemsSystemIdPosition
 */
export interface GetUniverseSystemsSystemIdPosition {
  /**
   * x number
   * @type {number}
   * @memberof GetUniverseSystemsSystemIdPosition
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof GetUniverseSystemsSystemIdPosition
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof GetUniverseSystemsSystemIdPosition
   */
  z: number;
}
/**
 * dogma_attribute object
 * @export
 * @interface GetUniverseTypesTypeIdDogmaAttribute
 */
export interface GetUniverseTypesTypeIdDogmaAttribute {
  /**
   * attribute_id integer
   * @type {number}
   * @memberof GetUniverseTypesTypeIdDogmaAttribute
   */
  attribute_id: number;
  /**
   * value number
   * @type {number}
   * @memberof GetUniverseTypesTypeIdDogmaAttribute
   */
  value: number;
}
/**
 * dogma_effect object
 * @export
 * @interface GetUniverseTypesTypeIdDogmaEffect
 */
export interface GetUniverseTypesTypeIdDogmaEffect {
  /**
   * effect_id integer
   * @type {number}
   * @memberof GetUniverseTypesTypeIdDogmaEffect
   */
  effect_id: number;
  /**
   * is_default boolean
   * @type {boolean}
   * @memberof GetUniverseTypesTypeIdDogmaEffect
   */
  is_default: boolean;
}
/**
 * Not found
 * @export
 * @interface GetUniverseTypesTypeIdNotFound
 */
export interface GetUniverseTypesTypeIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof GetUniverseTypesTypeIdNotFound
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetUniverseTypesTypeIdOk
 */
export interface GetUniverseTypesTypeIdOk {
  /**
   * capacity number
   * @type {number}
   * @memberof GetUniverseTypesTypeIdOk
   */
  capacity?: number;
  /**
   * description string
   * @type {string}
   * @memberof GetUniverseTypesTypeIdOk
   */
  description: string;
  /**
   * dogma_attributes array
   * @type {Array<GetUniverseTypesTypeIdDogmaAttribute>}
   * @memberof GetUniverseTypesTypeIdOk
   */
  dogma_attributes?: Array<GetUniverseTypesTypeIdDogmaAttribute>;
  /**
   * dogma_effects array
   * @type {Array<GetUniverseTypesTypeIdDogmaEffect>}
   * @memberof GetUniverseTypesTypeIdOk
   */
  dogma_effects?: Array<GetUniverseTypesTypeIdDogmaEffect>;
  /**
   * graphic_id integer
   * @type {number}
   * @memberof GetUniverseTypesTypeIdOk
   */
  graphic_id?: number;
  /**
   * group_id integer
   * @type {number}
   * @memberof GetUniverseTypesTypeIdOk
   */
  group_id: number;
  /**
   * icon_id integer
   * @type {number}
   * @memberof GetUniverseTypesTypeIdOk
   */
  icon_id?: number;
  /**
   * This only exists for types that can be put on the market
   * @type {number}
   * @memberof GetUniverseTypesTypeIdOk
   */
  market_group_id?: number;
  /**
   * mass number
   * @type {number}
   * @memberof GetUniverseTypesTypeIdOk
   */
  mass?: number;
  /**
   * name string
   * @type {string}
   * @memberof GetUniverseTypesTypeIdOk
   */
  name: string;
  /**
   * packaged_volume number
   * @type {number}
   * @memberof GetUniverseTypesTypeIdOk
   */
  packaged_volume?: number;
  /**
   * portion_size integer
   * @type {number}
   * @memberof GetUniverseTypesTypeIdOk
   */
  portion_size?: number;
  /**
   * published boolean
   * @type {boolean}
   * @memberof GetUniverseTypesTypeIdOk
   */
  published: boolean;
  /**
   * radius number
   * @type {number}
   * @memberof GetUniverseTypesTypeIdOk
   */
  radius?: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof GetUniverseTypesTypeIdOk
   */
  type_id: number;
  /**
   * volume number
   * @type {number}
   * @memberof GetUniverseTypesTypeIdOk
   */
  volume?: number;
}
/**
 * The aggressor corporation or alliance that declared this war, only contains either corporation_id or alliance_id
 * @export
 * @interface GetWarsWarIdAggressor
 */
export interface GetWarsWarIdAggressor {
  /**
   * Alliance ID if and only if the aggressor is an alliance
   * @type {number}
   * @memberof GetWarsWarIdAggressor
   */
  alliance_id?: number;
  /**
   * Corporation ID if and only if the aggressor is a corporation
   * @type {number}
   * @memberof GetWarsWarIdAggressor
   */
  corporation_id?: number;
  /**
   * ISK value of ships the aggressor has destroyed
   * @type {number}
   * @memberof GetWarsWarIdAggressor
   */
  isk_destroyed: number;
  /**
   * The number of ships the aggressor has killed
   * @type {number}
   * @memberof GetWarsWarIdAggressor
   */
  ships_killed: number;
}
/**
 * ally object
 * @export
 * @interface GetWarsWarIdAlly
 */
export interface GetWarsWarIdAlly {
  /**
   * Alliance ID if and only if this ally is an alliance
   * @type {number}
   * @memberof GetWarsWarIdAlly
   */
  alliance_id?: number;
  /**
   * Corporation ID if and only if this ally is a corporation
   * @type {number}
   * @memberof GetWarsWarIdAlly
   */
  corporation_id?: number;
}
/**
 * The defending corporation or alliance that declared this war, only contains either corporation_id or alliance_id
 * @export
 * @interface GetWarsWarIdDefender
 */
export interface GetWarsWarIdDefender {
  /**
   * Alliance ID if and only if the defender is an alliance
   * @type {number}
   * @memberof GetWarsWarIdDefender
   */
  alliance_id?: number;
  /**
   * Corporation ID if and only if the defender is a corporation
   * @type {number}
   * @memberof GetWarsWarIdDefender
   */
  corporation_id?: number;
  /**
   * ISK value of ships the defender has killed
   * @type {number}
   * @memberof GetWarsWarIdDefender
   */
  isk_destroyed: number;
  /**
   * The number of ships the defender has killed
   * @type {number}
   * @memberof GetWarsWarIdDefender
   */
  ships_killed: number;
}
/**
 * 200 ok object
 * @export
 * @interface GetWarsWarIdKillmails200Ok
 */
export interface GetWarsWarIdKillmails200Ok {
  /**
   * A hash of this killmail
   * @type {string}
   * @memberof GetWarsWarIdKillmails200Ok
   */
  killmail_hash: string;
  /**
   * ID of this killmail
   * @type {number}
   * @memberof GetWarsWarIdKillmails200Ok
   */
  killmail_id: number;
}
/**
 * Unprocessable entity
 * @export
 * @interface GetWarsWarIdKillmailsUnprocessableEntity
 */
export interface GetWarsWarIdKillmailsUnprocessableEntity {
  /**
   * Unprocessable entity message
   * @type {string}
   * @memberof GetWarsWarIdKillmailsUnprocessableEntity
   */
  error?: string;
}
/**
 * 200 ok object
 * @export
 * @interface GetWarsWarIdOk
 */
export interface GetWarsWarIdOk {
  /**
   *
   * @type {GetWarsWarIdAggressor}
   * @memberof GetWarsWarIdOk
   */
  aggressor: GetWarsWarIdAggressor;
  /**
   * allied corporations or alliances, each object contains either corporation_id or alliance_id
   * @type {Array<GetWarsWarIdAlly>}
   * @memberof GetWarsWarIdOk
   */
  allies?: Array<GetWarsWarIdAlly>;
  /**
   * Time that the war was declared
   * @type {string}
   * @memberof GetWarsWarIdOk
   */
  declared: string;
  /**
   *
   * @type {GetWarsWarIdDefender}
   * @memberof GetWarsWarIdOk
   */
  defender: GetWarsWarIdDefender;
  /**
   * Time the war ended and shooting was no longer allowed
   * @type {string}
   * @memberof GetWarsWarIdOk
   */
  finished?: string;
  /**
   * ID of the specified war
   * @type {number}
   * @memberof GetWarsWarIdOk
   */
  id: number;
  /**
   * Was the war declared mutual by both parties
   * @type {boolean}
   * @memberof GetWarsWarIdOk
   */
  mutual: boolean;
  /**
   * Is the war currently open for allies or not
   * @type {boolean}
   * @memberof GetWarsWarIdOk
   */
  open_for_allies: boolean;
  /**
   * Time the war was retracted but both sides could still shoot each other
   * @type {string}
   * @memberof GetWarsWarIdOk
   */
  retracted?: string;
  /**
   * Time when the war started and both sides could shoot each other
   * @type {string}
   * @memberof GetWarsWarIdOk
   */
  started?: string;
}
/**
 * Unprocessable entity
 * @export
 * @interface GetWarsWarIdUnprocessableEntity
 */
export interface GetWarsWarIdUnprocessableEntity {
  /**
   * Unprocessable entity message
   * @type {string}
   * @memberof GetWarsWarIdUnprocessableEntity
   */
  error?: string;
}
/**
 * Internal server error model
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError {
  /**
   * Internal server error message
   * @type {string}
   * @memberof InternalServerError
   */
  error: string;
}
/**
 * 200 ok object
 * @export
 * @interface PostCharactersAffiliation200Ok
 */
export interface PostCharactersAffiliation200Ok {
  /**
   * The character\'s alliance ID, if their corporation is in an alliance
   * @type {number}
   * @memberof PostCharactersAffiliation200Ok
   */
  alliance_id?: number;
  /**
   * The character\'s ID
   * @type {number}
   * @memberof PostCharactersAffiliation200Ok
   */
  character_id: number;
  /**
   * The character\'s corporation ID
   * @type {number}
   * @memberof PostCharactersAffiliation200Ok
   */
  corporation_id: number;
  /**
   * The character\'s faction ID, if their corporation is in a faction
   * @type {number}
   * @memberof PostCharactersAffiliation200Ok
   */
  faction_id?: number;
}
/**
 * 200 ok object
 * @export
 * @interface PostCharactersCharacterIdAssetsLocations200Ok
 */
export interface PostCharactersCharacterIdAssetsLocations200Ok {
  /**
   * item_id integer
   * @type {number}
   * @memberof PostCharactersCharacterIdAssetsLocations200Ok
   */
  item_id: number;
  /**
   *
   * @type {PostCharactersCharacterIdAssetsLocationsPosition}
   * @memberof PostCharactersCharacterIdAssetsLocations200Ok
   */
  position: PostCharactersCharacterIdAssetsLocationsPosition;
}
/**
 * position object
 * @export
 * @interface PostCharactersCharacterIdAssetsLocationsPosition
 */
export interface PostCharactersCharacterIdAssetsLocationsPosition {
  /**
   * x number
   * @type {number}
   * @memberof PostCharactersCharacterIdAssetsLocationsPosition
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof PostCharactersCharacterIdAssetsLocationsPosition
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof PostCharactersCharacterIdAssetsLocationsPosition
   */
  z: number;
}
/**
 * 200 ok object
 * @export
 * @interface PostCharactersCharacterIdAssetsNames200Ok
 */
export interface PostCharactersCharacterIdAssetsNames200Ok {
  /**
   * item_id integer
   * @type {number}
   * @memberof PostCharactersCharacterIdAssetsNames200Ok
   */
  item_id: number;
  /**
   * name string
   * @type {string}
   * @memberof PostCharactersCharacterIdAssetsNames200Ok
   */
  name: string;
}
/**
 * Error 520
 * @export
 * @interface PostCharactersCharacterIdContactsError520
 */
export interface PostCharactersCharacterIdContactsError520 {
  /**
   * Error 520 message
   * @type {string}
   * @memberof PostCharactersCharacterIdContactsError520
   */
  error?: string;
}
/**
 * 201 created object
 * @export
 * @interface PostCharactersCharacterIdFittingsCreated
 */
export interface PostCharactersCharacterIdFittingsCreated {
  /**
   * fitting_id integer
   * @type {number}
   * @memberof PostCharactersCharacterIdFittingsCreated
   */
  fitting_id: number;
}
/**
 * fitting object
 * @export
 * @interface PostCharactersCharacterIdFittingsFitting
 */
export interface PostCharactersCharacterIdFittingsFitting {
  /**
   * description string
   * @type {string}
   * @memberof PostCharactersCharacterIdFittingsFitting
   */
  description: string;
  /**
   * items array
   * @type {Array<PostCharactersCharacterIdFittingsItem>}
   * @memberof PostCharactersCharacterIdFittingsFitting
   */
  items: Array<PostCharactersCharacterIdFittingsItem>;
  /**
   * name string
   * @type {string}
   * @memberof PostCharactersCharacterIdFittingsFitting
   */
  name: string;
  /**
   * ship_type_id integer
   * @type {number}
   * @memberof PostCharactersCharacterIdFittingsFitting
   */
  ship_type_id: number;
}
/**
 * item object
 * @export
 * @interface PostCharactersCharacterIdFittingsItem
 */
export interface PostCharactersCharacterIdFittingsItem {
  /**
   * Fitting location for the item. Entries placed in \'Invalid\' will be discarded. If this leaves the fitting with nothing, it will cause an error.
   * @type {string}
   * @memberof PostCharactersCharacterIdFittingsItem
   */
  flag: PostCharactersCharacterIdFittingsItemFlagEnum;
  /**
   * quantity integer
   * @type {number}
   * @memberof PostCharactersCharacterIdFittingsItem
   */
  quantity: number;
  /**
   * type_id integer
   * @type {number}
   * @memberof PostCharactersCharacterIdFittingsItem
   */
  type_id: number;
}

export const PostCharactersCharacterIdFittingsItemFlagEnum = {
  CARGO: "Cargo",
  DRONE_BAY: "DroneBay",
  FIGHTER_BAY: "FighterBay",
  HI_SLOT0: "HiSlot0",
  HI_SLOT1: "HiSlot1",
  HI_SLOT2: "HiSlot2",
  HI_SLOT3: "HiSlot3",
  HI_SLOT4: "HiSlot4",
  HI_SLOT5: "HiSlot5",
  HI_SLOT6: "HiSlot6",
  HI_SLOT7: "HiSlot7",
  INVALID: "Invalid",
  LO_SLOT0: "LoSlot0",
  LO_SLOT1: "LoSlot1",
  LO_SLOT2: "LoSlot2",
  LO_SLOT3: "LoSlot3",
  LO_SLOT4: "LoSlot4",
  LO_SLOT5: "LoSlot5",
  LO_SLOT6: "LoSlot6",
  LO_SLOT7: "LoSlot7",
  MED_SLOT0: "MedSlot0",
  MED_SLOT1: "MedSlot1",
  MED_SLOT2: "MedSlot2",
  MED_SLOT3: "MedSlot3",
  MED_SLOT4: "MedSlot4",
  MED_SLOT5: "MedSlot5",
  MED_SLOT6: "MedSlot6",
  MED_SLOT7: "MedSlot7",
  RIG_SLOT0: "RigSlot0",
  RIG_SLOT1: "RigSlot1",
  RIG_SLOT2: "RigSlot2",
  SERVICE_SLOT0: "ServiceSlot0",
  SERVICE_SLOT1: "ServiceSlot1",
  SERVICE_SLOT2: "ServiceSlot2",
  SERVICE_SLOT3: "ServiceSlot3",
  SERVICE_SLOT4: "ServiceSlot4",
  SERVICE_SLOT5: "ServiceSlot5",
  SERVICE_SLOT6: "ServiceSlot6",
  SERVICE_SLOT7: "ServiceSlot7",
  SUB_SYSTEM_SLOT0: "SubSystemSlot0",
  SUB_SYSTEM_SLOT1: "SubSystemSlot1",
  SUB_SYSTEM_SLOT2: "SubSystemSlot2",
  SUB_SYSTEM_SLOT3: "SubSystemSlot3",
} as const;

export type PostCharactersCharacterIdFittingsItemFlagEnum =
  typeof PostCharactersCharacterIdFittingsItemFlagEnum[keyof typeof PostCharactersCharacterIdFittingsItemFlagEnum];

/**
 * Error 520
 * @export
 * @interface PostCharactersCharacterIdMailError520
 */
export interface PostCharactersCharacterIdMailError520 {
  /**
   * Error 520 message
   * @type {string}
   * @memberof PostCharactersCharacterIdMailError520
   */
  error?: string;
}
/**
 * label object
 * @export
 * @interface PostCharactersCharacterIdMailLabelsLabel
 */
export interface PostCharactersCharacterIdMailLabelsLabel {
  /**
   * Hexadecimal string representing label color, in RGB format
   * @type {string}
   * @memberof PostCharactersCharacterIdMailLabelsLabel
   */
  color?: PostCharactersCharacterIdMailLabelsLabelColorEnum;
  /**
   * name string
   * @type {string}
   * @memberof PostCharactersCharacterIdMailLabelsLabel
   */
  name: string;
}

export const PostCharactersCharacterIdMailLabelsLabelColorEnum = {
  _0000FE: "#0000fe",
  _006634: "#006634",
  _0099FF: "#0099ff",
  _00FF33: "#00ff33",
  _01FFFF: "#01ffff",
  _349800: "#349800",
  _660066: "#660066",
  _666666: "#666666",
  _999999: "#999999",
  _99FFFF: "#99ffff",
  _9A0000: "#9a0000",
  CCFF9A: "#ccff9a",
  E6E6E6: "#e6e6e6",
  FE0000: "#fe0000",
  FF6600: "#ff6600",
  FFFF01: "#ffff01",
  FFFFCD: "#ffffcd",
  FFFFFF: "#ffffff",
} as const;

export type PostCharactersCharacterIdMailLabelsLabelColorEnum =
  typeof PostCharactersCharacterIdMailLabelsLabelColorEnum[keyof typeof PostCharactersCharacterIdMailLabelsLabelColorEnum];

/**
 * mail object
 * @export
 * @interface PostCharactersCharacterIdMailMail
 */
export interface PostCharactersCharacterIdMailMail {
  /**
   * approved_cost integer
   * @type {number}
   * @memberof PostCharactersCharacterIdMailMail
   */
  approved_cost?: number;
  /**
   * body string
   * @type {string}
   * @memberof PostCharactersCharacterIdMailMail
   */
  body: string;
  /**
   * recipients array
   * @type {Array<PostCharactersCharacterIdMailRecipient>}
   * @memberof PostCharactersCharacterIdMailMail
   */
  recipients: Array<PostCharactersCharacterIdMailRecipient>;
  /**
   * subject string
   * @type {string}
   * @memberof PostCharactersCharacterIdMailMail
   */
  subject: string;
}
/**
 * recipient object
 * @export
 * @interface PostCharactersCharacterIdMailRecipient
 */
export interface PostCharactersCharacterIdMailRecipient {
  /**
   * recipient_id integer
   * @type {number}
   * @memberof PostCharactersCharacterIdMailRecipient
   */
  recipient_id: number;
  /**
   * recipient_type string
   * @type {string}
   * @memberof PostCharactersCharacterIdMailRecipient
   */
  recipient_type: PostCharactersCharacterIdMailRecipientRecipientTypeEnum;
}

export const PostCharactersCharacterIdMailRecipientRecipientTypeEnum = {
  ALLIANCE: "alliance",
  CHARACTER: "character",
  CORPORATION: "corporation",
  MAILING_LIST: "mailing_list",
} as const;

export type PostCharactersCharacterIdMailRecipientRecipientTypeEnum =
  typeof PostCharactersCharacterIdMailRecipientRecipientTypeEnum[keyof typeof PostCharactersCharacterIdMailRecipientRecipientTypeEnum];

/**
 * 200 ok object
 * @export
 * @interface PostCorporationsCorporationIdAssetsLocations200Ok
 */
export interface PostCorporationsCorporationIdAssetsLocations200Ok {
  /**
   * item_id integer
   * @type {number}
   * @memberof PostCorporationsCorporationIdAssetsLocations200Ok
   */
  item_id: number;
  /**
   *
   * @type {PostCorporationsCorporationIdAssetsLocationsPosition}
   * @memberof PostCorporationsCorporationIdAssetsLocations200Ok
   */
  position: PostCorporationsCorporationIdAssetsLocationsPosition;
}
/**
 * Not found
 * @export
 * @interface PostCorporationsCorporationIdAssetsLocationsNotFound
 */
export interface PostCorporationsCorporationIdAssetsLocationsNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof PostCorporationsCorporationIdAssetsLocationsNotFound
   */
  error?: string;
}
/**
 * position object
 * @export
 * @interface PostCorporationsCorporationIdAssetsLocationsPosition
 */
export interface PostCorporationsCorporationIdAssetsLocationsPosition {
  /**
   * x number
   * @type {number}
   * @memberof PostCorporationsCorporationIdAssetsLocationsPosition
   */
  x: number;
  /**
   * y number
   * @type {number}
   * @memberof PostCorporationsCorporationIdAssetsLocationsPosition
   */
  y: number;
  /**
   * z number
   * @type {number}
   * @memberof PostCorporationsCorporationIdAssetsLocationsPosition
   */
  z: number;
}
/**
 * 200 ok object
 * @export
 * @interface PostCorporationsCorporationIdAssetsNames200Ok
 */
export interface PostCorporationsCorporationIdAssetsNames200Ok {
  /**
   * item_id integer
   * @type {number}
   * @memberof PostCorporationsCorporationIdAssetsNames200Ok
   */
  item_id: number;
  /**
   * name string
   * @type {string}
   * @memberof PostCorporationsCorporationIdAssetsNames200Ok
   */
  name: string;
}
/**
 * Not found
 * @export
 * @interface PostCorporationsCorporationIdAssetsNamesNotFound
 */
export interface PostCorporationsCorporationIdAssetsNamesNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof PostCorporationsCorporationIdAssetsNamesNotFound
   */
  error?: string;
}
/**
 * invitation object
 * @export
 * @interface PostFleetsFleetIdMembersInvitation
 */
export interface PostFleetsFleetIdMembersInvitation {
  /**
   * The character you want to invite
   * @type {number}
   * @memberof PostFleetsFleetIdMembersInvitation
   */
  character_id: number;
  /**
   * If a character is invited with the `fleet_commander` role, neither `wing_id` or `squad_id` should be specified. If a character is invited with the `wing_commander` role, only `wing_id` should be specified. If a character is invited with the `squad_commander` role, both `wing_id` and `squad_id` should be specified. If a character is invited with the `squad_member` role, `wing_id` and `squad_id` should either both be specified or not specified at all. If they aren’t specified, the invited character will join any squad with available positions.
   * @type {string}
   * @memberof PostFleetsFleetIdMembersInvitation
   */
  role: PostFleetsFleetIdMembersInvitationRoleEnum;
  /**
   * squad_id integer
   * @type {number}
   * @memberof PostFleetsFleetIdMembersInvitation
   */
  squad_id?: number;
  /**
   * wing_id integer
   * @type {number}
   * @memberof PostFleetsFleetIdMembersInvitation
   */
  wing_id?: number;
}

export const PostFleetsFleetIdMembersInvitationRoleEnum = {
  FLEET_COMMANDER: "fleet_commander",
  WING_COMMANDER: "wing_commander",
  SQUAD_COMMANDER: "squad_commander",
  SQUAD_MEMBER: "squad_member",
} as const;

export type PostFleetsFleetIdMembersInvitationRoleEnum =
  typeof PostFleetsFleetIdMembersInvitationRoleEnum[keyof typeof PostFleetsFleetIdMembersInvitationRoleEnum];

/**
 * Not found
 * @export
 * @interface PostFleetsFleetIdMembersNotFound
 */
export interface PostFleetsFleetIdMembersNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof PostFleetsFleetIdMembersNotFound
   */
  error?: string;
}
/**
 * 422 unprocessable entity object
 * @export
 * @interface PostFleetsFleetIdMembersUnprocessableEntity
 */
export interface PostFleetsFleetIdMembersUnprocessableEntity {
  /**
   * error message
   * @type {string}
   * @memberof PostFleetsFleetIdMembersUnprocessableEntity
   */
  error?: string;
}
/**
 * 201 created object
 * @export
 * @interface PostFleetsFleetIdWingsCreated
 */
export interface PostFleetsFleetIdWingsCreated {
  /**
   * The wing_id of the newly created wing
   * @type {number}
   * @memberof PostFleetsFleetIdWingsCreated
   */
  wing_id: number;
}
/**
 * Not found
 * @export
 * @interface PostFleetsFleetIdWingsNotFound
 */
export interface PostFleetsFleetIdWingsNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof PostFleetsFleetIdWingsNotFound
   */
  error?: string;
}
/**
 * 201 created object
 * @export
 * @interface PostFleetsFleetIdWingsWingIdSquadsCreated
 */
export interface PostFleetsFleetIdWingsWingIdSquadsCreated {
  /**
   * The squad_id of the newly created squad
   * @type {number}
   * @memberof PostFleetsFleetIdWingsWingIdSquadsCreated
   */
  squad_id: number;
}
/**
 * Not found
 * @export
 * @interface PostFleetsFleetIdWingsWingIdSquadsNotFound
 */
export interface PostFleetsFleetIdWingsWingIdSquadsNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof PostFleetsFleetIdWingsWingIdSquadsNotFound
   */
  error?: string;
}
/**
 * new_mail object
 * @export
 * @interface PostUiOpenwindowNewmailNewMail
 */
export interface PostUiOpenwindowNewmailNewMail {
  /**
   * body string
   * @type {string}
   * @memberof PostUiOpenwindowNewmailNewMail
   */
  body: string;
  /**
   * recipients array
   * @type {Array<number>}
   * @memberof PostUiOpenwindowNewmailNewMail
   */
  recipients: Array<number>;
  /**
   * subject string
   * @type {string}
   * @memberof PostUiOpenwindowNewmailNewMail
   */
  subject: string;
  /**
   * to_corp_or_alliance_id integer
   * @type {number}
   * @memberof PostUiOpenwindowNewmailNewMail
   */
  to_corp_or_alliance_id?: number;
  /**
   * Corporations, alliances and mailing lists are all types of mailing groups. You may only send to one mailing group, at a time, so you may fill out either this field or the to_corp_or_alliance_ids field
   * @type {number}
   * @memberof PostUiOpenwindowNewmailNewMail
   */
  to_mailing_list_id?: number;
}
/**
 * Unprocessable entity
 * @export
 * @interface PostUiOpenwindowNewmailUnprocessableEntity
 */
export interface PostUiOpenwindowNewmailUnprocessableEntity {
  /**
   * Unprocessable entity message
   * @type {string}
   * @memberof PostUiOpenwindowNewmailUnprocessableEntity
   */
  error?: string;
}
/**
 * agent object
 * @export
 * @interface PostUniverseIdsAgent
 */
export interface PostUniverseIdsAgent {
  /**
   * id integer
   * @type {number}
   * @memberof PostUniverseIdsAgent
   */
  id?: number;
  /**
   * name string
   * @type {string}
   * @memberof PostUniverseIdsAgent
   */
  name?: string;
}
/**
 * alliance object
 * @export
 * @interface PostUniverseIdsAlliance
 */
export interface PostUniverseIdsAlliance {
  /**
   * id integer
   * @type {number}
   * @memberof PostUniverseIdsAlliance
   */
  id?: number;
  /**
   * name string
   * @type {string}
   * @memberof PostUniverseIdsAlliance
   */
  name?: string;
}
/**
 * character object
 * @export
 * @interface PostUniverseIdsCharacter
 */
export interface PostUniverseIdsCharacter {
  /**
   * id integer
   * @type {number}
   * @memberof PostUniverseIdsCharacter
   */
  id?: number;
  /**
   * name string
   * @type {string}
   * @memberof PostUniverseIdsCharacter
   */
  name?: string;
}
/**
 * constellation object
 * @export
 * @interface PostUniverseIdsConstellation
 */
export interface PostUniverseIdsConstellation {
  /**
   * id integer
   * @type {number}
   * @memberof PostUniverseIdsConstellation
   */
  id?: number;
  /**
   * name string
   * @type {string}
   * @memberof PostUniverseIdsConstellation
   */
  name?: string;
}
/**
 * corporation object
 * @export
 * @interface PostUniverseIdsCorporation
 */
export interface PostUniverseIdsCorporation {
  /**
   * id integer
   * @type {number}
   * @memberof PostUniverseIdsCorporation
   */
  id?: number;
  /**
   * name string
   * @type {string}
   * @memberof PostUniverseIdsCorporation
   */
  name?: string;
}
/**
 * faction object
 * @export
 * @interface PostUniverseIdsFaction
 */
export interface PostUniverseIdsFaction {
  /**
   * id integer
   * @type {number}
   * @memberof PostUniverseIdsFaction
   */
  id?: number;
  /**
   * name string
   * @type {string}
   * @memberof PostUniverseIdsFaction
   */
  name?: string;
}
/**
 * inventory_type object
 * @export
 * @interface PostUniverseIdsInventoryType
 */
export interface PostUniverseIdsInventoryType {
  /**
   * id integer
   * @type {number}
   * @memberof PostUniverseIdsInventoryType
   */
  id?: number;
  /**
   * name string
   * @type {string}
   * @memberof PostUniverseIdsInventoryType
   */
  name?: string;
}
/**
 * 200 ok object
 * @export
 * @interface PostUniverseIdsOk
 */
export interface PostUniverseIdsOk {
  /**
   * agents array
   * @type {Array<PostUniverseIdsAgent>}
   * @memberof PostUniverseIdsOk
   */
  agents?: Array<PostUniverseIdsAgent>;
  /**
   * alliances array
   * @type {Array<PostUniverseIdsAlliance>}
   * @memberof PostUniverseIdsOk
   */
  alliances?: Array<PostUniverseIdsAlliance>;
  /**
   * characters array
   * @type {Array<PostUniverseIdsCharacter>}
   * @memberof PostUniverseIdsOk
   */
  characters?: Array<PostUniverseIdsCharacter>;
  /**
   * constellations array
   * @type {Array<PostUniverseIdsConstellation>}
   * @memberof PostUniverseIdsOk
   */
  constellations?: Array<PostUniverseIdsConstellation>;
  /**
   * corporations array
   * @type {Array<PostUniverseIdsCorporation>}
   * @memberof PostUniverseIdsOk
   */
  corporations?: Array<PostUniverseIdsCorporation>;
  /**
   * factions array
   * @type {Array<PostUniverseIdsFaction>}
   * @memberof PostUniverseIdsOk
   */
  factions?: Array<PostUniverseIdsFaction>;
  /**
   * inventory_types array
   * @type {Array<PostUniverseIdsInventoryType>}
   * @memberof PostUniverseIdsOk
   */
  inventory_types?: Array<PostUniverseIdsInventoryType>;
  /**
   * regions array
   * @type {Array<PostUniverseIdsRegion>}
   * @memberof PostUniverseIdsOk
   */
  regions?: Array<PostUniverseIdsRegion>;
  /**
   * stations array
   * @type {Array<PostUniverseIdsStation>}
   * @memberof PostUniverseIdsOk
   */
  stations?: Array<PostUniverseIdsStation>;
  /**
   * systems array
   * @type {Array<PostUniverseIdsSystem>}
   * @memberof PostUniverseIdsOk
   */
  systems?: Array<PostUniverseIdsSystem>;
}
/**
 * region object
 * @export
 * @interface PostUniverseIdsRegion
 */
export interface PostUniverseIdsRegion {
  /**
   * id integer
   * @type {number}
   * @memberof PostUniverseIdsRegion
   */
  id?: number;
  /**
   * name string
   * @type {string}
   * @memberof PostUniverseIdsRegion
   */
  name?: string;
}
/**
 * station object
 * @export
 * @interface PostUniverseIdsStation
 */
export interface PostUniverseIdsStation {
  /**
   * id integer
   * @type {number}
   * @memberof PostUniverseIdsStation
   */
  id?: number;
  /**
   * name string
   * @type {string}
   * @memberof PostUniverseIdsStation
   */
  name?: string;
}
/**
 * system object
 * @export
 * @interface PostUniverseIdsSystem
 */
export interface PostUniverseIdsSystem {
  /**
   * id integer
   * @type {number}
   * @memberof PostUniverseIdsSystem
   */
  id?: number;
  /**
   * name string
   * @type {string}
   * @memberof PostUniverseIdsSystem
   */
  name?: string;
}
/**
 * 200 ok object
 * @export
 * @interface PostUniverseNames200Ok
 */
export interface PostUniverseNames200Ok {
  /**
   * category string
   * @type {string}
   * @memberof PostUniverseNames200Ok
   */
  category: PostUniverseNames200OkCategoryEnum;
  /**
   * id integer
   * @type {number}
   * @memberof PostUniverseNames200Ok
   */
  id: number;
  /**
   * name string
   * @type {string}
   * @memberof PostUniverseNames200Ok
   */
  name: string;
}

export const PostUniverseNames200OkCategoryEnum = {
  ALLIANCE: "alliance",
  CHARACTER: "character",
  CONSTELLATION: "constellation",
  CORPORATION: "corporation",
  INVENTORY_TYPE: "inventory_type",
  REGION: "region",
  SOLAR_SYSTEM: "solar_system",
  STATION: "station",
  FACTION: "faction",
} as const;

export type PostUniverseNames200OkCategoryEnum =
  typeof PostUniverseNames200OkCategoryEnum[keyof typeof PostUniverseNames200OkCategoryEnum];

/**
 * Not found
 * @export
 * @interface PostUniverseNamesNotFound
 */
export interface PostUniverseNamesNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof PostUniverseNamesNotFound
   */
  error?: string;
}
/**
 * response object
 * @export
 * @interface PutCharactersCharacterIdCalendarEventIdResponse
 */
export interface PutCharactersCharacterIdCalendarEventIdResponse {
  /**
   * response string
   * @type {string}
   * @memberof PutCharactersCharacterIdCalendarEventIdResponse
   */
  response: PutCharactersCharacterIdCalendarEventIdResponseResponseEnum;
}

export const PutCharactersCharacterIdCalendarEventIdResponseResponseEnum = {
  ACCEPTED: "accepted",
  DECLINED: "declined",
  TENTATIVE: "tentative",
} as const;

export type PutCharactersCharacterIdCalendarEventIdResponseResponseEnum =
  typeof PutCharactersCharacterIdCalendarEventIdResponseResponseEnum[keyof typeof PutCharactersCharacterIdCalendarEventIdResponseResponseEnum];

/**
 * contents object
 * @export
 * @interface PutCharactersCharacterIdMailMailIdContents
 */
export interface PutCharactersCharacterIdMailMailIdContents {
  /**
   * Labels to assign to the mail. Pre-existing labels are unassigned.
   * @type {Array<number>}
   * @memberof PutCharactersCharacterIdMailMailIdContents
   */
  labels?: Array<number>;
  /**
   * Whether the mail is flagged as read
   * @type {boolean}
   * @memberof PutCharactersCharacterIdMailMailIdContents
   */
  read?: boolean;
}
/**
 * movement object
 * @export
 * @interface PutFleetsFleetIdMembersMemberIdMovement
 */
export interface PutFleetsFleetIdMembersMemberIdMovement {
  /**
   * If a character is moved to the `fleet_commander` role, neither `wing_id` or `squad_id` should be specified. If a character is moved to the `wing_commander` role, only `wing_id` should be specified. If a character is moved to the `squad_commander` role, both `wing_id` and `squad_id` should be specified. If a character is moved to the `squad_member` role, both `wing_id` and `squad_id` should be specified.
   * @type {string}
   * @memberof PutFleetsFleetIdMembersMemberIdMovement
   */
  role: PutFleetsFleetIdMembersMemberIdMovementRoleEnum;
  /**
   * squad_id integer
   * @type {number}
   * @memberof PutFleetsFleetIdMembersMemberIdMovement
   */
  squad_id?: number;
  /**
   * wing_id integer
   * @type {number}
   * @memberof PutFleetsFleetIdMembersMemberIdMovement
   */
  wing_id?: number;
}

export const PutFleetsFleetIdMembersMemberIdMovementRoleEnum = {
  FLEET_COMMANDER: "fleet_commander",
  WING_COMMANDER: "wing_commander",
  SQUAD_COMMANDER: "squad_commander",
  SQUAD_MEMBER: "squad_member",
} as const;

export type PutFleetsFleetIdMembersMemberIdMovementRoleEnum =
  typeof PutFleetsFleetIdMembersMemberIdMovementRoleEnum[keyof typeof PutFleetsFleetIdMembersMemberIdMovementRoleEnum];

/**
 * Not found
 * @export
 * @interface PutFleetsFleetIdMembersMemberIdNotFound
 */
export interface PutFleetsFleetIdMembersMemberIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof PutFleetsFleetIdMembersMemberIdNotFound
   */
  error?: string;
}
/**
 * 422 unprocessable entity object
 * @export
 * @interface PutFleetsFleetIdMembersMemberIdUnprocessableEntity
 */
export interface PutFleetsFleetIdMembersMemberIdUnprocessableEntity {
  /**
   * error message
   * @type {string}
   * @memberof PutFleetsFleetIdMembersMemberIdUnprocessableEntity
   */
  error?: string;
}
/**
 * new_settings object
 * @export
 * @interface PutFleetsFleetIdNewSettings
 */
export interface PutFleetsFleetIdNewSettings {
  /**
   * Should free-move be enabled in the fleet
   * @type {boolean}
   * @memberof PutFleetsFleetIdNewSettings
   */
  is_free_move?: boolean;
  /**
   * New fleet MOTD in CCP flavoured HTML
   * @type {string}
   * @memberof PutFleetsFleetIdNewSettings
   */
  motd?: string;
}
/**
 * Not found
 * @export
 * @interface PutFleetsFleetIdNotFound
 */
export interface PutFleetsFleetIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof PutFleetsFleetIdNotFound
   */
  error?: string;
}
/**
 * naming object
 * @export
 * @interface PutFleetsFleetIdSquadsSquadIdNaming
 */
export interface PutFleetsFleetIdSquadsSquadIdNaming {
  /**
   * name string
   * @type {string}
   * @memberof PutFleetsFleetIdSquadsSquadIdNaming
   */
  name: string;
}
/**
 * Not found
 * @export
 * @interface PutFleetsFleetIdSquadsSquadIdNotFound
 */
export interface PutFleetsFleetIdSquadsSquadIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof PutFleetsFleetIdSquadsSquadIdNotFound
   */
  error?: string;
}
/**
 * naming object
 * @export
 * @interface PutFleetsFleetIdWingsWingIdNaming
 */
export interface PutFleetsFleetIdWingsWingIdNaming {
  /**
   * name string
   * @type {string}
   * @memberof PutFleetsFleetIdWingsWingIdNaming
   */
  name: string;
}
/**
 * Not found
 * @export
 * @interface PutFleetsFleetIdWingsWingIdNotFound
 */
export interface PutFleetsFleetIdWingsWingIdNotFound {
  /**
   * Not found message
   * @type {string}
   * @memberof PutFleetsFleetIdWingsWingIdNotFound
   */
  error?: string;
}
/**
 * Service unavailable model
 * @export
 * @interface ServiceUnavailable
 */
export interface ServiceUnavailable {
  /**
   * Service unavailable message
   * @type {string}
   * @memberof ServiceUnavailable
   */
  error: string;
}
/**
 * Unauthorized model
 * @export
 * @interface Unauthorized
 */
export interface Unauthorized {
  /**
   * Unauthorized message
   * @type {string}
   * @memberof Unauthorized
   */
  error: string;
}

/**
 * AllianceApi - axios parameter creator
 * @export
 */
export const AllianceApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/legacy/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  Alternate route: `/v4/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get alliance information
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlliance: async (
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'allianceId' is not null or undefined
      assertParamExists("getAlliance", "allianceId", allianceId);
      const localVarPath = `/alliances/{alliance_id}/`.replace(
        `{${"alliance_id"}}`,
        encodeURIComponent(String(allianceId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
     * @summary List alliance\'s corporations
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllianceCorporations: async (
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'allianceId' is not null or undefined
      assertParamExists("getAllianceCorporations", "allianceId", allianceId);
      const localVarPath = `/alliances/{alliance_id}/corporations/`.replace(
        `{${"alliance_id"}}`,
        encodeURIComponent(String(allianceId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the icon urls for a alliance  --- Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/alliances/{alliance_id}/icons/)
     * @summary Get alliance icon
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllianceIcons: async (
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'allianceId' is not null or undefined
      assertParamExists("getAllianceIcons", "allianceId", allianceId);
      const localVarPath = `/alliances/{alliance_id}/icons/`.replace(
        `{${"alliance_id"}}`,
        encodeURIComponent(String(allianceId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
     * @summary List all alliances
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlliances: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/alliances/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AllianceApi - functional programming interface
 * @export
 */
export const AllianceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AllianceApiAxiosParamCreator(configuration);
  return {
    /**
     * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/legacy/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  Alternate route: `/v4/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get alliance information
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAlliance(
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAlliancesAllianceIdOk>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAlliance(
        allianceId,
        datasource,
        ifNoneMatch,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
     * @summary List alliance\'s corporations
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllianceCorporations(
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllianceCorporations(
          allianceId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get the icon urls for a alliance  --- Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/alliances/{alliance_id}/icons/)
     * @summary Get alliance icon
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllianceIcons(
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAlliancesAllianceIdIconsOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllianceIcons(
          allianceId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
     * @summary List all alliances
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAlliances(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAlliances(
        datasource,
        ifNoneMatch,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AllianceApi - factory interface
 * @export
 */
export const AllianceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AllianceApiFp(configuration);
  return {
    /**
     * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/legacy/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  Alternate route: `/v4/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get alliance information
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlliance(
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetAlliancesAllianceIdOk> {
      return localVarFp
        .getAlliance(allianceId, datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
     * @summary List alliance\'s corporations
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllianceCorporations(
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getAllianceCorporations(allianceId, datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the icon urls for a alliance  --- Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/alliances/{alliance_id}/icons/)
     * @summary Get alliance icon
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllianceIcons(
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetAlliancesAllianceIdIconsOk> {
      return localVarFp
        .getAllianceIcons(allianceId, datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
     * @summary List all alliances
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlliances(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getAlliances(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AllianceApi - object-oriented interface
 * @export
 * @class AllianceApi
 * @extends {BaseAPI}
 */
export class AllianceApi extends BaseAPI {
  /**
   * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/legacy/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  Alternate route: `/v4/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
   * @summary Get alliance information
   * @param {number} allianceId An EVE alliance ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AllianceApi
   */
  public getAlliance(
    allianceId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return AllianceApiFp(this.configuration)
      .getAlliance(allianceId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
   * @summary List alliance\'s corporations
   * @param {number} allianceId An EVE alliance ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AllianceApi
   */
  public getAllianceCorporations(
    allianceId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return AllianceApiFp(this.configuration)
      .getAllianceCorporations(allianceId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the icon urls for a alliance  --- Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/alliances/{alliance_id}/icons/)
   * @summary Get alliance icon
   * @param {number} allianceId An EVE alliance ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AllianceApi
   */
  public getAllianceIcons(
    allianceId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return AllianceApiFp(this.configuration)
      .getAllianceIcons(allianceId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
   * @summary List all alliances
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AllianceApi
   */
  public getAlliances(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return AllianceApiFp(this.configuration)
      .getAlliances(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/`
     * @summary Get character asset locations
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterAssetLocations: async (
      characterId: number,
      itemIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterAssetLocations",
        "characterId",
        characterId
      );
      // verify required parameter 'itemIds' is not null or undefined
      assertParamExists("getCharacterAssetLocations", "itemIds", itemIds);
      const localVarPath =
        `/characters/{character_id}/assets/locations/`.replace(
          `{${"character_id"}}`,
          encodeURIComponent(String(characterId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-assets.read_assets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        itemIds,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/`
     * @summary Get character asset names
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterAssetNames: async (
      characterId: number,
      itemIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterAssetNames", "characterId", characterId);
      // verify required parameter 'itemIds' is not null or undefined
      assertParamExists("getCharacterAssetNames", "itemIds", itemIds);
      const localVarPath = `/characters/{character_id}/assets/names/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-assets.read_assets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        itemIds,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
     * @summary Get character assets
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterAssets: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterAssets", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/assets/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-assets.read_assets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation assets
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdAssets: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdAssets",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/assets/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-assets.read_corporation_assets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation asset locations
     * @param {number} corporationId An EVE corporation ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCorporationsCorporationIdAssetsLocations: async (
      corporationId: number,
      itemIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "postCorporationsCorporationIdAssetsLocations",
        "corporationId",
        corporationId
      );
      // verify required parameter 'itemIds' is not null or undefined
      assertParamExists(
        "postCorporationsCorporationIdAssetsLocations",
        "itemIds",
        itemIds
      );
      const localVarPath =
        `/corporations/{corporation_id}/assets/locations/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-assets.read_corporation_assets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        itemIds,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation asset names
     * @param {number} corporationId An EVE corporation ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCorporationsCorporationIdAssetsNames: async (
      corporationId: number,
      itemIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "postCorporationsCorporationIdAssetsNames",
        "corporationId",
        corporationId
      );
      // verify required parameter 'itemIds' is not null or undefined
      assertParamExists(
        "postCorporationsCorporationIdAssetsNames",
        "itemIds",
        itemIds
      );
      const localVarPath =
        `/corporations/{corporation_id}/assets/names/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-assets.read_corporation_assets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        itemIds,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/`
     * @summary Get character asset locations
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterAssetLocations(
      characterId: number,
      itemIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PostCharactersCharacterIdAssetsLocations200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterAssetLocations(
          characterId,
          itemIds,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/`
     * @summary Get character asset names
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterAssetNames(
      characterId: number,
      itemIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PostCharactersCharacterIdAssetsNames200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterAssetNames(
          characterId,
          itemIds,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
     * @summary Get character assets
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterAssets(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdAssets200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterAssets(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation assets
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdAssets(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdAssets200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdAssets(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation asset locations
     * @param {number} corporationId An EVE corporation ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postCorporationsCorporationIdAssetsLocations(
      corporationId: number,
      itemIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<
        Array<PostCorporationsCorporationIdAssetsLocations200Ok>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postCorporationsCorporationIdAssetsLocations(
          corporationId,
          itemIds,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation asset names
     * @param {number} corporationId An EVE corporation ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postCorporationsCorporationIdAssetsNames(
      corporationId: number,
      itemIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PostCorporationsCorporationIdAssetsNames200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postCorporationsCorporationIdAssetsNames(
          corporationId,
          itemIds,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AssetsApiFp(configuration);
  return {
    /**
     * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/`
     * @summary Get character asset locations
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterAssetLocations(
      characterId: number,
      itemIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<Array<PostCharactersCharacterIdAssetsLocations200Ok>> {
      return localVarFp
        .getCharacterAssetLocations(
          characterId,
          itemIds,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/`
     * @summary Get character asset names
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterAssetNames(
      characterId: number,
      itemIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<Array<PostCharactersCharacterIdAssetsNames200Ok>> {
      return localVarFp
        .getCharacterAssetNames(
          characterId,
          itemIds,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
     * @summary Get character assets
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterAssets(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdAssets200Ok>> {
      return localVarFp
        .getCharacterAssets(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation assets
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdAssets(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdAssets200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdAssets(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation asset locations
     * @param {number} corporationId An EVE corporation ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCorporationsCorporationIdAssetsLocations(
      corporationId: number,
      itemIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<Array<PostCorporationsCorporationIdAssetsLocations200Ok>> {
      return localVarFp
        .postCorporationsCorporationIdAssetsLocations(
          corporationId,
          itemIds,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation asset names
     * @param {number} corporationId An EVE corporation ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCorporationsCorporationIdAssetsNames(
      corporationId: number,
      itemIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<Array<PostCorporationsCorporationIdAssetsNames200Ok>> {
      return localVarFp
        .postCorporationsCorporationIdAssetsNames(
          corporationId,
          itemIds,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
  /**
   * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/`
   * @summary Get character asset locations
   * @param {number} characterId An EVE character ID
   * @param {Array<number>} itemIds A list of item ids
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public getCharacterAssetLocations(
    characterId: number,
    itemIds: Array<number>,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return AssetsApiFp(this.configuration)
      .getCharacterAssetLocations(
        characterId,
        itemIds,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/`
   * @summary Get character asset names
   * @param {number} characterId An EVE character ID
   * @param {Array<number>} itemIds A list of item ids
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public getCharacterAssetNames(
    characterId: number,
    itemIds: Array<number>,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return AssetsApiFp(this.configuration)
      .getCharacterAssetNames(characterId, itemIds, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
   * @summary Get character assets
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public getCharacterAssets(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return AssetsApiFp(this.configuration)
      .getCharacterAssets(
        characterId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get corporation assets
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public getCorporationsCorporationIdAssets(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return AssetsApiFp(this.configuration)
      .getCorporationsCorporationIdAssets(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director
   * @summary Get corporation asset locations
   * @param {number} corporationId An EVE corporation ID
   * @param {Array<number>} itemIds A list of item ids
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public postCorporationsCorporationIdAssetsLocations(
    corporationId: number,
    itemIds: Array<number>,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return AssetsApiFp(this.configuration)
      .postCorporationsCorporationIdAssetsLocations(
        corporationId,
        itemIds,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director
   * @summary Get corporation asset names
   * @param {number} corporationId An EVE corporation ID
   * @param {Array<number>} itemIds A list of item ids
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public postCorporationsCorporationIdAssetsNames(
    corporationId: number,
    itemIds: Array<number>,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return AssetsApiFp(this.configuration)
      .postCorporationsCorporationIdAssetsNames(
        corporationId,
        itemIds,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BookmarksApi - axios parameter creator
 * @export
 */
export const BookmarksApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * A list of your character\'s personal bookmarks  --- Alternate route: `/dev/characters/{character_id}/bookmarks/`  Alternate route: `/v2/characters/{character_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
     * @summary List bookmarks
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterBookmarks: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterBookmarks", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/bookmarks/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-bookmarks.read_character_bookmarks.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A list of your character\'s personal bookmark folders  --- Alternate route: `/dev/characters/{character_id}/bookmarks/folders/`  Alternate route: `/v2/characters/{character_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
     * @summary List bookmark folders
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterBookmarksFolders: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterBookmarksFolders",
        "characterId",
        characterId
      );
      const localVarPath =
        `/characters/{character_id}/bookmarks/folders/`.replace(
          `{${"character_id"}}`,
          encodeURIComponent(String(characterId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-bookmarks.read_character_bookmarks.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A list of your corporation\'s bookmarks  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
     * @summary List corporation bookmarks
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdBookmarks: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdBookmarks",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/bookmarks/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-bookmarks.read_corporation_bookmarks.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A list of your corporation\'s bookmark folders  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
     * @summary List corporation bookmark folders
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdBookmarksFolders: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdBookmarksFolders",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/bookmarks/folders/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-bookmarks.read_corporation_bookmarks.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BookmarksApi - functional programming interface
 * @export
 */
export const BookmarksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    BookmarksApiAxiosParamCreator(configuration);
  return {
    /**
     * A list of your character\'s personal bookmarks  --- Alternate route: `/dev/characters/{character_id}/bookmarks/`  Alternate route: `/v2/characters/{character_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
     * @summary List bookmarks
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterBookmarks(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdBookmarks200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterBookmarks(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * A list of your character\'s personal bookmark folders  --- Alternate route: `/dev/characters/{character_id}/bookmarks/folders/`  Alternate route: `/v2/characters/{character_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
     * @summary List bookmark folders
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterBookmarksFolders(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdBookmarksFolders200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterBookmarksFolders(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * A list of your corporation\'s bookmarks  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
     * @summary List corporation bookmarks
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdBookmarks(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdBookmarks200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdBookmarks(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * A list of your corporation\'s bookmark folders  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
     * @summary List corporation bookmark folders
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdBookmarksFolders(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<
        Array<GetCorporationsCorporationIdBookmarksFolders200Ok>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdBookmarksFolders(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * BookmarksApi - factory interface
 * @export
 */
export const BookmarksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BookmarksApiFp(configuration);
  return {
    /**
     * A list of your character\'s personal bookmarks  --- Alternate route: `/dev/characters/{character_id}/bookmarks/`  Alternate route: `/v2/characters/{character_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
     * @summary List bookmarks
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterBookmarks(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdBookmarks200Ok>> {
      return localVarFp
        .getCharacterBookmarks(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A list of your character\'s personal bookmark folders  --- Alternate route: `/dev/characters/{character_id}/bookmarks/folders/`  Alternate route: `/v2/characters/{character_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
     * @summary List bookmark folders
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterBookmarksFolders(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdBookmarksFolders200Ok>> {
      return localVarFp
        .getCharacterBookmarksFolders(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A list of your corporation\'s bookmarks  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
     * @summary List corporation bookmarks
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdBookmarks(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdBookmarks200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdBookmarks(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A list of your corporation\'s bookmark folders  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
     * @summary List corporation bookmark folders
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdBookmarksFolders(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdBookmarksFolders200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdBookmarksFolders(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BookmarksApi - object-oriented interface
 * @export
 * @class BookmarksApi
 * @extends {BaseAPI}
 */
export class BookmarksApi extends BaseAPI {
  /**
   * A list of your character\'s personal bookmarks  --- Alternate route: `/dev/characters/{character_id}/bookmarks/`  Alternate route: `/v2/characters/{character_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
   * @summary List bookmarks
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookmarksApi
   */
  public getCharacterBookmarks(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return BookmarksApiFp(this.configuration)
      .getCharacterBookmarks(
        characterId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A list of your character\'s personal bookmark folders  --- Alternate route: `/dev/characters/{character_id}/bookmarks/folders/`  Alternate route: `/v2/characters/{character_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
   * @summary List bookmark folders
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookmarksApi
   */
  public getCharacterBookmarksFolders(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return BookmarksApiFp(this.configuration)
      .getCharacterBookmarksFolders(
        characterId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A list of your corporation\'s bookmarks  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
   * @summary List corporation bookmarks
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookmarksApi
   */
  public getCorporationsCorporationIdBookmarks(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return BookmarksApiFp(this.configuration)
      .getCorporationsCorporationIdBookmarks(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A list of your corporation\'s bookmark folders  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
   * @summary List corporation bookmark folders
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookmarksApi
   */
  public getCorporationsCorporationIdBookmarksFolders(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return BookmarksApiFp(this.configuration)
      .getCorporationsCorporationIdBookmarksFolders(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CalendarApi - axios parameter creator
 * @export
 */
export const CalendarApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
     * @summary List calendar event summaries
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {number} [fromEvent] The event ID to retrieve events from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterCalendar: async (
      characterId: number,
      datasource?: "tranquility",
      fromEvent?: number,
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterCalendar", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/calendar/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-calendar.read_calendar_events.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (fromEvent !== undefined) {
        localVarQueryParameter["from_event"] = fromEvent;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
     * @summary Get an event
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The id of the event requested
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterCalendarEvent: async (
      characterId: number,
      eventId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterCalendarEvent",
        "characterId",
        characterId
      );
      // verify required parameter 'eventId' is not null or undefined
      assertParamExists("getCharacterCalendarEvent", "eventId", eventId);
      const localVarPath = `/characters/{character_id}/calendar/{event_id}/`
        .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
        .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-calendar.read_calendar_events.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
     * @summary Get attendees
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The id of the event requested
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterCalendarEventAttendees: async (
      characterId: number,
      eventId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterCalendarEventAttendees",
        "characterId",
        characterId
      );
      // verify required parameter 'eventId' is not null or undefined
      assertParamExists(
        "getCharacterCalendarEventAttendees",
        "eventId",
        eventId
      );
      const localVarPath =
        `/characters/{character_id}/calendar/{event_id}/attendees/`
          .replace(
            `{${"character_id"}}`,
            encodeURIComponent(String(characterId))
          )
          .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-calendar.read_calendar_events.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
     * @summary Respond to an event
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The ID of the event requested
     * @param {PutCharactersCharacterIdCalendarEventIdResponse} response The response value to set, overriding current value
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondToCharacterCharacterCalendarEvent: async (
      characterId: number,
      eventId: number,
      response: PutCharactersCharacterIdCalendarEventIdResponse,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "respondToCharacterCharacterCalendarEvent",
        "characterId",
        characterId
      );
      // verify required parameter 'eventId' is not null or undefined
      assertParamExists(
        "respondToCharacterCharacterCalendarEvent",
        "eventId",
        eventId
      );
      // verify required parameter 'response' is not null or undefined
      assertParamExists(
        "respondToCharacterCharacterCalendarEvent",
        "response",
        response
      );
      const localVarPath = `/characters/{character_id}/calendar/{event_id}/`
        .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
        .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-calendar.respond_calendar_events.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        response,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CalendarApi - functional programming interface
 * @export
 */
export const CalendarApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CalendarApiAxiosParamCreator(configuration);
  return {
    /**
     * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
     * @summary List calendar event summaries
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {number} [fromEvent] The event ID to retrieve events from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterCalendar(
      characterId: number,
      datasource?: "tranquility",
      fromEvent?: number,
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdCalendar200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterCalendar(
          characterId,
          datasource,
          fromEvent,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
     * @summary Get an event
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The id of the event requested
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterCalendarEvent(
      characterId: number,
      eventId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdCalendarEventIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterCalendarEvent(
          characterId,
          eventId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
     * @summary Get attendees
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The id of the event requested
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterCalendarEventAttendees(
      characterId: number,
      eventId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<
        Array<GetCharactersCharacterIdCalendarEventIdAttendees200Ok>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterCalendarEventAttendees(
          characterId,
          eventId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
     * @summary Respond to an event
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The ID of the event requested
     * @param {PutCharactersCharacterIdCalendarEventIdResponse} response The response value to set, overriding current value
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async respondToCharacterCharacterCalendarEvent(
      characterId: number,
      eventId: number,
      response: PutCharactersCharacterIdCalendarEventIdResponse,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.respondToCharacterCharacterCalendarEvent(
          characterId,
          eventId,
          response,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CalendarApi - factory interface
 * @export
 */
export const CalendarApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CalendarApiFp(configuration);
  return {
    /**
     * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
     * @summary List calendar event summaries
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {number} [fromEvent] The event ID to retrieve events from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterCalendar(
      characterId: number,
      datasource?: "tranquility",
      fromEvent?: number,
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdCalendar200Ok>> {
      return localVarFp
        .getCharacterCalendar(
          characterId,
          datasource,
          fromEvent,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
     * @summary Get an event
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The id of the event requested
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterCalendarEvent(
      characterId: number,
      eventId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdCalendarEventIdOk> {
      return localVarFp
        .getCharacterCalendarEvent(
          characterId,
          eventId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
     * @summary Get attendees
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The id of the event requested
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterCalendarEventAttendees(
      characterId: number,
      eventId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<
      Array<GetCharactersCharacterIdCalendarEventIdAttendees200Ok>
    > {
      return localVarFp
        .getCharacterCalendarEventAttendees(
          characterId,
          eventId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
     * @summary Respond to an event
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The ID of the event requested
     * @param {PutCharactersCharacterIdCalendarEventIdResponse} response The response value to set, overriding current value
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondToCharacterCharacterCalendarEvent(
      characterId: number,
      eventId: number,
      response: PutCharactersCharacterIdCalendarEventIdResponse,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .respondToCharacterCharacterCalendarEvent(
          characterId,
          eventId,
          response,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CalendarApi - object-oriented interface
 * @export
 * @class CalendarApi
 * @extends {BaseAPI}
 */
export class CalendarApi extends BaseAPI {
  /**
   * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
   * @summary List calendar event summaries
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {number} [fromEvent] The event ID to retrieve events from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CalendarApi
   */
  public getCharacterCalendar(
    characterId: number,
    datasource?: "tranquility",
    fromEvent?: number,
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CalendarApiFp(this.configuration)
      .getCharacterCalendar(
        characterId,
        datasource,
        fromEvent,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
   * @summary Get an event
   * @param {number} characterId An EVE character ID
   * @param {number} eventId The id of the event requested
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CalendarApi
   */
  public getCharacterCalendarEvent(
    characterId: number,
    eventId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CalendarApiFp(this.configuration)
      .getCharacterCalendarEvent(
        characterId,
        eventId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
   * @summary Get attendees
   * @param {number} characterId An EVE character ID
   * @param {number} eventId The id of the event requested
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CalendarApi
   */
  public getCharacterCalendarEventAttendees(
    characterId: number,
    eventId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CalendarApiFp(this.configuration)
      .getCharacterCalendarEventAttendees(
        characterId,
        eventId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
   * @summary Respond to an event
   * @param {number} characterId An EVE character ID
   * @param {number} eventId The ID of the event requested
   * @param {PutCharactersCharacterIdCalendarEventIdResponse} response The response value to set, overriding current value
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CalendarApi
   */
  public respondToCharacterCharacterCalendarEvent(
    characterId: number,
    eventId: number,
    response: PutCharactersCharacterIdCalendarEventIdResponse,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CalendarApiFp(this.configuration)
      .respondToCharacterCharacterCalendarEvent(
        characterId,
        eventId,
        response,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CharacterApi - axios parameter creator
 * @export
 */
export const CharacterApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/v2/characters/affiliation/`  --- This route is cached for up to 3600 seconds
     * @summary Character affiliation
     * @param {Array<number>} characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkLookupCharacterAffiliation: async (
      characters: Array<number>,
      datasource?: "tranquility",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characters' is not null or undefined
      assertParamExists(
        "bulkLookupCharacterAffiliation",
        "characters",
        characters
      );
      const localVarPath = `/characters/affiliation/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        characters,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/legacy/characters/{character_id}/`  Alternate route: `/v5/characters/{character_id}/`  --- This route is cached for up to 86400 seconds
     * @summary Get character\'s public information
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacter: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacter", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/v2/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
     * @summary Get agents research
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterAgentResearch: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterAgentResearch",
        "characterId",
        characterId
      );
      const localVarPath =
        `/characters/{character_id}/agents_research/`.replace(
          `{${"character_id"}}`,
          encodeURIComponent(String(characterId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_agents_research.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/v3/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
     * @summary Get blueprints
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterBlueprints: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterBlueprints", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/blueprints/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_blueprints.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/v2/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
     * @summary Get corporation history
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterCorporationhistory: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterCorporationhistory",
        "characterId",
        characterId
      );
      const localVarPath =
        `/characters/{character_id}/corporationhistory/`.replace(
          `{${"character_id"}}`,
          encodeURIComponent(String(characterId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a character\'s jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/v2/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
     * @summary Get jump fatigue
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterFatigue: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterFatigue", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/fatigue/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_fatigue.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/v2/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
     * @summary Get medals
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterMedals: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterMedals", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/medals/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_medals.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  Alternate route: `/v6/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
     * @summary Get character notifications
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterNotifications: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterNotifications",
        "characterId",
        characterId
      );
      const localVarPath = `/characters/{character_id}/notifications/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_notifications.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return notifications about having been added to someone\'s contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/v2/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
     * @summary Get new contact notifications
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterNotificationsContacts: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterNotificationsContacts",
        "characterId",
        characterId
      );
      const localVarPath =
        `/characters/{character_id}/notifications/contacts/`.replace(
          `{${"character_id"}}`,
          encodeURIComponent(String(characterId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_notifications.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get portrait urls for a character  --- Alternate route: `/dev/characters/{character_id}/portrait/`  Alternate route: `/v2/characters/{character_id}/portrait/`  Alternate route: `/v3/characters/{character_id}/portrait/`  --- This route expires daily at 11:05
     * @summary Get character portraits
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterPortrait: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterPortrait", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/portrait/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a character\'s corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/v3/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
     * @summary Get character corporation roles
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterRoles: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterRoles", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/roles/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_corporation_roles.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/v2/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
     * @summary Get standings
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterStandings: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterStandings", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/standings/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_standings.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a character\'s titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/v2/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
     * @summary Get character corporation titles
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterTitles: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterTitles", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/titles/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_titles.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Takes a source character ID in the url and a set of target character ID\'s in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/v5/characters/{character_id}/cspa/`
     * @summary Calculate a CSPA charge cost
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} characters The target characters to calculate the charge for
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharactersCspaCost: async (
      characterId: number,
      characters: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharactersCspaCost", "characterId", characterId);
      // verify required parameter 'characters' is not null or undefined
      assertParamExists("getCharactersCspaCost", "characters", characters);
      const localVarPath = `/characters/{character_id}/cspa/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_contacts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        characters,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CharacterApi - functional programming interface
 * @export
 */
export const CharacterApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CharacterApiAxiosParamCreator(configuration);
  return {
    /**
     * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/v2/characters/affiliation/`  --- This route is cached for up to 3600 seconds
     * @summary Character affiliation
     * @param {Array<number>} characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkLookupCharacterAffiliation(
      characters: Array<number>,
      datasource?: "tranquility",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PostCharactersAffiliation200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bulkLookupCharacterAffiliation(
          characters,
          datasource,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/legacy/characters/{character_id}/`  Alternate route: `/v5/characters/{character_id}/`  --- This route is cached for up to 86400 seconds
     * @summary Get character\'s public information
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacter(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdOk>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCharacter(
        characterId,
        datasource,
        ifNoneMatch,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/v2/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
     * @summary Get agents research
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterAgentResearch(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdAgentsResearch200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterAgentResearch(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/v3/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
     * @summary Get blueprints
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterBlueprints(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdBlueprints200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterBlueprints(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/v2/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
     * @summary Get corporation history
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterCorporationhistory(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdCorporationhistory200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterCorporationhistory(
          characterId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a character\'s jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/v2/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
     * @summary Get jump fatigue
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterFatigue(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdFatigueOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterFatigue(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/v2/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
     * @summary Get medals
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterMedals(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdMedals200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterMedals(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  Alternate route: `/v6/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
     * @summary Get character notifications
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterNotifications(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdNotifications200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterNotifications(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return notifications about having been added to someone\'s contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/v2/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
     * @summary Get new contact notifications
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterNotificationsContacts(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<
        Array<GetCharactersCharacterIdNotificationsContacts200Ok>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterNotificationsContacts(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get portrait urls for a character  --- Alternate route: `/dev/characters/{character_id}/portrait/`  Alternate route: `/v2/characters/{character_id}/portrait/`  Alternate route: `/v3/characters/{character_id}/portrait/`  --- This route expires daily at 11:05
     * @summary Get character portraits
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterPortrait(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdPortraitOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterPortrait(
          characterId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a character\'s corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/v3/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
     * @summary Get character corporation roles
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterRoles(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdRolesOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterRoles(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/v2/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
     * @summary Get standings
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterStandings(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdStandings200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterStandings(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a character\'s titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/v2/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
     * @summary Get character corporation titles
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterTitles(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdTitles200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterTitles(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Takes a source character ID in the url and a set of target character ID\'s in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/v5/characters/{character_id}/cspa/`
     * @summary Calculate a CSPA charge cost
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} characters The target characters to calculate the charge for
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharactersCspaCost(
      characterId: number,
      characters: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharactersCspaCost(
          characterId,
          characters,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CharacterApi - factory interface
 * @export
 */
export const CharacterApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CharacterApiFp(configuration);
  return {
    /**
     * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/v2/characters/affiliation/`  --- This route is cached for up to 3600 seconds
     * @summary Character affiliation
     * @param {Array<number>} characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkLookupCharacterAffiliation(
      characters: Array<number>,
      datasource?: "tranquility",
      options?: any
    ): AxiosPromise<Array<PostCharactersAffiliation200Ok>> {
      return localVarFp
        .bulkLookupCharacterAffiliation(characters, datasource, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/legacy/characters/{character_id}/`  Alternate route: `/v5/characters/{character_id}/`  --- This route is cached for up to 86400 seconds
     * @summary Get character\'s public information
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacter(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdOk> {
      return localVarFp
        .getCharacter(characterId, datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/v2/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
     * @summary Get agents research
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterAgentResearch(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdAgentsResearch200Ok>> {
      return localVarFp
        .getCharacterAgentResearch(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/v3/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
     * @summary Get blueprints
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterBlueprints(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdBlueprints200Ok>> {
      return localVarFp
        .getCharacterBlueprints(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/v2/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
     * @summary Get corporation history
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterCorporationhistory(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdCorporationhistory200Ok>> {
      return localVarFp
        .getCharacterCorporationhistory(
          characterId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a character\'s jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/v2/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
     * @summary Get jump fatigue
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterFatigue(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdFatigueOk> {
      return localVarFp
        .getCharacterFatigue(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/v2/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
     * @summary Get medals
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterMedals(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdMedals200Ok>> {
      return localVarFp
        .getCharacterMedals(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  Alternate route: `/v6/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
     * @summary Get character notifications
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterNotifications(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdNotifications200Ok>> {
      return localVarFp
        .getCharacterNotifications(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return notifications about having been added to someone\'s contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/v2/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
     * @summary Get new contact notifications
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterNotificationsContacts(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdNotificationsContacts200Ok>> {
      return localVarFp
        .getCharacterNotificationsContacts(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get portrait urls for a character  --- Alternate route: `/dev/characters/{character_id}/portrait/`  Alternate route: `/v2/characters/{character_id}/portrait/`  Alternate route: `/v3/characters/{character_id}/portrait/`  --- This route expires daily at 11:05
     * @summary Get character portraits
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterPortrait(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdPortraitOk> {
      return localVarFp
        .getCharacterPortrait(characterId, datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a character\'s corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/v3/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
     * @summary Get character corporation roles
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterRoles(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdRolesOk> {
      return localVarFp
        .getCharacterRoles(characterId, datasource, ifNoneMatch, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/v2/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
     * @summary Get standings
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterStandings(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdStandings200Ok>> {
      return localVarFp
        .getCharacterStandings(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a character\'s titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/v2/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
     * @summary Get character corporation titles
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterTitles(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdTitles200Ok>> {
      return localVarFp
        .getCharacterTitles(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Takes a source character ID in the url and a set of target character ID\'s in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/v5/characters/{character_id}/cspa/`
     * @summary Calculate a CSPA charge cost
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} characters The target characters to calculate the charge for
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharactersCspaCost(
      characterId: number,
      characters: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .getCharactersCspaCost(
          characterId,
          characters,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CharacterApi - object-oriented interface
 * @export
 * @class CharacterApi
 * @extends {BaseAPI}
 */
export class CharacterApi extends BaseAPI {
  /**
   * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/v2/characters/affiliation/`  --- This route is cached for up to 3600 seconds
   * @summary Character affiliation
   * @param {Array<number>} characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public bulkLookupCharacterAffiliation(
    characters: Array<number>,
    datasource?: "tranquility",
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .bulkLookupCharacterAffiliation(characters, datasource, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/legacy/characters/{character_id}/`  Alternate route: `/v5/characters/{character_id}/`  --- This route is cached for up to 86400 seconds
   * @summary Get character\'s public information
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharacter(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharacter(characterId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/v2/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
   * @summary Get agents research
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharacterAgentResearch(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharacterAgentResearch(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/v3/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
   * @summary Get blueprints
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharacterBlueprints(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharacterBlueprints(
        characterId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/v2/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
   * @summary Get corporation history
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharacterCorporationhistory(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharacterCorporationhistory(
        characterId,
        datasource,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a character\'s jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/v2/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
   * @summary Get jump fatigue
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharacterFatigue(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharacterFatigue(characterId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/v2/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
   * @summary Get medals
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharacterMedals(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharacterMedals(characterId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  Alternate route: `/v6/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
   * @summary Get character notifications
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharacterNotifications(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharacterNotifications(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return notifications about having been added to someone\'s contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/v2/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
   * @summary Get new contact notifications
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharacterNotificationsContacts(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharacterNotificationsContacts(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get portrait urls for a character  --- Alternate route: `/dev/characters/{character_id}/portrait/`  Alternate route: `/v2/characters/{character_id}/portrait/`  Alternate route: `/v3/characters/{character_id}/portrait/`  --- This route expires daily at 11:05
   * @summary Get character portraits
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharacterPortrait(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharacterPortrait(characterId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a character\'s corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/v3/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
   * @summary Get character corporation roles
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharacterRoles(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharacterRoles(characterId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/v2/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
   * @summary Get standings
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharacterStandings(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharacterStandings(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a character\'s titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/v2/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
   * @summary Get character corporation titles
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharacterTitles(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharacterTitles(characterId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Takes a source character ID in the url and a set of target character ID\'s in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/v5/characters/{character_id}/cspa/`
   * @summary Calculate a CSPA charge cost
   * @param {number} characterId An EVE character ID
   * @param {Array<number>} characters The target characters to calculate the charge for
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CharacterApi
   */
  public getCharactersCspaCost(
    characterId: number,
    characters: Array<number>,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CharacterApiFp(this.configuration)
      .getCharactersCspaCost(
        characterId,
        characters,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ClonesApi - axios parameter creator
 * @export
 */
export const ClonesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  Alternate route: `/v2/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
     * @summary Get active implants
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterCharacterImplants: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterCharacterImplants",
        "characterId",
        characterId
      );
      const localVarPath = `/characters/{character_id}/implants/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-clones.read_implants.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A list of the character\'s clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  Alternate route: `/v4/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
     * @summary Get clones
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterClones: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterClones", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/clones/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-clones.read_clones.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClonesApi - functional programming interface
 * @export
 */
export const ClonesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ClonesApiAxiosParamCreator(configuration);
  return {
    /**
     * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  Alternate route: `/v2/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
     * @summary Get active implants
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterCharacterImplants(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterCharacterImplants(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * A list of the character\'s clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  Alternate route: `/v4/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
     * @summary Get clones
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterClones(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdClonesOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterClones(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ClonesApi - factory interface
 * @export
 */
export const ClonesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ClonesApiFp(configuration);
  return {
    /**
     * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  Alternate route: `/v2/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
     * @summary Get active implants
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterCharacterImplants(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getCharacterCharacterImplants(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A list of the character\'s clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  Alternate route: `/v4/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
     * @summary Get clones
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterClones(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdClonesOk> {
      return localVarFp
        .getCharacterClones(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ClonesApi - object-oriented interface
 * @export
 * @class ClonesApi
 * @extends {BaseAPI}
 */
export class ClonesApi extends BaseAPI {
  /**
   * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  Alternate route: `/v2/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
   * @summary Get active implants
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClonesApi
   */
  public getCharacterCharacterImplants(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ClonesApiFp(this.configuration)
      .getCharacterCharacterImplants(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A list of the character\'s clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  Alternate route: `/v4/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
   * @summary Get clones
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClonesApi
   */
  public getCharacterClones(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ClonesApiFp(this.configuration)
      .getCharacterClones(characterId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`
     * @summary Add contacts
     * @param {number} characterId An EVE character ID
     * @param {number} standing Standing for the contact
     * @param {Array<number>} contactIds A list of contacts
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {Array<number>} [labelIds] Add custom labels to the new contact
     * @param {string} [token] Access token to use if unable to set a header
     * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkAddCharacterContacts: async (
      characterId: number,
      standing: number,
      contactIds: Array<number>,
      datasource?: "tranquility",
      labelIds?: Array<number>,
      token?: string,
      watched?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("bulkAddCharacterContacts", "characterId", characterId);
      // verify required parameter 'standing' is not null or undefined
      assertParamExists("bulkAddCharacterContacts", "standing", standing);
      // verify required parameter 'contactIds' is not null or undefined
      assertParamExists("bulkAddCharacterContacts", "contactIds", contactIds);
      const localVarPath = `/characters/{character_id}/contacts/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.write_contacts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (labelIds) {
        localVarQueryParameter["label_ids"] = labelIds.join(
          COLLECTION_FORMATS.csv
        );
      }

      if (standing !== undefined) {
        localVarQueryParameter["standing"] = standing;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (watched !== undefined) {
        localVarQueryParameter["watched"] = watched;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        contactIds,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`
     * @summary Delete contacts
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} contactIds A list of contacts to delete
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteCharacterContacts: async (
      characterId: number,
      contactIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "bulkDeleteCharacterContacts",
        "characterId",
        characterId
      );
      // verify required parameter 'contactIds' is not null or undefined
      assertParamExists(
        "bulkDeleteCharacterContacts",
        "contactIds",
        contactIds
      );
      const localVarPath = `/characters/{character_id}/contacts/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.write_contacts.v1"],
        configuration
      );

      if (contactIds) {
        localVarQueryParameter["contact_ids"] = contactIds.join(
          COLLECTION_FORMATS.csv
        );
      }

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`
     * @summary Edit contacts
     * @param {number} characterId An EVE character ID
     * @param {number} standing Standing for the contact
     * @param {Array<number>} contactIds A list of contacts
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {Array<number>} [labelIds] Add custom labels to the contact
     * @param {string} [token] Access token to use if unable to set a header
     * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkEditCharacterContacts: async (
      characterId: number,
      standing: number,
      contactIds: Array<number>,
      datasource?: "tranquility",
      labelIds?: Array<number>,
      token?: string,
      watched?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "bulkEditCharacterContacts",
        "characterId",
        characterId
      );
      // verify required parameter 'standing' is not null or undefined
      assertParamExists("bulkEditCharacterContacts", "standing", standing);
      // verify required parameter 'contactIds' is not null or undefined
      assertParamExists("bulkEditCharacterContacts", "contactIds", contactIds);
      const localVarPath = `/characters/{character_id}/contacts/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.write_contacts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (labelIds) {
        localVarQueryParameter["label_ids"] = labelIds.join(
          COLLECTION_FORMATS.csv
        );
      }

      if (standing !== undefined) {
        localVarQueryParameter["standing"] = standing;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (watched !== undefined) {
        localVarQueryParameter["watched"] = watched;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        contactIds,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return custom labels for an alliance\'s contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get alliance contact labels
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllianceContactLabels: async (
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'allianceId' is not null or undefined
      assertParamExists("getAllianceContactLabels", "allianceId", allianceId);
      const localVarPath = `/alliances/{alliance_id}/contacts/labels/`.replace(
        `{${"alliance_id"}}`,
        encodeURIComponent(String(allianceId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-alliances.read_contacts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get alliance contacts
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllianceContacts: async (
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'allianceId' is not null or undefined
      assertParamExists("getAllianceContacts", "allianceId", allianceId);
      const localVarPath = `/alliances/{alliance_id}/contacts/`.replace(
        `{${"alliance_id"}}`,
        encodeURIComponent(String(allianceId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-alliances.read_contacts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return custom labels for a character\'s contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get contact labels
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterContactLabels: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterContactLabels",
        "characterId",
        characterId
      );
      const localVarPath =
        `/characters/{character_id}/contacts/labels/`.replace(
          `{${"character_id"}}`,
          encodeURIComponent(String(characterId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_contacts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get contacts
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterContacts: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterContacts", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/contacts/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_contacts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contacts
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdContacts: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdContacts",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/contacts/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_contacts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return custom labels for a corporation\'s contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contact labels
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdContactsLabels: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdContactsLabels",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/contacts/labels/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_contacts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration);
  return {
    /**
     * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`
     * @summary Add contacts
     * @param {number} characterId An EVE character ID
     * @param {number} standing Standing for the contact
     * @param {Array<number>} contactIds A list of contacts
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {Array<number>} [labelIds] Add custom labels to the new contact
     * @param {string} [token] Access token to use if unable to set a header
     * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkAddCharacterContacts(
      characterId: number,
      standing: number,
      contactIds: Array<number>,
      datasource?: "tranquility",
      labelIds?: Array<number>,
      token?: string,
      watched?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bulkAddCharacterContacts(
          characterId,
          standing,
          contactIds,
          datasource,
          labelIds,
          token,
          watched,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`
     * @summary Delete contacts
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} contactIds A list of contacts to delete
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDeleteCharacterContacts(
      characterId: number,
      contactIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bulkDeleteCharacterContacts(
          characterId,
          contactIds,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`
     * @summary Edit contacts
     * @param {number} characterId An EVE character ID
     * @param {number} standing Standing for the contact
     * @param {Array<number>} contactIds A list of contacts
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {Array<number>} [labelIds] Add custom labels to the contact
     * @param {string} [token] Access token to use if unable to set a header
     * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkEditCharacterContacts(
      characterId: number,
      standing: number,
      contactIds: Array<number>,
      datasource?: "tranquility",
      labelIds?: Array<number>,
      token?: string,
      watched?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bulkEditCharacterContacts(
          characterId,
          standing,
          contactIds,
          datasource,
          labelIds,
          token,
          watched,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return custom labels for an alliance\'s contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get alliance contact labels
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllianceContactLabels(
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetAlliancesAllianceIdContactsLabels200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllianceContactLabels(
          allianceId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get alliance contacts
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllianceContacts(
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetAlliancesAllianceIdContacts200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllianceContacts(
          allianceId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return custom labels for a character\'s contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get contact labels
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterContactLabels(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdContactsLabels200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterContactLabels(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get contacts
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterContacts(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdContacts200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterContacts(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contacts
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdContacts(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdContacts200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdContacts(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return custom labels for a corporation\'s contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contact labels
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdContactsLabels(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdContactsLabels200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdContactsLabels(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ContactsApiFp(configuration);
  return {
    /**
     * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`
     * @summary Add contacts
     * @param {number} characterId An EVE character ID
     * @param {number} standing Standing for the contact
     * @param {Array<number>} contactIds A list of contacts
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {Array<number>} [labelIds] Add custom labels to the new contact
     * @param {string} [token] Access token to use if unable to set a header
     * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkAddCharacterContacts(
      characterId: number,
      standing: number,
      contactIds: Array<number>,
      datasource?: "tranquility",
      labelIds?: Array<number>,
      token?: string,
      watched?: boolean,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .bulkAddCharacterContacts(
          characterId,
          standing,
          contactIds,
          datasource,
          labelIds,
          token,
          watched,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`
     * @summary Delete contacts
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} contactIds A list of contacts to delete
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteCharacterContacts(
      characterId: number,
      contactIds: Array<number>,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .bulkDeleteCharacterContacts(
          characterId,
          contactIds,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`
     * @summary Edit contacts
     * @param {number} characterId An EVE character ID
     * @param {number} standing Standing for the contact
     * @param {Array<number>} contactIds A list of contacts
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {Array<number>} [labelIds] Add custom labels to the contact
     * @param {string} [token] Access token to use if unable to set a header
     * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkEditCharacterContacts(
      characterId: number,
      standing: number,
      contactIds: Array<number>,
      datasource?: "tranquility",
      labelIds?: Array<number>,
      token?: string,
      watched?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .bulkEditCharacterContacts(
          characterId,
          standing,
          contactIds,
          datasource,
          labelIds,
          token,
          watched,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return custom labels for an alliance\'s contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get alliance contact labels
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllianceContactLabels(
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetAlliancesAllianceIdContactsLabels200Ok>> {
      return localVarFp
        .getAllianceContactLabels(
          allianceId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get alliance contacts
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllianceContacts(
      allianceId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetAlliancesAllianceIdContacts200Ok>> {
      return localVarFp
        .getAllianceContacts(
          allianceId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return custom labels for a character\'s contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get contact labels
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterContactLabels(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdContactsLabels200Ok>> {
      return localVarFp
        .getCharacterContactLabels(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get contacts
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterContacts(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdContacts200Ok>> {
      return localVarFp
        .getCharacterContacts(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contacts
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdContacts(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdContacts200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdContacts(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return custom labels for a corporation\'s contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contact labels
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdContactsLabels(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdContactsLabels200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdContactsLabels(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
  /**
   * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`
   * @summary Add contacts
   * @param {number} characterId An EVE character ID
   * @param {number} standing Standing for the contact
   * @param {Array<number>} contactIds A list of contacts
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {Array<number>} [labelIds] Add custom labels to the new contact
   * @param {string} [token] Access token to use if unable to set a header
   * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public bulkAddCharacterContacts(
    characterId: number,
    standing: number,
    contactIds: Array<number>,
    datasource?: "tranquility",
    labelIds?: Array<number>,
    token?: string,
    watched?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ContactsApiFp(this.configuration)
      .bulkAddCharacterContacts(
        characterId,
        standing,
        contactIds,
        datasource,
        labelIds,
        token,
        watched,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`
   * @summary Delete contacts
   * @param {number} characterId An EVE character ID
   * @param {Array<number>} contactIds A list of contacts to delete
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public bulkDeleteCharacterContacts(
    characterId: number,
    contactIds: Array<number>,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContactsApiFp(this.configuration)
      .bulkDeleteCharacterContacts(
        characterId,
        contactIds,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`
   * @summary Edit contacts
   * @param {number} characterId An EVE character ID
   * @param {number} standing Standing for the contact
   * @param {Array<number>} contactIds A list of contacts
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {Array<number>} [labelIds] Add custom labels to the contact
   * @param {string} [token] Access token to use if unable to set a header
   * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public bulkEditCharacterContacts(
    characterId: number,
    standing: number,
    contactIds: Array<number>,
    datasource?: "tranquility",
    labelIds?: Array<number>,
    token?: string,
    watched?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ContactsApiFp(this.configuration)
      .bulkEditCharacterContacts(
        characterId,
        standing,
        contactIds,
        datasource,
        labelIds,
        token,
        watched,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return custom labels for an alliance\'s contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
   * @summary Get alliance contact labels
   * @param {number} allianceId An EVE alliance ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public getAllianceContactLabels(
    allianceId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContactsApiFp(this.configuration)
      .getAllianceContactLabels(
        allianceId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
   * @summary Get alliance contacts
   * @param {number} allianceId An EVE alliance ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public getAllianceContacts(
    allianceId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContactsApiFp(this.configuration)
      .getAllianceContacts(
        allianceId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return custom labels for a character\'s contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
   * @summary Get contact labels
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public getCharacterContactLabels(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContactsApiFp(this.configuration)
      .getCharacterContactLabels(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
   * @summary Get contacts
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public getCharacterContacts(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContactsApiFp(this.configuration)
      .getCharacterContacts(
        characterId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
   * @summary Get corporation contacts
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public getCorporationsCorporationIdContacts(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContactsApiFp(this.configuration)
      .getCorporationsCorporationIdContacts(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return custom labels for a corporation\'s contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
   * @summary Get corporation contact labels
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public getCorporationsCorporationIdContactsLabels(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContactsApiFp(this.configuration)
      .getCorporationsCorporationIdContactsLabels(
        corporationId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
     * @summary Get contract bids
     * @param {number} characterId An EVE character ID
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterContractBids: async (
      characterId: number,
      contractId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterContractBids", "characterId", characterId);
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists("getCharacterContractBids", "contractId", contractId);
      const localVarPath =
        `/characters/{character_id}/contracts/{contract_id}/bids/`
          .replace(
            `{${"character_id"}}`,
            encodeURIComponent(String(characterId))
          )
          .replace(
            `{${"contract_id"}}`,
            encodeURIComponent(String(contractId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-contracts.read_character_contracts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
     * @summary Get contract items
     * @param {number} characterId An EVE character ID
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterContractItems: async (
      characterId: number,
      contractId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterContractItems",
        "characterId",
        characterId
      );
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists("getCharacterContractItems", "contractId", contractId);
      const localVarPath =
        `/characters/{character_id}/contracts/{contract_id}/items/`
          .replace(
            `{${"character_id"}}`,
            encodeURIComponent(String(characterId))
          )
          .replace(
            `{${"contract_id"}}`,
            encodeURIComponent(String(contractId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-contracts.read_character_contracts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
     * @summary Get contracts
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterContracts: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterContracts", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/contracts/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-contracts.read_character_contracts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
     * @summary Get public contract bids
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractsPublicBidsContractId: async (
      contractId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists(
        "getContractsPublicBidsContractId",
        "contractId",
        contractId
      );
      const localVarPath = `/contracts/public/bids/{contract_id}/`.replace(
        `{${"contract_id"}}`,
        encodeURIComponent(String(contractId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get public contract items
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractsPublicItemsContractId: async (
      contractId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists(
        "getContractsPublicItemsContractId",
        "contractId",
        contractId
      );
      const localVarPath = `/contracts/public/items/{contract_id}/`.replace(
        `{${"contract_id"}}`,
        encodeURIComponent(String(contractId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
     * @summary Get public contracts
     * @param {number} regionId An EVE region id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractsPublicRegionId: async (
      regionId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'regionId' is not null or undefined
      assertParamExists("getContractsPublicRegionId", "regionId", regionId);
      const localVarPath = `/contracts/public/{region_id}/`.replace(
        `{${"region_id"}}`,
        encodeURIComponent(String(regionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contracts
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdContracts: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdContracts",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/contracts/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-contracts.read_corporation_contracts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation contract bids
     * @param {number} contractId ID of a contract
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdContractsContractIdBids: async (
      contractId: number,
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdContractsContractIdBids",
        "contractId",
        contractId
      );
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdContractsContractIdBids",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/contracts/{contract_id}/bids/`
          .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
          .replace(
            `{${"corporation_id"}}`,
            encodeURIComponent(String(corporationId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-contracts.read_corporation_contracts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation contract items
     * @param {number} contractId ID of a contract
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdContractsContractIdItems: async (
      contractId: number,
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdContractsContractIdItems",
        "contractId",
        contractId
      );
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdContractsContractIdItems",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/contracts/{contract_id}/items/`
          .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
          .replace(
            `{${"corporation_id"}}`,
            encodeURIComponent(String(corporationId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-contracts.read_corporation_contracts.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ContractsApiAxiosParamCreator(configuration);
  return {
    /**
     * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
     * @summary Get contract bids
     * @param {number} characterId An EVE character ID
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterContractBids(
      characterId: number,
      contractId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<
        Array<GetCharactersCharacterIdContractsContractIdBids200Ok>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterContractBids(
          characterId,
          contractId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
     * @summary Get contract items
     * @param {number} characterId An EVE character ID
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterContractItems(
      characterId: number,
      contractId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<
        Array<GetCharactersCharacterIdContractsContractIdItems200Ok>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterContractItems(
          characterId,
          contractId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
     * @summary Get contracts
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterContracts(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdContracts200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterContracts(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
     * @summary Get public contract bids
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContractsPublicBidsContractId(
      contractId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetContractsPublicBidsContractId200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getContractsPublicBidsContractId(
          contractId,
          datasource,
          ifNoneMatch,
          page,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get public contract items
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContractsPublicItemsContractId(
      contractId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetContractsPublicItemsContractId200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getContractsPublicItemsContractId(
          contractId,
          datasource,
          ifNoneMatch,
          page,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
     * @summary Get public contracts
     * @param {number} regionId An EVE region id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContractsPublicRegionId(
      regionId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetContractsPublicRegionId200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getContractsPublicRegionId(
          regionId,
          datasource,
          ifNoneMatch,
          page,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contracts
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdContracts(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdContracts200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdContracts(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation contract bids
     * @param {number} contractId ID of a contract
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdContractsContractIdBids(
      contractId: number,
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<
        Array<GetCorporationsCorporationIdContractsContractIdBids200Ok>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdContractsContractIdBids(
          contractId,
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation contract items
     * @param {number} contractId ID of a contract
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdContractsContractIdItems(
      contractId: number,
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<
        Array<GetCorporationsCorporationIdContractsContractIdItems200Ok>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdContractsContractIdItems(
          contractId,
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ContractsApiFp(configuration);
  return {
    /**
     * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
     * @summary Get contract bids
     * @param {number} characterId An EVE character ID
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterContractBids(
      characterId: number,
      contractId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<
      Array<GetCharactersCharacterIdContractsContractIdBids200Ok>
    > {
      return localVarFp
        .getCharacterContractBids(
          characterId,
          contractId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
     * @summary Get contract items
     * @param {number} characterId An EVE character ID
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterContractItems(
      characterId: number,
      contractId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<
      Array<GetCharactersCharacterIdContractsContractIdItems200Ok>
    > {
      return localVarFp
        .getCharacterContractItems(
          characterId,
          contractId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
     * @summary Get contracts
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterContracts(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdContracts200Ok>> {
      return localVarFp
        .getCharacterContracts(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
     * @summary Get public contract bids
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractsPublicBidsContractId(
      contractId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: any
    ): AxiosPromise<Array<GetContractsPublicBidsContractId200Ok>> {
      return localVarFp
        .getContractsPublicBidsContractId(
          contractId,
          datasource,
          ifNoneMatch,
          page,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get public contract items
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractsPublicItemsContractId(
      contractId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: any
    ): AxiosPromise<Array<GetContractsPublicItemsContractId200Ok>> {
      return localVarFp
        .getContractsPublicItemsContractId(
          contractId,
          datasource,
          ifNoneMatch,
          page,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
     * @summary Get public contracts
     * @param {number} regionId An EVE region id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractsPublicRegionId(
      regionId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: any
    ): AxiosPromise<Array<GetContractsPublicRegionId200Ok>> {
      return localVarFp
        .getContractsPublicRegionId(
          regionId,
          datasource,
          ifNoneMatch,
          page,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contracts
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdContracts(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdContracts200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdContracts(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation contract bids
     * @param {number} contractId ID of a contract
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdContractsContractIdBids(
      contractId: number,
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<
      Array<GetCorporationsCorporationIdContractsContractIdBids200Ok>
    > {
      return localVarFp
        .getCorporationsCorporationIdContractsContractIdBids(
          contractId,
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation contract items
     * @param {number} contractId ID of a contract
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdContractsContractIdItems(
      contractId: number,
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<
      Array<GetCorporationsCorporationIdContractsContractIdItems200Ok>
    > {
      return localVarFp
        .getCorporationsCorporationIdContractsContractIdItems(
          contractId,
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
  /**
   * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
   * @summary Get contract bids
   * @param {number} characterId An EVE character ID
   * @param {number} contractId ID of a contract
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getCharacterContractBids(
    characterId: number,
    contractId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getCharacterContractBids(
        characterId,
        contractId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
   * @summary Get contract items
   * @param {number} characterId An EVE character ID
   * @param {number} contractId ID of a contract
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getCharacterContractItems(
    characterId: number,
    contractId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getCharacterContractItems(
        characterId,
        contractId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
   * @summary Get contracts
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getCharacterContracts(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getCharacterContracts(
        characterId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
   * @summary Get public contract bids
   * @param {number} contractId ID of a contract
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getContractsPublicBidsContractId(
    contractId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getContractsPublicBidsContractId(
        contractId,
        datasource,
        ifNoneMatch,
        page,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
   * @summary Get public contract items
   * @param {number} contractId ID of a contract
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getContractsPublicItemsContractId(
    contractId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getContractsPublicItemsContractId(
        contractId,
        datasource,
        ifNoneMatch,
        page,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
   * @summary Get public contracts
   * @param {number} regionId An EVE region id
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getContractsPublicRegionId(
    regionId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getContractsPublicRegionId(
        regionId,
        datasource,
        ifNoneMatch,
        page,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
   * @summary Get corporation contracts
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getCorporationsCorporationIdContracts(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getCorporationsCorporationIdContracts(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
   * @summary Get corporation contract bids
   * @param {number} contractId ID of a contract
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getCorporationsCorporationIdContractsContractIdBids(
    contractId: number,
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getCorporationsCorporationIdContractsContractIdBids(
        contractId,
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
   * @summary Get corporation contract items
   * @param {number} contractId ID of a contract
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getCorporationsCorporationIdContractsContractIdItems(
    contractId: number,
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getCorporationsCorporationIdContractsContractIdItems(
        contractId,
        corporationId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CorporationApi - axios parameter creator
 * @export
 */
export const CorporationApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/v5/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation information
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationId: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationId",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v3/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
     * @summary Get alliance history
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdAlliancehistory: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdAlliancehistory",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/alliancehistory/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/v3/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation blueprints
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdBlueprints: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdBlueprints",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/blueprints/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_blueprints.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v3/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get all corporation ALSC logs
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdContainersLogs: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdContainersLogs",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/containers/logs/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_container_logs.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/v2/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation divisions
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdDivisions: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdDivisions",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/divisions/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_divisions.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a corporation\'s facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/v2/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager
     * @summary Get corporation facilities
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdFacilities: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdFacilities",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/facilities/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_facilities.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the icon urls for a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/icons/`  Alternate route: `/v2/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation icon
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdIcons: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdIcons",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/icons/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a corporation\'s medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/v2/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation medals
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdMedals: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdMedals",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/medals/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_medals.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v2/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation issued medals
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdMedalsIssued: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdMedalsIssued",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/medals/issued/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_medals.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the current member list of a corporation, the token\'s character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/v4/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation members
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdMembers: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdMembers",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/members/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_corporation_membership.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a corporation\'s member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/v2/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation member limit
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdMembersLimit: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdMembersLimit",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/members/limit/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.track_members.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a corporation\'s members\' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/v2/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation\'s members\' titles
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdMembersTitles: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdMembersTitles",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/members/titles/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_titles.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns additional information about a corporation\'s members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/v2/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Track corporation members
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdMembertracking: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdMembertracking",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/membertracking/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.track_members.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/v2/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation member roles
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdRoles: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdRoles",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/roles/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_corporation_membership.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return how roles have changed for a coporation\'s members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/v2/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation member roles history
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdRolesHistory: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdRolesHistory",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/roles/history/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_corporation_membership.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation shareholders
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdShareholders: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdShareholders",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/shareholders/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-wallet.read_corporation_wallets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/v2/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation standings
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdStandings: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdStandings",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/standings/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_standings.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation starbases (POSes)
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdStarbases: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdStarbases",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/starbases/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_starbases.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get starbase (POS) detail
     * @param {number} corporationId An EVE corporation ID
     * @param {number} starbaseId An EVE starbase (POS) ID
     * @param {number} systemId The solar system this starbase (POS) is located in,
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdStarbasesStarbaseId: async (
      corporationId: number,
      starbaseId: number,
      systemId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdStarbasesStarbaseId",
        "corporationId",
        corporationId
      );
      // verify required parameter 'starbaseId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdStarbasesStarbaseId",
        "starbaseId",
        starbaseId
      );
      // verify required parameter 'systemId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdStarbasesStarbaseId",
        "systemId",
        systemId
      );
      const localVarPath =
        `/corporations/{corporation_id}/starbases/{starbase_id}/`
          .replace(
            `{${"corporation_id"}}`,
            encodeURIComponent(String(corporationId))
          )
          .replace(
            `{${"starbase_id"}}`,
            encodeURIComponent(String(starbaseId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_starbases.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (systemId !== undefined) {
        localVarQueryParameter["system_id"] = systemId;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of corporation structures. This route\'s version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v4/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager
     * @summary Get corporation structures
     * @param {number} corporationId An EVE corporation ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdStructures: async (
      corporationId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdStructures",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/structures/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_structures.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a corporation\'s titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/v2/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation titles
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdTitles: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdTitles",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/titles/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_titles.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/v2/corporations/npccorps/`  --- This route expires daily at 11:05
     * @summary Get npc corporations
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsNpccorps: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/corporations/npccorps/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CorporationApi - functional programming interface
 * @export
 */
export const CorporationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CorporationApiAxiosParamCreator(configuration);
  return {
    /**
     * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/v5/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation information
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationId(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCorporationsCorporationIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationId(
          corporationId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v3/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
     * @summary Get alliance history
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdAlliancehistory(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdAlliancehistory200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdAlliancehistory(
          corporationId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/v3/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation blueprints
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdBlueprints(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdBlueprints200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdBlueprints(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v3/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get all corporation ALSC logs
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdContainersLogs(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdContainersLogs200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdContainersLogs(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/v2/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation divisions
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdDivisions(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCorporationsCorporationIdDivisionsOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdDivisions(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a corporation\'s facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/v2/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager
     * @summary Get corporation facilities
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdFacilities(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdFacilities200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdFacilities(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get the icon urls for a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/icons/`  Alternate route: `/v2/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation icon
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdIcons(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCorporationsCorporationIdIconsOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdIcons(
          corporationId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a corporation\'s medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/v2/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation medals
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdMedals(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdMedals200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdMedals(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v2/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation issued medals
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdMedalsIssued(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdMedalsIssued200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdMedalsIssued(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return the current member list of a corporation, the token\'s character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/v4/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation members
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdMembers(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdMembers(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a corporation\'s member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/v2/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation member limit
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdMembersLimit(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdMembersLimit(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a corporation\'s members\' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/v2/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation\'s members\' titles
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdMembersTitles(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdMembersTitles200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdMembersTitles(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns additional information about a corporation\'s members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/v2/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Track corporation members
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdMembertracking(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdMembertracking200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdMembertracking(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/v2/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation member roles
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdRoles(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdRoles200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdRoles(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return how roles have changed for a coporation\'s members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/v2/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation member roles history
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdRolesHistory(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdRolesHistory200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdRolesHistory(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation shareholders
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdShareholders(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdShareholders200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdShareholders(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/v2/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation standings
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdStandings(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdStandings200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdStandings(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation starbases (POSes)
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdStarbases(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdStarbases200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdStarbases(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get starbase (POS) detail
     * @param {number} corporationId An EVE corporation ID
     * @param {number} starbaseId An EVE starbase (POS) ID
     * @param {number} systemId The solar system this starbase (POS) is located in,
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdStarbasesStarbaseId(
      corporationId: number,
      starbaseId: number,
      systemId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCorporationsCorporationIdStarbasesStarbaseIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdStarbasesStarbaseId(
          corporationId,
          starbaseId,
          systemId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of corporation structures. This route\'s version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v4/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager
     * @summary Get corporation structures
     * @param {number} corporationId An EVE corporation ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdStructures(
      corporationId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdStructures200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdStructures(
          corporationId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a corporation\'s titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/v2/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation titles
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdTitles(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdTitles200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdTitles(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/v2/corporations/npccorps/`  --- This route expires daily at 11:05
     * @summary Get npc corporations
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsNpccorps(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsNpccorps(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CorporationApi - factory interface
 * @export
 */
export const CorporationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CorporationApiFp(configuration);
  return {
    /**
     * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/v5/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation information
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationId(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetCorporationsCorporationIdOk> {
      return localVarFp
        .getCorporationsCorporationId(
          corporationId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v3/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
     * @summary Get alliance history
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdAlliancehistory(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdAlliancehistory200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdAlliancehistory(
          corporationId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/v3/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation blueprints
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdBlueprints(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdBlueprints200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdBlueprints(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v3/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get all corporation ALSC logs
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdContainersLogs(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdContainersLogs200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdContainersLogs(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/v2/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation divisions
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdDivisions(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCorporationsCorporationIdDivisionsOk> {
      return localVarFp
        .getCorporationsCorporationIdDivisions(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a corporation\'s facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/v2/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager
     * @summary Get corporation facilities
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdFacilities(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdFacilities200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdFacilities(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the icon urls for a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/icons/`  Alternate route: `/v2/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation icon
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdIcons(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetCorporationsCorporationIdIconsOk> {
      return localVarFp
        .getCorporationsCorporationIdIcons(
          corporationId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a corporation\'s medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/v2/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation medals
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdMedals(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdMedals200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdMedals(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v2/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation issued medals
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdMedalsIssued(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdMedalsIssued200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdMedalsIssued(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return the current member list of a corporation, the token\'s character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/v4/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation members
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdMembers(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getCorporationsCorporationIdMembers(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a corporation\'s member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/v2/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation member limit
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdMembersLimit(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .getCorporationsCorporationIdMembersLimit(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a corporation\'s members\' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/v2/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation\'s members\' titles
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdMembersTitles(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdMembersTitles200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdMembersTitles(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns additional information about a corporation\'s members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/v2/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Track corporation members
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdMembertracking(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdMembertracking200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdMembertracking(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/v2/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation member roles
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdRoles(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdRoles200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdRoles(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return how roles have changed for a coporation\'s members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/v2/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation member roles history
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdRolesHistory(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdRolesHistory200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdRolesHistory(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation shareholders
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdShareholders(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdShareholders200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdShareholders(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/v2/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation standings
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdStandings(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdStandings200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdStandings(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation starbases (POSes)
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdStarbases(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdStarbases200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdStarbases(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get starbase (POS) detail
     * @param {number} corporationId An EVE corporation ID
     * @param {number} starbaseId An EVE starbase (POS) ID
     * @param {number} systemId The solar system this starbase (POS) is located in,
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdStarbasesStarbaseId(
      corporationId: number,
      starbaseId: number,
      systemId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCorporationsCorporationIdStarbasesStarbaseIdOk> {
      return localVarFp
        .getCorporationsCorporationIdStarbasesStarbaseId(
          corporationId,
          starbaseId,
          systemId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of corporation structures. This route\'s version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v4/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager
     * @summary Get corporation structures
     * @param {number} corporationId An EVE corporation ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdStructures(
      corporationId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdStructures200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdStructures(
          corporationId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a corporation\'s titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/v2/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get corporation titles
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdTitles(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdTitles200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdTitles(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/v2/corporations/npccorps/`  --- This route expires daily at 11:05
     * @summary Get npc corporations
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsNpccorps(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getCorporationsNpccorps(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CorporationApi - object-oriented interface
 * @export
 * @class CorporationApi
 * @extends {BaseAPI}
 */
export class CorporationApi extends BaseAPI {
  /**
   * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/v5/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
   * @summary Get corporation information
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationId(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationId(
        corporationId,
        datasource,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v3/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
   * @summary Get alliance history
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdAlliancehistory(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdAlliancehistory(
        corporationId,
        datasource,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/v3/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get corporation blueprints
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdBlueprints(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdBlueprints(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v3/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get all corporation ALSC logs
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdContainersLogs(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdContainersLogs(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/v2/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get corporation divisions
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdDivisions(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdDivisions(
        corporationId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a corporation\'s facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/v2/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager
   * @summary Get corporation facilities
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdFacilities(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdFacilities(
        corporationId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the icon urls for a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/icons/`  Alternate route: `/v2/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds
   * @summary Get corporation icon
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdIcons(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdIcons(
        corporationId,
        datasource,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a corporation\'s medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/v2/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
   * @summary Get corporation medals
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdMedals(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdMedals(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v2/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get corporation issued medals
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdMedalsIssued(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdMedalsIssued(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return the current member list of a corporation, the token\'s character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/v4/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
   * @summary Get corporation members
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdMembers(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdMembers(
        corporationId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a corporation\'s member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/v2/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get corporation member limit
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdMembersLimit(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdMembersLimit(
        corporationId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a corporation\'s members\' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/v2/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get corporation\'s members\' titles
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdMembersTitles(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdMembersTitles(
        corporationId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns additional information about a corporation\'s members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/v2/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Track corporation members
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdMembertracking(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdMembertracking(
        corporationId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/v2/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
   * @summary Get corporation member roles
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdRoles(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdRoles(
        corporationId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return how roles have changed for a coporation\'s members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/v2/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get corporation member roles history
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdRolesHistory(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdRolesHistory(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get corporation shareholders
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdShareholders(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdShareholders(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/v2/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
   * @summary Get corporation standings
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdStandings(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdStandings(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get corporation starbases (POSes)
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdStarbases(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdStarbases(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get starbase (POS) detail
   * @param {number} corporationId An EVE corporation ID
   * @param {number} starbaseId An EVE starbase (POS) ID
   * @param {number} systemId The solar system this starbase (POS) is located in,
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdStarbasesStarbaseId(
    corporationId: number,
    starbaseId: number,
    systemId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdStarbasesStarbaseId(
        corporationId,
        starbaseId,
        systemId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of corporation structures. This route\'s version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v4/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager
   * @summary Get corporation structures
   * @param {number} corporationId An EVE corporation ID
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdStructures(
    corporationId: number,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdStructures(
        corporationId,
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a corporation\'s titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/v2/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get corporation titles
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsCorporationIdTitles(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsCorporationIdTitles(
        corporationId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/v2/corporations/npccorps/`  --- This route expires daily at 11:05
   * @summary Get npc corporations
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorporationApi
   */
  public getCorporationsNpccorps(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return CorporationApiFp(this.configuration)
      .getCorporationsNpccorps(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DogmaApi - axios parameter creator
 * @export
 */
export const DogmaApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
     * @summary Get attributes
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDogmaAttributes: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/dogma/attributes/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
     * @summary Get attribute information
     * @param {number} attributeId A dogma attribute ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDogmaAttributesAttributeId: async (
      attributeId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'attributeId' is not null or undefined
      assertParamExists(
        "getDogmaAttributesAttributeId",
        "attributeId",
        attributeId
      );
      const localVarPath = `/dogma/attributes/{attribute_id}/`.replace(
        `{${"attribute_id"}}`,
        encodeURIComponent(String(attributeId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
     * @summary Get dynamic item information
     * @param {number} itemId item_id integer
     * @param {number} typeId type_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDogmaDynamicItemsTypeIdItemId: async (
      itemId: number,
      typeId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'itemId' is not null or undefined
      assertParamExists("getDogmaDynamicItemsTypeIdItemId", "itemId", itemId);
      // verify required parameter 'typeId' is not null or undefined
      assertParamExists("getDogmaDynamicItemsTypeIdItemId", "typeId", typeId);
      const localVarPath = `/dogma/dynamic/items/{type_id}/{item_id}/`
        .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)))
        .replace(`{${"type_id"}}`, encodeURIComponent(String(typeId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
     * @summary Get effects
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDogmaEffects: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/dogma/effects/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
     * @summary Get effect information
     * @param {number} effectId A dogma effect ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDogmaEffectsEffectId: async (
      effectId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'effectId' is not null or undefined
      assertParamExists("getDogmaEffectsEffectId", "effectId", effectId);
      const localVarPath = `/dogma/effects/{effect_id}/`.replace(
        `{${"effect_id"}}`,
        encodeURIComponent(String(effectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DogmaApi - functional programming interface
 * @export
 */
export const DogmaApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DogmaApiAxiosParamCreator(configuration);
  return {
    /**
     * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
     * @summary Get attributes
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDogmaAttributes(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDogmaAttributes(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
     * @summary Get attribute information
     * @param {number} attributeId A dogma attribute ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDogmaAttributesAttributeId(
      attributeId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetDogmaAttributesAttributeIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDogmaAttributesAttributeId(
          attributeId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
     * @summary Get dynamic item information
     * @param {number} itemId item_id integer
     * @param {number} typeId type_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDogmaDynamicItemsTypeIdItemId(
      itemId: number,
      typeId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetDogmaDynamicItemsTypeIdItemIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDogmaDynamicItemsTypeIdItemId(
          itemId,
          typeId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
     * @summary Get effects
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDogmaEffects(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDogmaEffects(
        datasource,
        ifNoneMatch,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
     * @summary Get effect information
     * @param {number} effectId A dogma effect ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDogmaEffectsEffectId(
      effectId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetDogmaEffectsEffectIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDogmaEffectsEffectId(
          effectId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * DogmaApi - factory interface
 * @export
 */
export const DogmaApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DogmaApiFp(configuration);
  return {
    /**
     * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
     * @summary Get attributes
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDogmaAttributes(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getDogmaAttributes(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
     * @summary Get attribute information
     * @param {number} attributeId A dogma attribute ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDogmaAttributesAttributeId(
      attributeId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetDogmaAttributesAttributeIdOk> {
      return localVarFp
        .getDogmaAttributesAttributeId(
          attributeId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
     * @summary Get dynamic item information
     * @param {number} itemId item_id integer
     * @param {number} typeId type_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDogmaDynamicItemsTypeIdItemId(
      itemId: number,
      typeId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetDogmaDynamicItemsTypeIdItemIdOk> {
      return localVarFp
        .getDogmaDynamicItemsTypeIdItemId(
          itemId,
          typeId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
     * @summary Get effects
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDogmaEffects(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getDogmaEffects(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
     * @summary Get effect information
     * @param {number} effectId A dogma effect ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDogmaEffectsEffectId(
      effectId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetDogmaEffectsEffectIdOk> {
      return localVarFp
        .getDogmaEffectsEffectId(effectId, datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DogmaApi - object-oriented interface
 * @export
 * @class DogmaApi
 * @extends {BaseAPI}
 */
export class DogmaApi extends BaseAPI {
  /**
   * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
   * @summary Get attributes
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DogmaApi
   */
  public getDogmaAttributes(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return DogmaApiFp(this.configuration)
      .getDogmaAttributes(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
   * @summary Get attribute information
   * @param {number} attributeId A dogma attribute ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DogmaApi
   */
  public getDogmaAttributesAttributeId(
    attributeId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return DogmaApiFp(this.configuration)
      .getDogmaAttributesAttributeId(
        attributeId,
        datasource,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
   * @summary Get dynamic item information
   * @param {number} itemId item_id integer
   * @param {number} typeId type_id integer
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DogmaApi
   */
  public getDogmaDynamicItemsTypeIdItemId(
    itemId: number,
    typeId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return DogmaApiFp(this.configuration)
      .getDogmaDynamicItemsTypeIdItemId(
        itemId,
        typeId,
        datasource,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
   * @summary Get effects
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DogmaApi
   */
  public getDogmaEffects(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return DogmaApiFp(this.configuration)
      .getDogmaEffects(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
   * @summary Get effect information
   * @param {number} effectId A dogma effect ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DogmaApi
   */
  public getDogmaEffectsEffectId(
    effectId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return DogmaApiFp(this.configuration)
      .getDogmaEffectsEffectId(effectId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FactionWarfareApi - axios parameter creator
 * @export
 */
export const FactionWarfareApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
     * @summary Overview of a character involved in faction warfare
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterCharacterFwStats: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterCharacterFwStats",
        "characterId",
        characterId
      );
      const localVarPath = `/characters/{character_id}/fw/stats/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_fw_stats.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
     * @summary Overview of a corporation involved in faction warfare
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdFwStats: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdFwStats",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/fw/stats/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-corporations.read_fw_stats.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
     * @summary List of the top factions in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFwLeaderboards: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/fw/leaderboards/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
     * @summary List of the top pilots in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFwLeaderboardsCharacters: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/fw/leaderboards/characters/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
     * @summary List of the top corporations in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFwLeaderboardsCorporations: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/fw/leaderboards/corporations/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
     * @summary An overview of statistics about factions involved in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFwStats: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/fw/stats/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/legacy/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
     * @summary Ownership of faction warfare systems
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFwSystems: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/fw/systems/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
     * @summary Data about which NPC factions are at war
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFwWars: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/fw/wars/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FactionWarfareApi - functional programming interface
 * @export
 */
export const FactionWarfareApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    FactionWarfareApiAxiosParamCreator(configuration);
  return {
    /**
     * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
     * @summary Overview of a character involved in faction warfare
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterCharacterFwStats(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdFwStatsOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterCharacterFwStats(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
     * @summary Overview of a corporation involved in faction warfare
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdFwStats(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCorporationsCorporationIdFwStatsOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdFwStats(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
     * @summary List of the top factions in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFwLeaderboards(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetFwLeaderboardsOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFwLeaderboards(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
     * @summary List of the top pilots in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFwLeaderboardsCharacters(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetFwLeaderboardsCharactersOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFwLeaderboardsCharacters(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
     * @summary List of the top corporations in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFwLeaderboardsCorporations(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetFwLeaderboardsCorporationsOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFwLeaderboardsCorporations(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
     * @summary An overview of statistics about factions involved in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFwStats(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetFwStats200Ok>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFwStats(
        datasource,
        ifNoneMatch,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/legacy/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
     * @summary Ownership of faction warfare systems
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFwSystems(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetFwSystems200Ok>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFwSystems(
        datasource,
        ifNoneMatch,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
     * @summary Data about which NPC factions are at war
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFwWars(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetFwWars200Ok>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFwWars(
        datasource,
        ifNoneMatch,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * FactionWarfareApi - factory interface
 * @export
 */
export const FactionWarfareApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FactionWarfareApiFp(configuration);
  return {
    /**
     * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
     * @summary Overview of a character involved in faction warfare
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterCharacterFwStats(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdFwStatsOk> {
      return localVarFp
        .getCharacterCharacterFwStats(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
     * @summary Overview of a corporation involved in faction warfare
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdFwStats(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCorporationsCorporationIdFwStatsOk> {
      return localVarFp
        .getCorporationsCorporationIdFwStats(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
     * @summary List of the top factions in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFwLeaderboards(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetFwLeaderboardsOk> {
      return localVarFp
        .getFwLeaderboards(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
     * @summary List of the top pilots in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFwLeaderboardsCharacters(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetFwLeaderboardsCharactersOk> {
      return localVarFp
        .getFwLeaderboardsCharacters(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
     * @summary List of the top corporations in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFwLeaderboardsCorporations(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetFwLeaderboardsCorporationsOk> {
      return localVarFp
        .getFwLeaderboardsCorporations(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
     * @summary An overview of statistics about factions involved in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFwStats(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetFwStats200Ok>> {
      return localVarFp
        .getFwStats(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/legacy/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
     * @summary Ownership of faction warfare systems
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFwSystems(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetFwSystems200Ok>> {
      return localVarFp
        .getFwSystems(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
     * @summary Data about which NPC factions are at war
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFwWars(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetFwWars200Ok>> {
      return localVarFp
        .getFwWars(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FactionWarfareApi - object-oriented interface
 * @export
 * @class FactionWarfareApi
 * @extends {BaseAPI}
 */
export class FactionWarfareApi extends BaseAPI {
  /**
   * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
   * @summary Overview of a character involved in faction warfare
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FactionWarfareApi
   */
  public getCharacterCharacterFwStats(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FactionWarfareApiFp(this.configuration)
      .getCharacterCharacterFwStats(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
   * @summary Overview of a corporation involved in faction warfare
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FactionWarfareApi
   */
  public getCorporationsCorporationIdFwStats(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FactionWarfareApiFp(this.configuration)
      .getCorporationsCorporationIdFwStats(
        corporationId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
   * @summary List of the top factions in faction warfare
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FactionWarfareApi
   */
  public getFwLeaderboards(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return FactionWarfareApiFp(this.configuration)
      .getFwLeaderboards(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
   * @summary List of the top pilots in faction warfare
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FactionWarfareApi
   */
  public getFwLeaderboardsCharacters(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return FactionWarfareApiFp(this.configuration)
      .getFwLeaderboardsCharacters(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
   * @summary List of the top corporations in faction warfare
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FactionWarfareApi
   */
  public getFwLeaderboardsCorporations(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return FactionWarfareApiFp(this.configuration)
      .getFwLeaderboardsCorporations(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
   * @summary An overview of statistics about factions involved in faction warfare
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FactionWarfareApi
   */
  public getFwStats(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return FactionWarfareApiFp(this.configuration)
      .getFwStats(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/legacy/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
   * @summary Ownership of faction warfare systems
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FactionWarfareApi
   */
  public getFwSystems(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return FactionWarfareApiFp(this.configuration)
      .getFwSystems(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
   * @summary Data about which NPC factions are at war
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FactionWarfareApi
   */
  public getFwWars(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return FactionWarfareApiFp(this.configuration)
      .getFwWars(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FittingsApi - axios parameter creator
 * @export
 */
export const FittingsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`
     * @summary Create fitting
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdFittingsFitting} fitting Details about the new fitting
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCharacterFitting: async (
      characterId: number,
      fitting: PostCharactersCharacterIdFittingsFitting,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("addCharacterFitting", "characterId", characterId);
      // verify required parameter 'fitting' is not null or undefined
      assertParamExists("addCharacterFitting", "fitting", fitting);
      const localVarPath = `/characters/{character_id}/fittings/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fittings.write_fittings.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        fitting,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/`
     * @summary Delete fitting
     * @param {number} characterId An EVE character ID
     * @param {number} fittingId ID for a fitting of this character
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCharacterFitting: async (
      characterId: number,
      fittingId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("deleteCharacterFitting", "characterId", characterId);
      // verify required parameter 'fittingId' is not null or undefined
      assertParamExists("deleteCharacterFitting", "fittingId", fittingId);
      const localVarPath = `/characters/{character_id}/fittings/{fitting_id}/`
        .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
        .replace(`{${"fitting_id"}}`, encodeURIComponent(String(fittingId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fittings.write_fittings.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
     * @summary Get fittings
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterFittings: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterFittings", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/fittings/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fittings.read_fittings.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FittingsApi - functional programming interface
 * @export
 */
export const FittingsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FittingsApiAxiosParamCreator(configuration);
  return {
    /**
     * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`
     * @summary Create fitting
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdFittingsFitting} fitting Details about the new fitting
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addCharacterFitting(
      characterId: number,
      fitting: PostCharactersCharacterIdFittingsFitting,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PostCharactersCharacterIdFittingsCreated>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addCharacterFitting(
          characterId,
          fitting,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/`
     * @summary Delete fitting
     * @param {number} characterId An EVE character ID
     * @param {number} fittingId ID for a fitting of this character
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCharacterFitting(
      characterId: number,
      fittingId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteCharacterFitting(
          characterId,
          fittingId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
     * @summary Get fittings
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterFittings(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdFittings200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterFittings(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * FittingsApi - factory interface
 * @export
 */
export const FittingsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FittingsApiFp(configuration);
  return {
    /**
     * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`
     * @summary Create fitting
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdFittingsFitting} fitting Details about the new fitting
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCharacterFitting(
      characterId: number,
      fitting: PostCharactersCharacterIdFittingsFitting,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<PostCharactersCharacterIdFittingsCreated> {
      return localVarFp
        .addCharacterFitting(characterId, fitting, datasource, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/`
     * @summary Delete fitting
     * @param {number} characterId An EVE character ID
     * @param {number} fittingId ID for a fitting of this character
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCharacterFitting(
      characterId: number,
      fittingId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteCharacterFitting(
          characterId,
          fittingId,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
     * @summary Get fittings
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterFittings(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdFittings200Ok>> {
      return localVarFp
        .getCharacterFittings(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FittingsApi - object-oriented interface
 * @export
 * @class FittingsApi
 * @extends {BaseAPI}
 */
export class FittingsApi extends BaseAPI {
  /**
   * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`
   * @summary Create fitting
   * @param {number} characterId An EVE character ID
   * @param {PostCharactersCharacterIdFittingsFitting} fitting Details about the new fitting
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FittingsApi
   */
  public addCharacterFitting(
    characterId: number,
    fitting: PostCharactersCharacterIdFittingsFitting,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FittingsApiFp(this.configuration)
      .addCharacterFitting(characterId, fitting, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/`
   * @summary Delete fitting
   * @param {number} characterId An EVE character ID
   * @param {number} fittingId ID for a fitting of this character
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FittingsApi
   */
  public deleteCharacterFitting(
    characterId: number,
    fittingId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FittingsApiFp(this.configuration)
      .deleteCharacterFitting(
        characterId,
        fittingId,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
   * @summary Get fittings
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FittingsApi
   */
  public getCharacterFittings(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FittingsApiFp(this.configuration)
      .getCharacterFittings(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FleetsApi - axios parameter creator
 * @export
 */
export const FleetsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/`
     * @summary Kick fleet member
     * @param {number} fleetId ID for a fleet
     * @param {number} memberId The character ID of a member in this fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFleetsFleetIdMembersMemberId: async (
      fleetId: number,
      memberId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists(
        "deleteFleetsFleetIdMembersMemberId",
        "fleetId",
        fleetId
      );
      // verify required parameter 'memberId' is not null or undefined
      assertParamExists(
        "deleteFleetsFleetIdMembersMemberId",
        "memberId",
        memberId
      );
      const localVarPath = `/fleets/{fleet_id}/members/{member_id}/`
        .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
        .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.write_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/`
     * @summary Delete fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} squadId The squad to delete
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFleetsFleetIdSquadsSquadId: async (
      fleetId: number,
      squadId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists("deleteFleetsFleetIdSquadsSquadId", "fleetId", fleetId);
      // verify required parameter 'squadId' is not null or undefined
      assertParamExists("deleteFleetsFleetIdSquadsSquadId", "squadId", squadId);
      const localVarPath = `/fleets/{fleet_id}/squads/{squad_id}/`
        .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
        .replace(`{${"squad_id"}}`, encodeURIComponent(String(squadId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.write_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/`
     * @summary Delete fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing to delete
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFleetsFleetIdWingsWingId: async (
      fleetId: number,
      wingId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists("deleteFleetsFleetIdWingsWingId", "fleetId", fleetId);
      // verify required parameter 'wingId' is not null or undefined
      assertParamExists("deleteFleetsFleetIdWingsWingId", "wingId", wingId);
      const localVarPath = `/fleets/{fleet_id}/wings/{wing_id}/`
        .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
        .replace(`{${"wing_id"}}`, encodeURIComponent(String(wingId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.write_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the fleet ID the character is in, if any.  --- Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds  --- Warning: This route has an upgrade available  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/fleet/)
     * @summary Get character fleet info
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterFleet: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterFleet", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/fleet/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.read_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet information
     * @param {number} fleetId ID for a fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetId: async (
      fleetId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists("getFleetsFleetId", "fleetId", fleetId);
      const localVarPath = `/fleets/{fleet_id}/`.replace(
        `{${"fleet_id"}}`,
        encodeURIComponent(String(fleetId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.read_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet members
     * @param {number} fleetId ID for a fleet
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetIdMembers: async (
      fleetId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists("getFleetsFleetIdMembers", "fleetId", fleetId);
      const localVarPath = `/fleets/{fleet_id}/members/`.replace(
        `{${"fleet_id"}}`,
        encodeURIComponent(String(fleetId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.read_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet wings
     * @param {number} fleetId ID for a fleet
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetIdWings: async (
      fleetId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists("getFleetsFleetIdWings", "fleetId", fleetId);
      const localVarPath = `/fleets/{fleet_id}/wings/`.replace(
        `{${"fleet_id"}}`,
        encodeURIComponent(String(fleetId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.read_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`
     * @summary Create fleet invitation
     * @param {number} fleetId ID for a fleet
     * @param {PostFleetsFleetIdMembersInvitation} invitation Details of the invitation
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFleetsFleetIdMembers: async (
      fleetId: number,
      invitation: PostFleetsFleetIdMembersInvitation,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists("postFleetsFleetIdMembers", "fleetId", fleetId);
      // verify required parameter 'invitation' is not null or undefined
      assertParamExists("postFleetsFleetIdMembers", "invitation", invitation);
      const localVarPath = `/fleets/{fleet_id}/members/`.replace(
        `{${"fleet_id"}}`,
        encodeURIComponent(String(fleetId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.write_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        invitation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`
     * @summary Create fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFleetsFleetIdWings: async (
      fleetId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists("postFleetsFleetIdWings", "fleetId", fleetId);
      const localVarPath = `/fleets/{fleet_id}/wings/`.replace(
        `{${"fleet_id"}}`,
        encodeURIComponent(String(fleetId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.write_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/`
     * @summary Create fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing_id to create squad in
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFleetsFleetIdWingsWingIdSquads: async (
      fleetId: number,
      wingId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists(
        "postFleetsFleetIdWingsWingIdSquads",
        "fleetId",
        fleetId
      );
      // verify required parameter 'wingId' is not null or undefined
      assertParamExists("postFleetsFleetIdWingsWingIdSquads", "wingId", wingId);
      const localVarPath = `/fleets/{fleet_id}/wings/{wing_id}/squads/`
        .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
        .replace(`{${"wing_id"}}`, encodeURIComponent(String(wingId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.write_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`
     * @summary Update fleet
     * @param {number} fleetId ID for a fleet
     * @param {PutFleetsFleetIdNewSettings} newSettings What to update for this fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putFleetsFleetId: async (
      fleetId: number,
      newSettings: PutFleetsFleetIdNewSettings,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists("putFleetsFleetId", "fleetId", fleetId);
      // verify required parameter 'newSettings' is not null or undefined
      assertParamExists("putFleetsFleetId", "newSettings", newSettings);
      const localVarPath = `/fleets/{fleet_id}/`.replace(
        `{${"fleet_id"}}`,
        encodeURIComponent(String(fleetId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.write_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        newSettings,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/`
     * @summary Move fleet member
     * @param {number} fleetId ID for a fleet
     * @param {number} memberId The character ID of a member in this fleet
     * @param {PutFleetsFleetIdMembersMemberIdMovement} movement Details of the invitation
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putFleetsFleetIdMembersMemberId: async (
      fleetId: number,
      memberId: number,
      movement: PutFleetsFleetIdMembersMemberIdMovement,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists("putFleetsFleetIdMembersMemberId", "fleetId", fleetId);
      // verify required parameter 'memberId' is not null or undefined
      assertParamExists(
        "putFleetsFleetIdMembersMemberId",
        "memberId",
        memberId
      );
      // verify required parameter 'movement' is not null or undefined
      assertParamExists(
        "putFleetsFleetIdMembersMemberId",
        "movement",
        movement
      );
      const localVarPath = `/fleets/{fleet_id}/members/{member_id}/`
        .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
        .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.write_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        movement,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/`
     * @summary Rename fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} squadId The squad to rename
     * @param {PutFleetsFleetIdSquadsSquadIdNaming} naming New name of the squad
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putFleetsFleetIdSquadsSquadId: async (
      fleetId: number,
      squadId: number,
      naming: PutFleetsFleetIdSquadsSquadIdNaming,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists("putFleetsFleetIdSquadsSquadId", "fleetId", fleetId);
      // verify required parameter 'squadId' is not null or undefined
      assertParamExists("putFleetsFleetIdSquadsSquadId", "squadId", squadId);
      // verify required parameter 'naming' is not null or undefined
      assertParamExists("putFleetsFleetIdSquadsSquadId", "naming", naming);
      const localVarPath = `/fleets/{fleet_id}/squads/{squad_id}/`
        .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
        .replace(`{${"squad_id"}}`, encodeURIComponent(String(squadId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.write_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        naming,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/`
     * @summary Rename fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing to rename
     * @param {PutFleetsFleetIdWingsWingIdNaming} naming New name of the wing
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putFleetsFleetIdWingsWingId: async (
      fleetId: number,
      wingId: number,
      naming: PutFleetsFleetIdWingsWingIdNaming,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleetId' is not null or undefined
      assertParamExists("putFleetsFleetIdWingsWingId", "fleetId", fleetId);
      // verify required parameter 'wingId' is not null or undefined
      assertParamExists("putFleetsFleetIdWingsWingId", "wingId", wingId);
      // verify required parameter 'naming' is not null or undefined
      assertParamExists("putFleetsFleetIdWingsWingId", "naming", naming);
      const localVarPath = `/fleets/{fleet_id}/wings/{wing_id}/`
        .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
        .replace(`{${"wing_id"}}`, encodeURIComponent(String(wingId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-fleets.write_fleet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        naming,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FleetsApi - functional programming interface
 * @export
 */
export const FleetsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FleetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/`
     * @summary Kick fleet member
     * @param {number} fleetId ID for a fleet
     * @param {number} memberId The character ID of a member in this fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFleetsFleetIdMembersMemberId(
      fleetId: number,
      memberId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFleetsFleetIdMembersMemberId(
          fleetId,
          memberId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/`
     * @summary Delete fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} squadId The squad to delete
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFleetsFleetIdSquadsSquadId(
      fleetId: number,
      squadId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFleetsFleetIdSquadsSquadId(
          fleetId,
          squadId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/`
     * @summary Delete fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing to delete
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFleetsFleetIdWingsWingId(
      fleetId: number,
      wingId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFleetsFleetIdWingsWingId(
          fleetId,
          wingId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return the fleet ID the character is in, if any.  --- Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds  --- Warning: This route has an upgrade available  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/fleet/)
     * @summary Get character fleet info
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterFleet(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdFleetOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterFleet(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet information
     * @param {number} fleetId ID for a fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetsFleetId(
      fleetId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetFleetsFleetIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFleetsFleetId(
          fleetId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet members
     * @param {number} fleetId ID for a fleet
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetsFleetIdMembers(
      fleetId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetFleetsFleetIdMembers200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFleetsFleetIdMembers(
          fleetId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet wings
     * @param {number} fleetId ID for a fleet
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetsFleetIdWings(
      fleetId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetFleetsFleetIdWings200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFleetsFleetIdWings(
          fleetId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`
     * @summary Create fleet invitation
     * @param {number} fleetId ID for a fleet
     * @param {PostFleetsFleetIdMembersInvitation} invitation Details of the invitation
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postFleetsFleetIdMembers(
      fleetId: number,
      invitation: PostFleetsFleetIdMembersInvitation,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postFleetsFleetIdMembers(
          fleetId,
          invitation,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`
     * @summary Create fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postFleetsFleetIdWings(
      fleetId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PostFleetsFleetIdWingsCreated>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postFleetsFleetIdWings(
          fleetId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/`
     * @summary Create fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing_id to create squad in
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postFleetsFleetIdWingsWingIdSquads(
      fleetId: number,
      wingId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PostFleetsFleetIdWingsWingIdSquadsCreated>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postFleetsFleetIdWingsWingIdSquads(
          fleetId,
          wingId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`
     * @summary Update fleet
     * @param {number} fleetId ID for a fleet
     * @param {PutFleetsFleetIdNewSettings} newSettings What to update for this fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putFleetsFleetId(
      fleetId: number,
      newSettings: PutFleetsFleetIdNewSettings,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putFleetsFleetId(
          fleetId,
          newSettings,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/`
     * @summary Move fleet member
     * @param {number} fleetId ID for a fleet
     * @param {number} memberId The character ID of a member in this fleet
     * @param {PutFleetsFleetIdMembersMemberIdMovement} movement Details of the invitation
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putFleetsFleetIdMembersMemberId(
      fleetId: number,
      memberId: number,
      movement: PutFleetsFleetIdMembersMemberIdMovement,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putFleetsFleetIdMembersMemberId(
          fleetId,
          memberId,
          movement,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/`
     * @summary Rename fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} squadId The squad to rename
     * @param {PutFleetsFleetIdSquadsSquadIdNaming} naming New name of the squad
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putFleetsFleetIdSquadsSquadId(
      fleetId: number,
      squadId: number,
      naming: PutFleetsFleetIdSquadsSquadIdNaming,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putFleetsFleetIdSquadsSquadId(
          fleetId,
          squadId,
          naming,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/`
     * @summary Rename fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing to rename
     * @param {PutFleetsFleetIdWingsWingIdNaming} naming New name of the wing
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putFleetsFleetIdWingsWingId(
      fleetId: number,
      wingId: number,
      naming: PutFleetsFleetIdWingsWingIdNaming,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putFleetsFleetIdWingsWingId(
          fleetId,
          wingId,
          naming,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * FleetsApi - factory interface
 * @export
 */
export const FleetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FleetsApiFp(configuration);
  return {
    /**
     * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/`
     * @summary Kick fleet member
     * @param {number} fleetId ID for a fleet
     * @param {number} memberId The character ID of a member in this fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFleetsFleetIdMembersMemberId(
      fleetId: number,
      memberId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteFleetsFleetIdMembersMemberId(
          fleetId,
          memberId,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/`
     * @summary Delete fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} squadId The squad to delete
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFleetsFleetIdSquadsSquadId(
      fleetId: number,
      squadId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteFleetsFleetIdSquadsSquadId(
          fleetId,
          squadId,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/`
     * @summary Delete fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing to delete
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFleetsFleetIdWingsWingId(
      fleetId: number,
      wingId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteFleetsFleetIdWingsWingId(
          fleetId,
          wingId,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return the fleet ID the character is in, if any.  --- Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds  --- Warning: This route has an upgrade available  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/fleet/)
     * @summary Get character fleet info
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterFleet(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdFleetOk> {
      return localVarFp
        .getCharacterFleet(characterId, datasource, ifNoneMatch, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet information
     * @param {number} fleetId ID for a fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetId(
      fleetId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetFleetsFleetIdOk> {
      return localVarFp
        .getFleetsFleetId(fleetId, datasource, ifNoneMatch, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet members
     * @param {number} fleetId ID for a fleet
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetIdMembers(
      fleetId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetFleetsFleetIdMembers200Ok>> {
      return localVarFp
        .getFleetsFleetIdMembers(
          fleetId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet wings
     * @param {number} fleetId ID for a fleet
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetIdWings(
      fleetId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetFleetsFleetIdWings200Ok>> {
      return localVarFp
        .getFleetsFleetIdWings(
          fleetId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`
     * @summary Create fleet invitation
     * @param {number} fleetId ID for a fleet
     * @param {PostFleetsFleetIdMembersInvitation} invitation Details of the invitation
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFleetsFleetIdMembers(
      fleetId: number,
      invitation: PostFleetsFleetIdMembersInvitation,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .postFleetsFleetIdMembers(
          fleetId,
          invitation,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`
     * @summary Create fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFleetsFleetIdWings(
      fleetId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<PostFleetsFleetIdWingsCreated> {
      return localVarFp
        .postFleetsFleetIdWings(fleetId, datasource, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/`
     * @summary Create fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing_id to create squad in
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFleetsFleetIdWingsWingIdSquads(
      fleetId: number,
      wingId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<PostFleetsFleetIdWingsWingIdSquadsCreated> {
      return localVarFp
        .postFleetsFleetIdWingsWingIdSquads(
          fleetId,
          wingId,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`
     * @summary Update fleet
     * @param {number} fleetId ID for a fleet
     * @param {PutFleetsFleetIdNewSettings} newSettings What to update for this fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putFleetsFleetId(
      fleetId: number,
      newSettings: PutFleetsFleetIdNewSettings,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .putFleetsFleetId(fleetId, newSettings, datasource, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/`
     * @summary Move fleet member
     * @param {number} fleetId ID for a fleet
     * @param {number} memberId The character ID of a member in this fleet
     * @param {PutFleetsFleetIdMembersMemberIdMovement} movement Details of the invitation
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putFleetsFleetIdMembersMemberId(
      fleetId: number,
      memberId: number,
      movement: PutFleetsFleetIdMembersMemberIdMovement,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .putFleetsFleetIdMembersMemberId(
          fleetId,
          memberId,
          movement,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/`
     * @summary Rename fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} squadId The squad to rename
     * @param {PutFleetsFleetIdSquadsSquadIdNaming} naming New name of the squad
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putFleetsFleetIdSquadsSquadId(
      fleetId: number,
      squadId: number,
      naming: PutFleetsFleetIdSquadsSquadIdNaming,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .putFleetsFleetIdSquadsSquadId(
          fleetId,
          squadId,
          naming,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/`
     * @summary Rename fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing to rename
     * @param {PutFleetsFleetIdWingsWingIdNaming} naming New name of the wing
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putFleetsFleetIdWingsWingId(
      fleetId: number,
      wingId: number,
      naming: PutFleetsFleetIdWingsWingIdNaming,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .putFleetsFleetIdWingsWingId(
          fleetId,
          wingId,
          naming,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FleetsApi - object-oriented interface
 * @export
 * @class FleetsApi
 * @extends {BaseAPI}
 */
export class FleetsApi extends BaseAPI {
  /**
   * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/`
   * @summary Kick fleet member
   * @param {number} fleetId ID for a fleet
   * @param {number} memberId The character ID of a member in this fleet
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public deleteFleetsFleetIdMembersMemberId(
    fleetId: number,
    memberId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .deleteFleetsFleetIdMembersMemberId(
        fleetId,
        memberId,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/`
   * @summary Delete fleet squad
   * @param {number} fleetId ID for a fleet
   * @param {number} squadId The squad to delete
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public deleteFleetsFleetIdSquadsSquadId(
    fleetId: number,
    squadId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .deleteFleetsFleetIdSquadsSquadId(
        fleetId,
        squadId,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/`
   * @summary Delete fleet wing
   * @param {number} fleetId ID for a fleet
   * @param {number} wingId The wing to delete
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public deleteFleetsFleetIdWingsWingId(
    fleetId: number,
    wingId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .deleteFleetsFleetIdWingsWingId(
        fleetId,
        wingId,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return the fleet ID the character is in, if any.  --- Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds  --- Warning: This route has an upgrade available  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/fleet/)
   * @summary Get character fleet info
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getCharacterFleet(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .getCharacterFleet(characterId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
   * @summary Get fleet information
   * @param {number} fleetId ID for a fleet
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetsFleetId(
    fleetId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .getFleetsFleetId(fleetId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
   * @summary Get fleet members
   * @param {number} fleetId ID for a fleet
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetsFleetIdMembers(
    fleetId: number,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .getFleetsFleetIdMembers(
        fleetId,
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
   * @summary Get fleet wings
   * @param {number} fleetId ID for a fleet
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetsFleetIdWings(
    fleetId: number,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .getFleetsFleetIdWings(
        fleetId,
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`
   * @summary Create fleet invitation
   * @param {number} fleetId ID for a fleet
   * @param {PostFleetsFleetIdMembersInvitation} invitation Details of the invitation
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public postFleetsFleetIdMembers(
    fleetId: number,
    invitation: PostFleetsFleetIdMembersInvitation,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .postFleetsFleetIdMembers(fleetId, invitation, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`
   * @summary Create fleet wing
   * @param {number} fleetId ID for a fleet
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public postFleetsFleetIdWings(
    fleetId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .postFleetsFleetIdWings(fleetId, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/`
   * @summary Create fleet squad
   * @param {number} fleetId ID for a fleet
   * @param {number} wingId The wing_id to create squad in
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public postFleetsFleetIdWingsWingIdSquads(
    fleetId: number,
    wingId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .postFleetsFleetIdWingsWingIdSquads(
        fleetId,
        wingId,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`
   * @summary Update fleet
   * @param {number} fleetId ID for a fleet
   * @param {PutFleetsFleetIdNewSettings} newSettings What to update for this fleet
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public putFleetsFleetId(
    fleetId: number,
    newSettings: PutFleetsFleetIdNewSettings,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .putFleetsFleetId(fleetId, newSettings, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/`
   * @summary Move fleet member
   * @param {number} fleetId ID for a fleet
   * @param {number} memberId The character ID of a member in this fleet
   * @param {PutFleetsFleetIdMembersMemberIdMovement} movement Details of the invitation
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public putFleetsFleetIdMembersMemberId(
    fleetId: number,
    memberId: number,
    movement: PutFleetsFleetIdMembersMemberIdMovement,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .putFleetsFleetIdMembersMemberId(
        fleetId,
        memberId,
        movement,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/`
   * @summary Rename fleet squad
   * @param {number} fleetId ID for a fleet
   * @param {number} squadId The squad to rename
   * @param {PutFleetsFleetIdSquadsSquadIdNaming} naming New name of the squad
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public putFleetsFleetIdSquadsSquadId(
    fleetId: number,
    squadId: number,
    naming: PutFleetsFleetIdSquadsSquadIdNaming,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .putFleetsFleetIdSquadsSquadId(
        fleetId,
        squadId,
        naming,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/`
   * @summary Rename fleet wing
   * @param {number} fleetId ID for a fleet
   * @param {number} wingId The wing to rename
   * @param {PutFleetsFleetIdWingsWingIdNaming} naming New name of the wing
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public putFleetsFleetIdWingsWingId(
    fleetId: number,
    wingId: number,
    naming: PutFleetsFleetIdWingsWingIdNaming,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return FleetsApiFp(this.configuration)
      .putFleetsFleetIdWingsWingId(
        fleetId,
        wingId,
        naming,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IncursionsApi - axios parameter creator
 * @export
 */
export const IncursionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
     * @summary List incursions
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIncursions: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/incursions/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IncursionsApi - functional programming interface
 * @export
 */
export const IncursionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    IncursionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
     * @summary List incursions
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIncursions(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetIncursions200Ok>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIncursions(
        datasource,
        ifNoneMatch,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * IncursionsApi - factory interface
 * @export
 */
export const IncursionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = IncursionsApiFp(configuration);
  return {
    /**
     * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
     * @summary List incursions
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIncursions(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetIncursions200Ok>> {
      return localVarFp
        .getIncursions(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IncursionsApi - object-oriented interface
 * @export
 * @class IncursionsApi
 * @extends {BaseAPI}
 */
export class IncursionsApi extends BaseAPI {
  /**
   * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
   * @summary List incursions
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IncursionsApi
   */
  public getIncursions(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return IncursionsApiFp(this.configuration)
      .getIncursions(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IndustryApi - axios parameter creator
 * @export
 */
export const IndustryApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
     * @summary List character industry jobs
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {boolean} [includeCompleted] Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterIndustryJobs: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      includeCompleted?: boolean,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterIndustryJobs", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/industry/jobs/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-industry.read_character_jobs.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (includeCompleted !== undefined) {
        localVarQueryParameter["include_completed"] = includeCompleted;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
     * @summary Character mining ledger
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterMining: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterMining", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/mining/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-industry.read_character_mining.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager
     * @summary Moon extraction timers
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationCorporationIdMiningExtractions: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationCorporationIdMiningExtractions",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporation/{corporation_id}/mining/extractions/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-industry.read_corporation_mining.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant
     * @summary Corporation mining observers
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationCorporationIdMiningObservers: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationCorporationIdMiningObservers",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporation/{corporation_id}/mining/observers/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-industry.read_corporation_mining.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant
     * @summary Observed corporation mining
     * @param {number} corporationId An EVE corporation ID
     * @param {number} observerId A mining observer id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationCorporationIdMiningObserversObserverId: async (
      corporationId: number,
      observerId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationCorporationIdMiningObserversObserverId",
        "corporationId",
        corporationId
      );
      // verify required parameter 'observerId' is not null or undefined
      assertParamExists(
        "getCorporationCorporationIdMiningObserversObserverId",
        "observerId",
        observerId
      );
      const localVarPath =
        `/corporation/{corporation_id}/mining/observers/{observer_id}/`
          .replace(
            `{${"corporation_id"}}`,
            encodeURIComponent(String(corporationId))
          )
          .replace(
            `{${"observer_id"}}`,
            encodeURIComponent(String(observerId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-industry.read_corporation_mining.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager
     * @summary List corporation industry jobs
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {boolean} [includeCompleted] Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdIndustryJobs: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      includeCompleted?: boolean,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdIndustryJobs",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/industry/jobs/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-industry.read_corporation_jobs.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (includeCompleted !== undefined) {
        localVarQueryParameter["include_completed"] = includeCompleted;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
     * @summary List industry facilities
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndustryFacilities: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/industry/facilities/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
     * @summary List solar system cost indices
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndustrySystems: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/industry/systems/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IndustryApi - functional programming interface
 * @export
 */
export const IndustryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IndustryApiAxiosParamCreator(configuration);
  return {
    /**
     * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
     * @summary List character industry jobs
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {boolean} [includeCompleted] Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterIndustryJobs(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      includeCompleted?: boolean,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdIndustryJobs200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterIndustryJobs(
          characterId,
          datasource,
          ifNoneMatch,
          includeCompleted,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
     * @summary Character mining ledger
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterMining(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdMining200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterMining(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager
     * @summary Moon extraction timers
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationCorporationIdMiningExtractions(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<
        Array<GetCorporationCorporationIdMiningExtractions200Ok>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationCorporationIdMiningExtractions(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant
     * @summary Corporation mining observers
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationCorporationIdMiningObservers(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationCorporationIdMiningObservers200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationCorporationIdMiningObservers(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant
     * @summary Observed corporation mining
     * @param {number} corporationId An EVE corporation ID
     * @param {number} observerId A mining observer id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationCorporationIdMiningObserversObserverId(
      corporationId: number,
      observerId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<
        Array<GetCorporationCorporationIdMiningObserversObserverId200Ok>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationCorporationIdMiningObserversObserverId(
          corporationId,
          observerId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager
     * @summary List corporation industry jobs
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {boolean} [includeCompleted] Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdIndustryJobs(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      includeCompleted?: boolean,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdIndustryJobs200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdIndustryJobs(
          corporationId,
          datasource,
          ifNoneMatch,
          includeCompleted,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
     * @summary List industry facilities
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIndustryFacilities(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetIndustryFacilities200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIndustryFacilities(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
     * @summary List solar system cost indices
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIndustrySystems(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetIndustrySystems200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIndustrySystems(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * IndustryApi - factory interface
 * @export
 */
export const IndustryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = IndustryApiFp(configuration);
  return {
    /**
     * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
     * @summary List character industry jobs
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {boolean} [includeCompleted] Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterIndustryJobs(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      includeCompleted?: boolean,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdIndustryJobs200Ok>> {
      return localVarFp
        .getCharacterIndustryJobs(
          characterId,
          datasource,
          ifNoneMatch,
          includeCompleted,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
     * @summary Character mining ledger
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterMining(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdMining200Ok>> {
      return localVarFp
        .getCharacterMining(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager
     * @summary Moon extraction timers
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationCorporationIdMiningExtractions(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationCorporationIdMiningExtractions200Ok>> {
      return localVarFp
        .getCorporationCorporationIdMiningExtractions(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant
     * @summary Corporation mining observers
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationCorporationIdMiningObservers(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationCorporationIdMiningObservers200Ok>> {
      return localVarFp
        .getCorporationCorporationIdMiningObservers(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant
     * @summary Observed corporation mining
     * @param {number} corporationId An EVE corporation ID
     * @param {number} observerId A mining observer id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationCorporationIdMiningObserversObserverId(
      corporationId: number,
      observerId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<
      Array<GetCorporationCorporationIdMiningObserversObserverId200Ok>
    > {
      return localVarFp
        .getCorporationCorporationIdMiningObserversObserverId(
          corporationId,
          observerId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager
     * @summary List corporation industry jobs
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {boolean} [includeCompleted] Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdIndustryJobs(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      includeCompleted?: boolean,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdIndustryJobs200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdIndustryJobs(
          corporationId,
          datasource,
          ifNoneMatch,
          includeCompleted,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
     * @summary List industry facilities
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndustryFacilities(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetIndustryFacilities200Ok>> {
      return localVarFp
        .getIndustryFacilities(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
     * @summary List solar system cost indices
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndustrySystems(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetIndustrySystems200Ok>> {
      return localVarFp
        .getIndustrySystems(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IndustryApi - object-oriented interface
 * @export
 * @class IndustryApi
 * @extends {BaseAPI}
 */
export class IndustryApi extends BaseAPI {
  /**
   * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
   * @summary List character industry jobs
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {boolean} [includeCompleted] Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IndustryApi
   */
  public getCharacterIndustryJobs(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    includeCompleted?: boolean,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return IndustryApiFp(this.configuration)
      .getCharacterIndustryJobs(
        characterId,
        datasource,
        ifNoneMatch,
        includeCompleted,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
   * @summary Character mining ledger
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IndustryApi
   */
  public getCharacterMining(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return IndustryApiFp(this.configuration)
      .getCharacterMining(
        characterId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager
   * @summary Moon extraction timers
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IndustryApi
   */
  public getCorporationCorporationIdMiningExtractions(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return IndustryApiFp(this.configuration)
      .getCorporationCorporationIdMiningExtractions(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant
   * @summary Corporation mining observers
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IndustryApi
   */
  public getCorporationCorporationIdMiningObservers(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return IndustryApiFp(this.configuration)
      .getCorporationCorporationIdMiningObservers(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant
   * @summary Observed corporation mining
   * @param {number} corporationId An EVE corporation ID
   * @param {number} observerId A mining observer id
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IndustryApi
   */
  public getCorporationCorporationIdMiningObserversObserverId(
    corporationId: number,
    observerId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return IndustryApiFp(this.configuration)
      .getCorporationCorporationIdMiningObserversObserverId(
        corporationId,
        observerId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager
   * @summary List corporation industry jobs
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {boolean} [includeCompleted] Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IndustryApi
   */
  public getCorporationsCorporationIdIndustryJobs(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    includeCompleted?: boolean,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return IndustryApiFp(this.configuration)
      .getCorporationsCorporationIdIndustryJobs(
        corporationId,
        datasource,
        ifNoneMatch,
        includeCompleted,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
   * @summary List industry facilities
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IndustryApi
   */
  public getIndustryFacilities(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return IndustryApiFp(this.configuration)
      .getIndustryFacilities(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
   * @summary List solar system cost indices
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IndustryApi
   */
  public getIndustrySystems(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return IndustryApiFp(this.configuration)
      .getIndustrySystems(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * InsuranceApi - axios parameter creator
 * @export
 */
export const InsuranceApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
     * @summary List insurance levels
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInsurancePrices: async (
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/insurance/prices/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InsuranceApi - functional programming interface
 * @export
 */
export const InsuranceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    InsuranceApiAxiosParamCreator(configuration);
  return {
    /**
     * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
     * @summary List insurance levels
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInsurancePrices(
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetInsurancePrices200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getInsurancePrices(
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * InsuranceApi - factory interface
 * @export
 */
export const InsuranceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = InsuranceApiFp(configuration);
  return {
    /**
     * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
     * @summary List insurance levels
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInsurancePrices(
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<Array<GetInsurancePrices200Ok>> {
      return localVarFp
        .getInsurancePrices(
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * InsuranceApi - object-oriented interface
 * @export
 * @class InsuranceApi
 * @extends {BaseAPI}
 */
export class InsuranceApi extends BaseAPI {
  /**
   * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
   * @summary List insurance levels
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InsuranceApi
   */
  public getInsurancePrices(
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return InsuranceApiFp(this.configuration)
      .getInsurancePrices(
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * KillmailsApi - axios parameter creator
 * @export
 */
export const KillmailsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return a list of a character\'s kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
     * @summary Get a character\'s recent kills and losses
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterRecentKillmails: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterRecentKillmails",
        "characterId",
        characterId
      );
      const localVarPath =
        `/characters/{character_id}/killmails/recent/`.replace(
          `{${"character_id"}}`,
          encodeURIComponent(String(characterId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-killmails.read_killmails.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of a corporation\'s kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get a corporation\'s recent kills and losses
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdKillmailsRecent: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdKillmailsRecent",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/killmails/recent/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-killmails.read_corporation_killmails.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
     * @summary Get a single killmail
     * @param {string} killmailHash The killmail hash for verification
     * @param {number} killmailId The killmail ID to be queried
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKillmailsKillmailIdKillmailHash: async (
      killmailHash: string,
      killmailId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'killmailHash' is not null or undefined
      assertParamExists(
        "getKillmailsKillmailIdKillmailHash",
        "killmailHash",
        killmailHash
      );
      // verify required parameter 'killmailId' is not null or undefined
      assertParamExists(
        "getKillmailsKillmailIdKillmailHash",
        "killmailId",
        killmailId
      );
      const localVarPath = `/killmails/{killmail_id}/{killmail_hash}/`
        .replace(
          `{${"killmail_hash"}}`,
          encodeURIComponent(String(killmailHash))
        )
        .replace(`{${"killmail_id"}}`, encodeURIComponent(String(killmailId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * KillmailsApi - functional programming interface
 * @export
 */
export const KillmailsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    KillmailsApiAxiosParamCreator(configuration);
  return {
    /**
     * Return a list of a character\'s kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
     * @summary Get a character\'s recent kills and losses
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterRecentKillmails(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdKillmailsRecent200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterRecentKillmails(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of a corporation\'s kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get a corporation\'s recent kills and losses
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdKillmailsRecent(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdKillmailsRecent200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdKillmailsRecent(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
     * @summary Get a single killmail
     * @param {string} killmailHash The killmail hash for verification
     * @param {number} killmailId The killmail ID to be queried
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getKillmailsKillmailIdKillmailHash(
      killmailHash: string,
      killmailId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetKillmailsKillmailIdKillmailHashOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getKillmailsKillmailIdKillmailHash(
          killmailHash,
          killmailId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * KillmailsApi - factory interface
 * @export
 */
export const KillmailsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = KillmailsApiFp(configuration);
  return {
    /**
     * Return a list of a character\'s kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
     * @summary Get a character\'s recent kills and losses
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterRecentKillmails(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdKillmailsRecent200Ok>> {
      return localVarFp
        .getCharacterRecentKillmails(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of a corporation\'s kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary Get a corporation\'s recent kills and losses
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdKillmailsRecent(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdKillmailsRecent200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdKillmailsRecent(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
     * @summary Get a single killmail
     * @param {string} killmailHash The killmail hash for verification
     * @param {number} killmailId The killmail ID to be queried
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKillmailsKillmailIdKillmailHash(
      killmailHash: string,
      killmailId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetKillmailsKillmailIdKillmailHashOk> {
      return localVarFp
        .getKillmailsKillmailIdKillmailHash(
          killmailHash,
          killmailId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * KillmailsApi - object-oriented interface
 * @export
 * @class KillmailsApi
 * @extends {BaseAPI}
 */
export class KillmailsApi extends BaseAPI {
  /**
   * Return a list of a character\'s kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
   * @summary Get a character\'s recent kills and losses
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KillmailsApi
   */
  public getCharacterRecentKillmails(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return KillmailsApiFp(this.configuration)
      .getCharacterRecentKillmails(
        characterId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of a corporation\'s kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary Get a corporation\'s recent kills and losses
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KillmailsApi
   */
  public getCorporationsCorporationIdKillmailsRecent(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return KillmailsApiFp(this.configuration)
      .getCorporationsCorporationIdKillmailsRecent(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
   * @summary Get a single killmail
   * @param {string} killmailHash The killmail hash for verification
   * @param {number} killmailId The killmail ID to be queried
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KillmailsApi
   */
  public getKillmailsKillmailIdKillmailHash(
    killmailHash: string,
    killmailId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return KillmailsApiFp(this.configuration)
      .getKillmailsKillmailIdKillmailHash(
        killmailHash,
        killmailId,
        datasource,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LocationApi - axios parameter creator
 * @export
 */
export const LocationApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
     * @summary Get character location
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterLocation: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterLocation", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/location/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-location.read_location.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
     * @summary Get current ship
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterShip: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterShip", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/ship/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-location.read_ship_type.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
     * @summary Get character online
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isCharacterOnline: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("isCharacterOnline", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/online/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-location.read_online.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LocationApi - functional programming interface
 * @export
 */
export const LocationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration);
  return {
    /**
     * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
     * @summary Get character location
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterLocation(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdLocationOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterLocation(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
     * @summary Get current ship
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterShip(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdShipOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterShip(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
     * @summary Get character online
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isCharacterOnline(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdOnlineOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.isCharacterOnline(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LocationApi - factory interface
 * @export
 */
export const LocationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LocationApiFp(configuration);
  return {
    /**
     * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
     * @summary Get character location
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterLocation(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdLocationOk> {
      return localVarFp
        .getCharacterLocation(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
     * @summary Get current ship
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterShip(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdShipOk> {
      return localVarFp
        .getCharacterShip(characterId, datasource, ifNoneMatch, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
     * @summary Get character online
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isCharacterOnline(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdOnlineOk> {
      return localVarFp
        .isCharacterOnline(characterId, datasource, ifNoneMatch, token, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LocationApi - object-oriented interface
 * @export
 * @class LocationApi
 * @extends {BaseAPI}
 */
export class LocationApi extends BaseAPI {
  /**
   * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
   * @summary Get character location
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationApi
   */
  public getCharacterLocation(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return LocationApiFp(this.configuration)
      .getCharacterLocation(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
   * @summary Get current ship
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationApi
   */
  public getCharacterShip(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return LocationApiFp(this.configuration)
      .getCharacterShip(characterId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
   * @summary Get character online
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationApi
   */
  public isCharacterOnline(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return LocationApiFp(this.configuration)
      .isCharacterOnline(characterId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LoyaltyApi - axios parameter creator
 * @export
 */
export const LoyaltyApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
     * @summary Get loyalty points
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterLoyaltyPoints: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterLoyaltyPoints",
        "characterId",
        characterId
      );
      const localVarPath = `/characters/{character_id}/loyalty/points/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_loyalty.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of offers from a specific corporation\'s loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
     * @summary List loyalty store offers
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoyaltyStoresCorporationIdOffers: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getLoyaltyStoresCorporationIdOffers",
        "corporationId",
        corporationId
      );
      const localVarPath = `/loyalty/stores/{corporation_id}/offers/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LoyaltyApi - functional programming interface
 * @export
 */
export const LoyaltyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LoyaltyApiAxiosParamCreator(configuration);
  return {
    /**
     * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
     * @summary Get loyalty points
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterLoyaltyPoints(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdLoyaltyPoints200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterLoyaltyPoints(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of offers from a specific corporation\'s loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
     * @summary List loyalty store offers
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoyaltyStoresCorporationIdOffers(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetLoyaltyStoresCorporationIdOffers200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLoyaltyStoresCorporationIdOffers(
          corporationId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LoyaltyApi - factory interface
 * @export
 */
export const LoyaltyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LoyaltyApiFp(configuration);
  return {
    /**
     * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
     * @summary Get loyalty points
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterLoyaltyPoints(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdLoyaltyPoints200Ok>> {
      return localVarFp
        .getCharacterLoyaltyPoints(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of offers from a specific corporation\'s loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
     * @summary List loyalty store offers
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoyaltyStoresCorporationIdOffers(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetLoyaltyStoresCorporationIdOffers200Ok>> {
      return localVarFp
        .getLoyaltyStoresCorporationIdOffers(
          corporationId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LoyaltyApi - object-oriented interface
 * @export
 * @class LoyaltyApi
 * @extends {BaseAPI}
 */
export class LoyaltyApi extends BaseAPI {
  /**
   * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
   * @summary Get loyalty points
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoyaltyApi
   */
  public getCharacterLoyaltyPoints(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return LoyaltyApiFp(this.configuration)
      .getCharacterLoyaltyPoints(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of offers from a specific corporation\'s loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
   * @summary List loyalty store offers
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoyaltyApi
   */
  public getLoyaltyStoresCorporationIdOffers(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return LoyaltyApiFp(this.configuration)
      .getLoyaltyStoresCorporationIdOffers(
        corporationId,
        datasource,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MailApi - axios parameter creator
 * @export
 */
export const MailApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/`
     * @summary Create a mail label
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdMailLabelsLabel} label Label to create
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCharacterMailLabel: async (
      characterId: number,
      label: PostCharactersCharacterIdMailLabelsLabel,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("createCharacterMailLabel", "characterId", characterId);
      // verify required parameter 'label' is not null or undefined
      assertParamExists("createCharacterMailLabel", "label", label);
      const localVarPath = `/characters/{character_id}/mail/labels/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-mail.organize_mail.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        label,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`
     * @summary Delete a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCharacterMail: async (
      characterId: number,
      mailId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("deleteCharacterMail", "characterId", characterId);
      // verify required parameter 'mailId' is not null or undefined
      assertParamExists("deleteCharacterMail", "mailId", mailId);
      const localVarPath = `/characters/{character_id}/mail/{mail_id}/`
        .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
        .replace(`{${"mail_id"}}`, encodeURIComponent(String(mailId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-mail.organize_mail.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/`
     * @summary Delete a mail label
     * @param {number} characterId An EVE character ID
     * @param {number} labelId An EVE label id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCharacterMailLabel: async (
      characterId: number,
      labelId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("deleteCharacterMailLabel", "characterId", characterId);
      // verify required parameter 'labelId' is not null or undefined
      assertParamExists("deleteCharacterMailLabel", "labelId", labelId);
      const localVarPath = `/characters/{character_id}/mail/labels/{label_id}/`
        .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
        .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-mail.organize_mail.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
     * @summary Return a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterMail: async (
      characterId: number,
      mailId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterMail", "characterId", characterId);
      // verify required parameter 'mailId' is not null or undefined
      assertParamExists("getCharacterMail", "mailId", mailId);
      const localVarPath = `/characters/{character_id}/mail/{mail_id}/`
        .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
        .replace(`{${"mail_id"}}`, encodeURIComponent(String(mailId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-mail.read_mail.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
     * @summary Return mail headers
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {Set<number>} [labels] Fetch only mails that match one or more of the given labels
     * @param {number} [lastMailId] List only mail with an ID lower than the given ID, if present
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterMailHeaders: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      labels?: Set<number>,
      lastMailId?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterMailHeaders", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/mail/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-mail.read_mail.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (labels) {
        localVarQueryParameter["labels"] = Array.from(labels).join(
          COLLECTION_FORMATS.csv
        );
      }

      if (lastMailId !== undefined) {
        localVarQueryParameter["last_mail_id"] = lastMailId;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
     * @summary Get mail labels and unread counts
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterMailLabels: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterMailLabels", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/mail/labels/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-mail.read_mail.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
     * @summary Return mailing list subscriptions
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterMailLists: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterMailLists", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/mail/lists/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-mail.read_mail.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`
     * @summary Send a new mail
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdMailMail} mail The mail to send
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendCharacterMail: async (
      characterId: number,
      mail: PostCharactersCharacterIdMailMail,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("sendCharacterMail", "characterId", characterId);
      // verify required parameter 'mail' is not null or undefined
      assertParamExists("sendCharacterMail", "mail", mail);
      const localVarPath = `/characters/{character_id}/mail/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-mail.send_mail.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mail,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`
     * @summary Update metadata about a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {PutCharactersCharacterIdMailMailIdContents} contents Data used to update the mail
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCharactersMailMetadata: async (
      characterId: number,
      mailId: number,
      contents: PutCharactersCharacterIdMailMailIdContents,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "updateCharactersMailMetadata",
        "characterId",
        characterId
      );
      // verify required parameter 'mailId' is not null or undefined
      assertParamExists("updateCharactersMailMetadata", "mailId", mailId);
      // verify required parameter 'contents' is not null or undefined
      assertParamExists("updateCharactersMailMetadata", "contents", contents);
      const localVarPath = `/characters/{character_id}/mail/{mail_id}/`
        .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
        .replace(`{${"mail_id"}}`, encodeURIComponent(String(mailId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-mail.organize_mail.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        contents,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MailApi - functional programming interface
 * @export
 */
export const MailApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MailApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/`
     * @summary Create a mail label
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdMailLabelsLabel} label Label to create
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCharacterMailLabel(
      characterId: number,
      label: PostCharactersCharacterIdMailLabelsLabel,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createCharacterMailLabel(
          characterId,
          label,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`
     * @summary Delete a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCharacterMail(
      characterId: number,
      mailId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteCharacterMail(
          characterId,
          mailId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/`
     * @summary Delete a mail label
     * @param {number} characterId An EVE character ID
     * @param {number} labelId An EVE label id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCharacterMailLabel(
      characterId: number,
      labelId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteCharacterMailLabel(
          characterId,
          labelId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
     * @summary Return a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterMail(
      characterId: number,
      mailId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdMailMailIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterMail(
          characterId,
          mailId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
     * @summary Return mail headers
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {Set<number>} [labels] Fetch only mails that match one or more of the given labels
     * @param {number} [lastMailId] List only mail with an ID lower than the given ID, if present
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterMailHeaders(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      labels?: Set<number>,
      lastMailId?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdMail200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterMailHeaders(
          characterId,
          datasource,
          ifNoneMatch,
          labels,
          lastMailId,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
     * @summary Get mail labels and unread counts
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterMailLabels(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdMailLabelsOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterMailLabels(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
     * @summary Return mailing list subscriptions
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterMailLists(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdMailLists200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterMailLists(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`
     * @summary Send a new mail
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdMailMail} mail The mail to send
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendCharacterMail(
      characterId: number,
      mail: PostCharactersCharacterIdMailMail,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.sendCharacterMail(
          characterId,
          mail,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`
     * @summary Update metadata about a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {PutCharactersCharacterIdMailMailIdContents} contents Data used to update the mail
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCharactersMailMetadata(
      characterId: number,
      mailId: number,
      contents: PutCharactersCharacterIdMailMailIdContents,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateCharactersMailMetadata(
          characterId,
          mailId,
          contents,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * MailApi - factory interface
 * @export
 */
export const MailApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MailApiFp(configuration);
  return {
    /**
     * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/`
     * @summary Create a mail label
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdMailLabelsLabel} label Label to create
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCharacterMailLabel(
      characterId: number,
      label: PostCharactersCharacterIdMailLabelsLabel,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .createCharacterMailLabel(
          characterId,
          label,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`
     * @summary Delete a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCharacterMail(
      characterId: number,
      mailId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteCharacterMail(characterId, mailId, datasource, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/`
     * @summary Delete a mail label
     * @param {number} characterId An EVE character ID
     * @param {number} labelId An EVE label id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCharacterMailLabel(
      characterId: number,
      labelId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteCharacterMailLabel(
          characterId,
          labelId,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
     * @summary Return a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterMail(
      characterId: number,
      mailId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdMailMailIdOk> {
      return localVarFp
        .getCharacterMail(
          characterId,
          mailId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
     * @summary Return mail headers
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {Set<number>} [labels] Fetch only mails that match one or more of the given labels
     * @param {number} [lastMailId] List only mail with an ID lower than the given ID, if present
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterMailHeaders(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      labels?: Set<number>,
      lastMailId?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdMail200Ok>> {
      return localVarFp
        .getCharacterMailHeaders(
          characterId,
          datasource,
          ifNoneMatch,
          labels,
          lastMailId,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
     * @summary Get mail labels and unread counts
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterMailLabels(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdMailLabelsOk> {
      return localVarFp
        .getCharacterMailLabels(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
     * @summary Return mailing list subscriptions
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterMailLists(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdMailLists200Ok>> {
      return localVarFp
        .getCharacterMailLists(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`
     * @summary Send a new mail
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdMailMail} mail The mail to send
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendCharacterMail(
      characterId: number,
      mail: PostCharactersCharacterIdMailMail,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .sendCharacterMail(characterId, mail, datasource, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`
     * @summary Update metadata about a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {PutCharactersCharacterIdMailMailIdContents} contents Data used to update the mail
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCharactersMailMetadata(
      characterId: number,
      mailId: number,
      contents: PutCharactersCharacterIdMailMailIdContents,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateCharactersMailMetadata(
          characterId,
          mailId,
          contents,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MailApi - object-oriented interface
 * @export
 * @class MailApi
 * @extends {BaseAPI}
 */
export class MailApi extends BaseAPI {
  /**
   * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/`
   * @summary Create a mail label
   * @param {number} characterId An EVE character ID
   * @param {PostCharactersCharacterIdMailLabelsLabel} label Label to create
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MailApi
   */
  public createCharacterMailLabel(
    characterId: number,
    label: PostCharactersCharacterIdMailLabelsLabel,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MailApiFp(this.configuration)
      .createCharacterMailLabel(characterId, label, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`
   * @summary Delete a mail
   * @param {number} characterId An EVE character ID
   * @param {number} mailId An EVE mail ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MailApi
   */
  public deleteCharacterMail(
    characterId: number,
    mailId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MailApiFp(this.configuration)
      .deleteCharacterMail(characterId, mailId, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/`
   * @summary Delete a mail label
   * @param {number} characterId An EVE character ID
   * @param {number} labelId An EVE label id
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MailApi
   */
  public deleteCharacterMailLabel(
    characterId: number,
    labelId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MailApiFp(this.configuration)
      .deleteCharacterMailLabel(
        characterId,
        labelId,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
   * @summary Return a mail
   * @param {number} characterId An EVE character ID
   * @param {number} mailId An EVE mail ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MailApi
   */
  public getCharacterMail(
    characterId: number,
    mailId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MailApiFp(this.configuration)
      .getCharacterMail(
        characterId,
        mailId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
   * @summary Return mail headers
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {Set<number>} [labels] Fetch only mails that match one or more of the given labels
   * @param {number} [lastMailId] List only mail with an ID lower than the given ID, if present
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MailApi
   */
  public getCharacterMailHeaders(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    labels?: Set<number>,
    lastMailId?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MailApiFp(this.configuration)
      .getCharacterMailHeaders(
        characterId,
        datasource,
        ifNoneMatch,
        labels,
        lastMailId,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
   * @summary Get mail labels and unread counts
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MailApi
   */
  public getCharacterMailLabels(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MailApiFp(this.configuration)
      .getCharacterMailLabels(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
   * @summary Return mailing list subscriptions
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MailApi
   */
  public getCharacterMailLists(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MailApiFp(this.configuration)
      .getCharacterMailLists(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`
   * @summary Send a new mail
   * @param {number} characterId An EVE character ID
   * @param {PostCharactersCharacterIdMailMail} mail The mail to send
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MailApi
   */
  public sendCharacterMail(
    characterId: number,
    mail: PostCharactersCharacterIdMailMail,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MailApiFp(this.configuration)
      .sendCharacterMail(characterId, mail, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`
   * @summary Update metadata about a mail
   * @param {number} characterId An EVE character ID
   * @param {number} mailId An EVE mail ID
   * @param {PutCharactersCharacterIdMailMailIdContents} contents Data used to update the mail
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MailApi
   */
  public updateCharactersMailMetadata(
    characterId: number,
    mailId: number,
    contents: PutCharactersCharacterIdMailMailIdContents,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MailApiFp(this.configuration)
      .updateCharactersMailMetadata(
        characterId,
        mailId,
        contents,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MarketApi - axios parameter creator
 * @export
 */
export const MarketApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
     * @summary List historical orders by a character
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterOrderHistory: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterOrderHistory", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/orders/history/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-markets.read_character_orders.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
     * @summary List open orders from a character
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterOrders: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterOrders", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/orders/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-markets.read_character_orders.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader
     * @summary List open orders from a corporation
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdOrders: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdOrders",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/orders/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-markets.read_corporation_orders.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader
     * @summary List historical orders from a corporation
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdOrdersHistory: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdOrdersHistory",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/orders/history/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-markets.read_corporation_orders.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
     * @summary Get item groups
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsGroups: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/markets/groups/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
     * @summary Get item group information
     * @param {number} marketGroupId An Eve item group ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsGroupsMarketGroupId: async (
      marketGroupId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'marketGroupId' is not null or undefined
      assertParamExists(
        "getMarketsGroupsMarketGroupId",
        "marketGroupId",
        marketGroupId
      );
      const localVarPath = `/markets/groups/{market_group_id}/`.replace(
        `{${"market_group_id"}}`,
        encodeURIComponent(String(marketGroupId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
     * @summary List market prices
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsPrices: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/markets/prices/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
     * @summary List historical market statistics in a region
     * @param {number} regionId Return statistics in this region
     * @param {number} typeId Return statistics for this type
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsRegionIdHistory: async (
      regionId: number,
      typeId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'regionId' is not null or undefined
      assertParamExists("getMarketsRegionIdHistory", "regionId", regionId);
      // verify required parameter 'typeId' is not null or undefined
      assertParamExists("getMarketsRegionIdHistory", "typeId", typeId);
      const localVarPath = `/markets/{region_id}/history/`.replace(
        `{${"region_id"}}`,
        encodeURIComponent(String(regionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (typeId !== undefined) {
        localVarQueryParameter["type_id"] = typeId;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
     * @summary List orders in a region
     * @param {'buy' | 'sell' | 'all'} orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
     * @param {number} regionId Return orders in this region
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {number} [typeId] Return orders only for this type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsRegionIdOrders: async (
      orderType: "buy" | "sell" | "all",
      regionId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      typeId?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'orderType' is not null or undefined
      assertParamExists("getMarketsRegionIdOrders", "orderType", orderType);
      // verify required parameter 'regionId' is not null or undefined
      assertParamExists("getMarketsRegionIdOrders", "regionId", regionId);
      const localVarPath = `/markets/{region_id}/orders/`.replace(
        `{${"region_id"}}`,
        encodeURIComponent(String(regionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (orderType !== undefined) {
        localVarQueryParameter["order_type"] = orderType;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (typeId !== undefined) {
        localVarQueryParameter["type_id"] = typeId;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
     * @summary List type IDs relevant to a market
     * @param {number} regionId Return statistics in this region
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsRegionIdTypes: async (
      regionId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'regionId' is not null or undefined
      assertParamExists("getMarketsRegionIdTypes", "regionId", regionId);
      const localVarPath = `/markets/{region_id}/types/`.replace(
        `{${"region_id"}}`,
        encodeURIComponent(String(regionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
     * @summary List orders in a structure
     * @param {number} structureId Return orders in this structure
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsStructuresStructureId: async (
      structureId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'structureId' is not null or undefined
      assertParamExists(
        "getMarketsStructuresStructureId",
        "structureId",
        structureId
      );
      const localVarPath = `/markets/structures/{structure_id}/`.replace(
        `{${"structure_id"}}`,
        encodeURIComponent(String(structureId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-markets.structure_markets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MarketApi - functional programming interface
 * @export
 */
export const MarketApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MarketApiAxiosParamCreator(configuration);
  return {
    /**
     * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
     * @summary List historical orders by a character
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterOrderHistory(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdOrdersHistory200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterOrderHistory(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
     * @summary List open orders from a character
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterOrders(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdOrders200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterOrders(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader
     * @summary List open orders from a corporation
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdOrders(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdOrders200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdOrders(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader
     * @summary List historical orders from a corporation
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdOrdersHistory(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdOrdersHistory200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdOrdersHistory(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
     * @summary Get item groups
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMarketsGroups(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMarketsGroups(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
     * @summary Get item group information
     * @param {number} marketGroupId An Eve item group ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMarketsGroupsMarketGroupId(
      marketGroupId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetMarketsGroupsMarketGroupIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMarketsGroupsMarketGroupId(
          marketGroupId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
     * @summary List market prices
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMarketsPrices(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetMarketsPrices200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMarketsPrices(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
     * @summary List historical market statistics in a region
     * @param {number} regionId Return statistics in this region
     * @param {number} typeId Return statistics for this type
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMarketsRegionIdHistory(
      regionId: number,
      typeId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetMarketsRegionIdHistory200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMarketsRegionIdHistory(
          regionId,
          typeId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
     * @summary List orders in a region
     * @param {'buy' | 'sell' | 'all'} orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
     * @param {number} regionId Return orders in this region
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {number} [typeId] Return orders only for this type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMarketsRegionIdOrders(
      orderType: "buy" | "sell" | "all",
      regionId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      typeId?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetMarketsRegionIdOrders200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMarketsRegionIdOrders(
          orderType,
          regionId,
          datasource,
          ifNoneMatch,
          page,
          typeId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
     * @summary List type IDs relevant to a market
     * @param {number} regionId Return statistics in this region
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMarketsRegionIdTypes(
      regionId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMarketsRegionIdTypes(
          regionId,
          datasource,
          ifNoneMatch,
          page,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
     * @summary List orders in a structure
     * @param {number} structureId Return orders in this structure
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMarketsStructuresStructureId(
      structureId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetMarketsStructuresStructureId200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMarketsStructuresStructureId(
          structureId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * MarketApi - factory interface
 * @export
 */
export const MarketApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MarketApiFp(configuration);
  return {
    /**
     * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
     * @summary List historical orders by a character
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterOrderHistory(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdOrdersHistory200Ok>> {
      return localVarFp
        .getCharacterOrderHistory(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
     * @summary List open orders from a character
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterOrders(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdOrders200Ok>> {
      return localVarFp
        .getCharacterOrders(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader
     * @summary List open orders from a corporation
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdOrders(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdOrders200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdOrders(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader
     * @summary List historical orders from a corporation
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdOrdersHistory(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdOrdersHistory200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdOrdersHistory(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
     * @summary Get item groups
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsGroups(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getMarketsGroups(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
     * @summary Get item group information
     * @param {number} marketGroupId An Eve item group ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsGroupsMarketGroupId(
      marketGroupId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<GetMarketsGroupsMarketGroupIdOk> {
      return localVarFp
        .getMarketsGroupsMarketGroupId(
          marketGroupId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
     * @summary List market prices
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsPrices(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetMarketsPrices200Ok>> {
      return localVarFp
        .getMarketsPrices(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
     * @summary List historical market statistics in a region
     * @param {number} regionId Return statistics in this region
     * @param {number} typeId Return statistics for this type
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsRegionIdHistory(
      regionId: number,
      typeId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetMarketsRegionIdHistory200Ok>> {
      return localVarFp
        .getMarketsRegionIdHistory(
          regionId,
          typeId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
     * @summary List orders in a region
     * @param {'buy' | 'sell' | 'all'} orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
     * @param {number} regionId Return orders in this region
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {number} [typeId] Return orders only for this type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsRegionIdOrders(
      orderType: "buy" | "sell" | "all",
      regionId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      typeId?: number,
      options?: any
    ): AxiosPromise<Array<GetMarketsRegionIdOrders200Ok>> {
      return localVarFp
        .getMarketsRegionIdOrders(
          orderType,
          regionId,
          datasource,
          ifNoneMatch,
          page,
          typeId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
     * @summary List type IDs relevant to a market
     * @param {number} regionId Return statistics in this region
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsRegionIdTypes(
      regionId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getMarketsRegionIdTypes(
          regionId,
          datasource,
          ifNoneMatch,
          page,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
     * @summary List orders in a structure
     * @param {number} structureId Return orders in this structure
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketsStructuresStructureId(
      structureId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetMarketsStructuresStructureId200Ok>> {
      return localVarFp
        .getMarketsStructuresStructureId(
          structureId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MarketApi - object-oriented interface
 * @export
 * @class MarketApi
 * @extends {BaseAPI}
 */
export class MarketApi extends BaseAPI {
  /**
   * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
   * @summary List historical orders by a character
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApi
   */
  public getCharacterOrderHistory(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MarketApiFp(this.configuration)
      .getCharacterOrderHistory(
        characterId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
   * @summary List open orders from a character
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApi
   */
  public getCharacterOrders(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MarketApiFp(this.configuration)
      .getCharacterOrders(characterId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader
   * @summary List open orders from a corporation
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApi
   */
  public getCorporationsCorporationIdOrders(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MarketApiFp(this.configuration)
      .getCorporationsCorporationIdOrders(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader
   * @summary List historical orders from a corporation
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApi
   */
  public getCorporationsCorporationIdOrdersHistory(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MarketApiFp(this.configuration)
      .getCorporationsCorporationIdOrdersHistory(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
   * @summary Get item groups
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApi
   */
  public getMarketsGroups(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return MarketApiFp(this.configuration)
      .getMarketsGroups(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
   * @summary Get item group information
   * @param {number} marketGroupId An Eve item group ID
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApi
   */
  public getMarketsGroupsMarketGroupId(
    marketGroupId: number,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return MarketApiFp(this.configuration)
      .getMarketsGroupsMarketGroupId(
        marketGroupId,
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
   * @summary List market prices
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApi
   */
  public getMarketsPrices(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return MarketApiFp(this.configuration)
      .getMarketsPrices(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
   * @summary List historical market statistics in a region
   * @param {number} regionId Return statistics in this region
   * @param {number} typeId Return statistics for this type
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApi
   */
  public getMarketsRegionIdHistory(
    regionId: number,
    typeId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return MarketApiFp(this.configuration)
      .getMarketsRegionIdHistory(
        regionId,
        typeId,
        datasource,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
   * @summary List orders in a region
   * @param {'buy' | 'sell' | 'all'} orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
   * @param {number} regionId Return orders in this region
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {number} [typeId] Return orders only for this type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApi
   */
  public getMarketsRegionIdOrders(
    orderType: "buy" | "sell" | "all",
    regionId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    typeId?: number,
    options?: AxiosRequestConfig
  ) {
    return MarketApiFp(this.configuration)
      .getMarketsRegionIdOrders(
        orderType,
        regionId,
        datasource,
        ifNoneMatch,
        page,
        typeId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
   * @summary List type IDs relevant to a market
   * @param {number} regionId Return statistics in this region
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApi
   */
  public getMarketsRegionIdTypes(
    regionId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    options?: AxiosRequestConfig
  ) {
    return MarketApiFp(this.configuration)
      .getMarketsRegionIdTypes(regionId, datasource, ifNoneMatch, page, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
   * @summary List orders in a structure
   * @param {number} structureId Return orders in this structure
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApi
   */
  public getMarketsStructuresStructureId(
    structureId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return MarketApiFp(this.configuration)
      .getMarketsStructuresStructureId(
        structureId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OpportunitiesApi - axios parameter creator
 * @export
 */
export const OpportunitiesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return a list of tasks finished by a character  --- Alternate route: `/dev/characters/{character_id}/opportunities/`  Alternate route: `/legacy/characters/{character_id}/opportunities/`  Alternate route: `/v1/characters/{character_id}/opportunities/`  --- This route is cached for up to 3600 seconds
     * @summary Get a character\'s completed tasks
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterOpportunities: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterOpportunities",
        "characterId",
        characterId
      );
      const localVarPath = `/characters/{character_id}/opportunities/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-characters.read_opportunities.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of opportunities groups  --- Alternate route: `/dev/opportunities/groups/`  Alternate route: `/legacy/opportunities/groups/`  Alternate route: `/v1/opportunities/groups/`  --- This route expires daily at 11:05
     * @summary Get opportunities groups
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpportunitiesGroups: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/opportunities/groups/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return information of an opportunities group  --- Alternate route: `/dev/opportunities/groups/{group_id}/`  Alternate route: `/legacy/opportunities/groups/{group_id}/`  Alternate route: `/v1/opportunities/groups/{group_id}/`  --- This route expires daily at 11:05
     * @summary Get opportunities group
     * @param {number} groupId ID of an opportunities group
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpportunitiesGroupsGroupId: async (
      groupId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists("getOpportunitiesGroupsGroupId", "groupId", groupId);
      const localVarPath = `/opportunities/groups/{group_id}/`.replace(
        `{${"group_id"}}`,
        encodeURIComponent(String(groupId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of opportunities tasks  --- Alternate route: `/dev/opportunities/tasks/`  Alternate route: `/legacy/opportunities/tasks/`  Alternate route: `/v1/opportunities/tasks/`  --- This route expires daily at 11:05
     * @summary Get opportunities tasks
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpportunitiesTasks: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/opportunities/tasks/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return information of an opportunities task  --- Alternate route: `/dev/opportunities/tasks/{task_id}/`  Alternate route: `/legacy/opportunities/tasks/{task_id}/`  Alternate route: `/v1/opportunities/tasks/{task_id}/`  --- This route expires daily at 11:05
     * @summary Get opportunities task
     * @param {number} taskId ID of an opportunities task
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpportunitiesTasksTaskId: async (
      taskId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists("getOpportunitiesTasksTaskId", "taskId", taskId);
      const localVarPath = `/opportunities/tasks/{task_id}/`.replace(
        `{${"task_id"}}`,
        encodeURIComponent(String(taskId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OpportunitiesApi - functional programming interface
 * @export
 */
export const OpportunitiesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    OpportunitiesApiAxiosParamCreator(configuration);
  return {
    /**
     * Return a list of tasks finished by a character  --- Alternate route: `/dev/characters/{character_id}/opportunities/`  Alternate route: `/legacy/characters/{character_id}/opportunities/`  Alternate route: `/v1/characters/{character_id}/opportunities/`  --- This route is cached for up to 3600 seconds
     * @summary Get a character\'s completed tasks
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterOpportunities(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdOpportunities200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterOpportunities(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of opportunities groups  --- Alternate route: `/dev/opportunities/groups/`  Alternate route: `/legacy/opportunities/groups/`  Alternate route: `/v1/opportunities/groups/`  --- This route expires daily at 11:05
     * @summary Get opportunities groups
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOpportunitiesGroups(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOpportunitiesGroups(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return information of an opportunities group  --- Alternate route: `/dev/opportunities/groups/{group_id}/`  Alternate route: `/legacy/opportunities/groups/{group_id}/`  Alternate route: `/v1/opportunities/groups/{group_id}/`  --- This route expires daily at 11:05
     * @summary Get opportunities group
     * @param {number} groupId ID of an opportunities group
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOpportunitiesGroupsGroupId(
      groupId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetOpportunitiesGroupsGroupIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOpportunitiesGroupsGroupId(
          groupId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of opportunities tasks  --- Alternate route: `/dev/opportunities/tasks/`  Alternate route: `/legacy/opportunities/tasks/`  Alternate route: `/v1/opportunities/tasks/`  --- This route expires daily at 11:05
     * @summary Get opportunities tasks
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOpportunitiesTasks(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOpportunitiesTasks(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return information of an opportunities task  --- Alternate route: `/dev/opportunities/tasks/{task_id}/`  Alternate route: `/legacy/opportunities/tasks/{task_id}/`  Alternate route: `/v1/opportunities/tasks/{task_id}/`  --- This route expires daily at 11:05
     * @summary Get opportunities task
     * @param {number} taskId ID of an opportunities task
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOpportunitiesTasksTaskId(
      taskId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetOpportunitiesTasksTaskIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOpportunitiesTasksTaskId(
          taskId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * OpportunitiesApi - factory interface
 * @export
 */
export const OpportunitiesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = OpportunitiesApiFp(configuration);
  return {
    /**
     * Return a list of tasks finished by a character  --- Alternate route: `/dev/characters/{character_id}/opportunities/`  Alternate route: `/legacy/characters/{character_id}/opportunities/`  Alternate route: `/v1/characters/{character_id}/opportunities/`  --- This route is cached for up to 3600 seconds
     * @summary Get a character\'s completed tasks
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterOpportunities(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdOpportunities200Ok>> {
      return localVarFp
        .getCharacterOpportunities(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of opportunities groups  --- Alternate route: `/dev/opportunities/groups/`  Alternate route: `/legacy/opportunities/groups/`  Alternate route: `/v1/opportunities/groups/`  --- This route expires daily at 11:05
     * @summary Get opportunities groups
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpportunitiesGroups(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getOpportunitiesGroups(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return information of an opportunities group  --- Alternate route: `/dev/opportunities/groups/{group_id}/`  Alternate route: `/legacy/opportunities/groups/{group_id}/`  Alternate route: `/v1/opportunities/groups/{group_id}/`  --- This route expires daily at 11:05
     * @summary Get opportunities group
     * @param {number} groupId ID of an opportunities group
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpportunitiesGroupsGroupId(
      groupId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<GetOpportunitiesGroupsGroupIdOk> {
      return localVarFp
        .getOpportunitiesGroupsGroupId(
          groupId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of opportunities tasks  --- Alternate route: `/dev/opportunities/tasks/`  Alternate route: `/legacy/opportunities/tasks/`  Alternate route: `/v1/opportunities/tasks/`  --- This route expires daily at 11:05
     * @summary Get opportunities tasks
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpportunitiesTasks(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getOpportunitiesTasks(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return information of an opportunities task  --- Alternate route: `/dev/opportunities/tasks/{task_id}/`  Alternate route: `/legacy/opportunities/tasks/{task_id}/`  Alternate route: `/v1/opportunities/tasks/{task_id}/`  --- This route expires daily at 11:05
     * @summary Get opportunities task
     * @param {number} taskId ID of an opportunities task
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpportunitiesTasksTaskId(
      taskId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetOpportunitiesTasksTaskIdOk> {
      return localVarFp
        .getOpportunitiesTasksTaskId(taskId, datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * OpportunitiesApi - object-oriented interface
 * @export
 * @class OpportunitiesApi
 * @extends {BaseAPI}
 */
export class OpportunitiesApi extends BaseAPI {
  /**
   * Return a list of tasks finished by a character  --- Alternate route: `/dev/characters/{character_id}/opportunities/`  Alternate route: `/legacy/characters/{character_id}/opportunities/`  Alternate route: `/v1/characters/{character_id}/opportunities/`  --- This route is cached for up to 3600 seconds
   * @summary Get a character\'s completed tasks
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OpportunitiesApi
   */
  public getCharacterOpportunities(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return OpportunitiesApiFp(this.configuration)
      .getCharacterOpportunities(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of opportunities groups  --- Alternate route: `/dev/opportunities/groups/`  Alternate route: `/legacy/opportunities/groups/`  Alternate route: `/v1/opportunities/groups/`  --- This route expires daily at 11:05
   * @summary Get opportunities groups
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OpportunitiesApi
   */
  public getOpportunitiesGroups(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return OpportunitiesApiFp(this.configuration)
      .getOpportunitiesGroups(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return information of an opportunities group  --- Alternate route: `/dev/opportunities/groups/{group_id}/`  Alternate route: `/legacy/opportunities/groups/{group_id}/`  Alternate route: `/v1/opportunities/groups/{group_id}/`  --- This route expires daily at 11:05
   * @summary Get opportunities group
   * @param {number} groupId ID of an opportunities group
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OpportunitiesApi
   */
  public getOpportunitiesGroupsGroupId(
    groupId: number,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return OpportunitiesApiFp(this.configuration)
      .getOpportunitiesGroupsGroupId(
        groupId,
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of opportunities tasks  --- Alternate route: `/dev/opportunities/tasks/`  Alternate route: `/legacy/opportunities/tasks/`  Alternate route: `/v1/opportunities/tasks/`  --- This route expires daily at 11:05
   * @summary Get opportunities tasks
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OpportunitiesApi
   */
  public getOpportunitiesTasks(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return OpportunitiesApiFp(this.configuration)
      .getOpportunitiesTasks(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return information of an opportunities task  --- Alternate route: `/dev/opportunities/tasks/{task_id}/`  Alternate route: `/legacy/opportunities/tasks/{task_id}/`  Alternate route: `/v1/opportunities/tasks/{task_id}/`  --- This route expires daily at 11:05
   * @summary Get opportunities task
   * @param {number} taskId ID of an opportunities task
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OpportunitiesApi
   */
  public getOpportunitiesTasksTaskId(
    taskId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return OpportunitiesApiFp(this.configuration)
      .getOpportunitiesTasksTaskId(taskId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PlanetaryInteractionApi - axios parameter creator
 * @export
 */
export const PlanetaryInteractionApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/`
     * @summary Get colony layout
     * @param {number} characterId An EVE character ID
     * @param {number} planetId Planet id of the target planet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterPlanet: async (
      characterId: number,
      planetId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterPlanet", "characterId", characterId);
      // verify required parameter 'planetId' is not null or undefined
      assertParamExists("getCharacterPlanet", "planetId", planetId);
      const localVarPath = `/characters/{character_id}/planets/{planet_id}/`
        .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
        .replace(`{${"planet_id"}}`, encodeURIComponent(String(planetId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-planets.manage_planets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
     * @summary Get colonies
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterPlanets: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterPlanets", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/planets/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-planets.manage_planets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary List corporation customs offices
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdCustomsOffices: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdCustomsOffices",
        "corporationId",
        corporationId
      );
      const localVarPath =
        `/corporations/{corporation_id}/customs_offices/`.replace(
          `{${"corporation_id"}}`,
          encodeURIComponent(String(corporationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-planets.read_customs_offices.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get schematic information
     * @param {number} schematicId A PI schematic ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseSchematicsSchematicId: async (
      schematicId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schematicId' is not null or undefined
      assertParamExists(
        "getUniverseSchematicsSchematicId",
        "schematicId",
        schematicId
      );
      const localVarPath = `/universe/schematics/{schematic_id}/`.replace(
        `{${"schematic_id"}}`,
        encodeURIComponent(String(schematicId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PlanetaryInteractionApi - functional programming interface
 * @export
 */
export const PlanetaryInteractionApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    PlanetaryInteractionApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/`
     * @summary Get colony layout
     * @param {number} characterId An EVE character ID
     * @param {number} planetId Planet id of the target planet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterPlanet(
      characterId: number,
      planetId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdPlanetsPlanetIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterPlanet(
          characterId,
          planetId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
     * @summary Get colonies
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterPlanets(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdPlanets200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterPlanets(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary List corporation customs offices
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdCustomsOffices(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdCustomsOffices200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdCustomsOffices(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get schematic information
     * @param {number} schematicId A PI schematic ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseSchematicsSchematicId(
      schematicId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseSchematicsSchematicIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseSchematicsSchematicId(
          schematicId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PlanetaryInteractionApi - factory interface
 * @export
 */
export const PlanetaryInteractionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PlanetaryInteractionApiFp(configuration);
  return {
    /**
     * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/`
     * @summary Get colony layout
     * @param {number} characterId An EVE character ID
     * @param {number} planetId Planet id of the target planet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterPlanet(
      characterId: number,
      planetId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdPlanetsPlanetIdOk> {
      return localVarFp
        .getCharacterPlanet(characterId, planetId, datasource, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
     * @summary Get colonies
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterPlanets(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdPlanets200Ok>> {
      return localVarFp
        .getCharacterPlanets(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
     * @summary List corporation customs offices
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdCustomsOffices(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdCustomsOffices200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdCustomsOffices(
          corporationId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get schematic information
     * @param {number} schematicId A PI schematic ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseSchematicsSchematicId(
      schematicId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetUniverseSchematicsSchematicIdOk> {
      return localVarFp
        .getUniverseSchematicsSchematicId(
          schematicId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PlanetaryInteractionApi - object-oriented interface
 * @export
 * @class PlanetaryInteractionApi
 * @extends {BaseAPI}
 */
export class PlanetaryInteractionApi extends BaseAPI {
  /**
   * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/`
   * @summary Get colony layout
   * @param {number} characterId An EVE character ID
   * @param {number} planetId Planet id of the target planet
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanetaryInteractionApi
   */
  public getCharacterPlanet(
    characterId: number,
    planetId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return PlanetaryInteractionApiFp(this.configuration)
      .getCharacterPlanet(characterId, planetId, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
   * @summary Get colonies
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanetaryInteractionApi
   */
  public getCharacterPlanets(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return PlanetaryInteractionApiFp(this.configuration)
      .getCharacterPlanets(characterId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director
   * @summary List corporation customs offices
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanetaryInteractionApi
   */
  public getCorporationsCorporationIdCustomsOffices(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return PlanetaryInteractionApiFp(this.configuration)
      .getCorporationsCorporationIdCustomsOffices(
        corporationId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
   * @summary Get schematic information
   * @param {number} schematicId A PI schematic ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanetaryInteractionApi
   */
  public getUniverseSchematicsSchematicId(
    schematicId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return PlanetaryInteractionApiFp(this.configuration)
      .getUniverseSchematicsSchematicId(
        schematicId,
        datasource,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RoutesApi - axios parameter creator
 * @export
 */
export const RoutesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
     * @summary Get route
     * @param {number} destination destination solar system ID
     * @param {number} origin origin solar system ID
     * @param {Set<number>} [avoid] avoid solar system ID(s)
     * @param {Set<Set<number>>} [connections] connected solar system pairs
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {'shortest' | 'secure' | 'insecure'} [flag] route security preference
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteOriginDestination: async (
      destination: number,
      origin: number,
      avoid?: Set<number>,
      connections?: Set<Set<number>>,
      datasource?: "tranquility",
      flag?: "shortest" | "secure" | "insecure",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'destination' is not null or undefined
      assertParamExists(
        "getRouteOriginDestination",
        "destination",
        destination
      );
      // verify required parameter 'origin' is not null or undefined
      assertParamExists("getRouteOriginDestination", "origin", origin);
      const localVarPath = `/route/{origin}/{destination}/`
        .replace(`{${"destination"}}`, encodeURIComponent(String(destination)))
        .replace(`{${"origin"}}`, encodeURIComponent(String(origin)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (avoid) {
        localVarQueryParameter["avoid"] = Array.from(avoid).join(
          COLLECTION_FORMATS.csv
        );
      }

      if (connections) {
        localVarQueryParameter["connections"] = Array.from(connections).join(
          COLLECTION_FORMATS.csv
        );
      }

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (flag !== undefined) {
        localVarQueryParameter["flag"] = flag;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RoutesApi - functional programming interface
 * @export
 */
export const RoutesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RoutesApiAxiosParamCreator(configuration);
  return {
    /**
     * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
     * @summary Get route
     * @param {number} destination destination solar system ID
     * @param {number} origin origin solar system ID
     * @param {Set<number>} [avoid] avoid solar system ID(s)
     * @param {Set<Set<number>>} [connections] connected solar system pairs
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {'shortest' | 'secure' | 'insecure'} [flag] route security preference
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRouteOriginDestination(
      destination: number,
      origin: number,
      avoid?: Set<number>,
      connections?: Set<Set<number>>,
      datasource?: "tranquility",
      flag?: "shortest" | "secure" | "insecure",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRouteOriginDestination(
          destination,
          origin,
          avoid,
          connections,
          datasource,
          flag,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RoutesApi - factory interface
 * @export
 */
export const RoutesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RoutesApiFp(configuration);
  return {
    /**
     * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
     * @summary Get route
     * @param {number} destination destination solar system ID
     * @param {number} origin origin solar system ID
     * @param {Set<number>} [avoid] avoid solar system ID(s)
     * @param {Set<Set<number>>} [connections] connected solar system pairs
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {'shortest' | 'secure' | 'insecure'} [flag] route security preference
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteOriginDestination(
      destination: number,
      origin: number,
      avoid?: Set<number>,
      connections?: Set<Set<number>>,
      datasource?: "tranquility",
      flag?: "shortest" | "secure" | "insecure",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getRouteOriginDestination(
          destination,
          origin,
          avoid,
          connections,
          datasource,
          flag,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RoutesApi - object-oriented interface
 * @export
 * @class RoutesApi
 * @extends {BaseAPI}
 */
export class RoutesApi extends BaseAPI {
  /**
   * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
   * @summary Get route
   * @param {number} destination destination solar system ID
   * @param {number} origin origin solar system ID
   * @param {Set<number>} [avoid] avoid solar system ID(s)
   * @param {Set<Set<number>>} [connections] connected solar system pairs
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {'shortest' | 'secure' | 'insecure'} [flag] route security preference
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutesApi
   */
  public getRouteOriginDestination(
    destination: number,
    origin: number,
    avoid?: Set<number>,
    connections?: Set<Set<number>>,
    datasource?: "tranquility",
    flag?: "shortest" | "secure" | "insecure",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return RoutesApiFp(this.configuration)
      .getRouteOriginDestination(
        destination,
        origin,
        avoid,
        connections,
        datasource,
        flag,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
     * @summary Search on a string
     * @param {Set<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>} categories Type of entities to search for
     * @param {number} characterId An EVE character ID
     * @param {string} search The string to search on
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {boolean} [strict] Whether the search should be a strict match
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCharacterEntities: async (
      categories: Set<
        | "agent"
        | "alliance"
        | "character"
        | "constellation"
        | "corporation"
        | "faction"
        | "inventory_type"
        | "region"
        | "solar_system"
        | "station"
        | "structure"
      >,
      characterId: number,
      search: string,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      strict?: boolean,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'categories' is not null or undefined
      assertParamExists("searchCharacterEntities", "categories", categories);
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("searchCharacterEntities", "characterId", characterId);
      // verify required parameter 'search' is not null or undefined
      assertParamExists("searchCharacterEntities", "search", search);
      const localVarPath = `/characters/{character_id}/search/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-search.search_structures.v1"],
        configuration
      );

      if (categories) {
        localVarQueryParameter["categories"] = Array.from(categories).join(
          COLLECTION_FORMATS.csv
        );
      }

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      if (strict !== undefined) {
        localVarQueryParameter["strict"] = strict;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration);
  return {
    /**
     * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
     * @summary Search on a string
     * @param {Set<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>} categories Type of entities to search for
     * @param {number} characterId An EVE character ID
     * @param {string} search The string to search on
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {boolean} [strict] Whether the search should be a strict match
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchCharacterEntities(
      categories: Set<
        | "agent"
        | "alliance"
        | "character"
        | "constellation"
        | "corporation"
        | "faction"
        | "inventory_type"
        | "region"
        | "solar_system"
        | "station"
        | "structure"
      >,
      characterId: number,
      search: string,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      strict?: boolean,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdSearchOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchCharacterEntities(
          categories,
          characterId,
          search,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          strict,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SearchApiFp(configuration);
  return {
    /**
     * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
     * @summary Search on a string
     * @param {Set<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>} categories Type of entities to search for
     * @param {number} characterId An EVE character ID
     * @param {string} search The string to search on
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {boolean} [strict] Whether the search should be a strict match
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCharacterEntities(
      categories: Set<
        | "agent"
        | "alliance"
        | "character"
        | "constellation"
        | "corporation"
        | "faction"
        | "inventory_type"
        | "region"
        | "solar_system"
        | "station"
        | "structure"
      >,
      characterId: number,
      search: string,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      strict?: boolean,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdSearchOk> {
      return localVarFp
        .searchCharacterEntities(
          categories,
          characterId,
          search,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          strict,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
  /**
   * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
   * @summary Search on a string
   * @param {Set<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>} categories Type of entities to search for
   * @param {number} characterId An EVE character ID
   * @param {string} search The string to search on
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {boolean} [strict] Whether the search should be a strict match
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public searchCharacterEntities(
    categories: Set<
      | "agent"
      | "alliance"
      | "character"
      | "constellation"
      | "corporation"
      | "faction"
      | "inventory_type"
      | "region"
      | "solar_system"
      | "station"
      | "structure"
    >,
    characterId: number,
    search: string,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    strict?: boolean,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return SearchApiFp(this.configuration)
      .searchCharacterEntities(
        categories,
        characterId,
        search,
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        strict,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SkillsApi - axios parameter creator
 * @export
 */
export const SkillsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
     * @summary Get character attributes
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterAttributes: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterAttributes", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/attributes/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-skills.read_skills.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
     * @summary Get character\'s skill queue
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterSkillqueue: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterSkillqueue", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/skillqueue/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-skills.read_skillqueue.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
     * @summary Get character skills
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterSkills: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterSkills", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/skills/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-skills.read_skills.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SkillsApi - functional programming interface
 * @export
 */
export const SkillsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SkillsApiAxiosParamCreator(configuration);
  return {
    /**
     * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
     * @summary Get character attributes
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterAttributes(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdAttributesOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterAttributes(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
     * @summary Get character\'s skill queue
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterSkillqueue(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdSkillqueue200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterSkillqueue(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
     * @summary Get character skills
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterSkills(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCharactersCharacterIdSkillsOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterSkills(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SkillsApi - factory interface
 * @export
 */
export const SkillsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SkillsApiFp(configuration);
  return {
    /**
     * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
     * @summary Get character attributes
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterAttributes(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdAttributesOk> {
      return localVarFp
        .getCharacterAttributes(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
     * @summary Get character\'s skill queue
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterSkillqueue(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdSkillqueue200Ok>> {
      return localVarFp
        .getCharacterSkillqueue(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
     * @summary Get character skills
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterSkills(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetCharactersCharacterIdSkillsOk> {
      return localVarFp
        .getCharacterSkills(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SkillsApi - object-oriented interface
 * @export
 * @class SkillsApi
 * @extends {BaseAPI}
 */
export class SkillsApi extends BaseAPI {
  /**
   * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
   * @summary Get character attributes
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillsApi
   */
  public getCharacterAttributes(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return SkillsApiFp(this.configuration)
      .getCharacterAttributes(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
   * @summary Get character\'s skill queue
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillsApi
   */
  public getCharacterSkillqueue(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return SkillsApiFp(this.configuration)
      .getCharacterSkillqueue(
        characterId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
   * @summary Get character skills
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillsApi
   */
  public getCharacterSkills(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return SkillsApiFp(this.configuration)
      .getCharacterSkills(characterId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SovereigntyApi - axios parameter creator
 * @export
 */
export const SovereigntyApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
     * @summary List sovereignty campaigns
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSovereigntyCampaigns: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/sovereignty/campaigns/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
     * @summary List sovereignty of systems
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSovereigntyMap: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/sovereignty/map/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
     * @summary List sovereignty structures
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSovereigntyStructures: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/sovereignty/structures/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SovereigntyApi - functional programming interface
 * @export
 */
export const SovereigntyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SovereigntyApiAxiosParamCreator(configuration);
  return {
    /**
     * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
     * @summary List sovereignty campaigns
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSovereigntyCampaigns(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetSovereigntyCampaigns200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSovereigntyCampaigns(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
     * @summary List sovereignty of systems
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSovereigntyMap(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetSovereigntyMap200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSovereigntyMap(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
     * @summary List sovereignty structures
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSovereigntyStructures(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetSovereigntyStructures200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSovereigntyStructures(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SovereigntyApi - factory interface
 * @export
 */
export const SovereigntyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SovereigntyApiFp(configuration);
  return {
    /**
     * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
     * @summary List sovereignty campaigns
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSovereigntyCampaigns(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetSovereigntyCampaigns200Ok>> {
      return localVarFp
        .getSovereigntyCampaigns(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
     * @summary List sovereignty of systems
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSovereigntyMap(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetSovereigntyMap200Ok>> {
      return localVarFp
        .getSovereigntyMap(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
     * @summary List sovereignty structures
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSovereigntyStructures(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetSovereigntyStructures200Ok>> {
      return localVarFp
        .getSovereigntyStructures(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SovereigntyApi - object-oriented interface
 * @export
 * @class SovereigntyApi
 * @extends {BaseAPI}
 */
export class SovereigntyApi extends BaseAPI {
  /**
   * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
   * @summary List sovereignty campaigns
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SovereigntyApi
   */
  public getSovereigntyCampaigns(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return SovereigntyApiFp(this.configuration)
      .getSovereigntyCampaigns(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
   * @summary List sovereignty of systems
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SovereigntyApi
   */
  public getSovereigntyMap(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return SovereigntyApiFp(this.configuration)
      .getSovereigntyMap(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
   * @summary List sovereignty structures
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SovereigntyApi
   */
  public getSovereigntyStructures(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return SovereigntyApiFp(this.configuration)
      .getSovereigntyStructures(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  Alternate route: `/v2/status/`  --- This route is cached for up to 30 seconds
     * @summary Retrieve the uptime and player counts
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/status/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration);
  return {
    /**
     * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  Alternate route: `/v2/status/`  --- This route is cached for up to 30 seconds
     * @summary Retrieve the uptime and player counts
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatus(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusOk>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(
        datasource,
        ifNoneMatch,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StatusApiFp(configuration);
  return {
    /**
     * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  Alternate route: `/v2/status/`  --- This route is cached for up to 30 seconds
     * @summary Retrieve the uptime and player counts
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetStatusOk> {
      return localVarFp
        .getStatus(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
  /**
   * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  Alternate route: `/v2/status/`  --- This route is cached for up to 30 seconds
   * @summary Retrieve the uptime and player counts
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public getStatus(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return StatusApiFp(this.configuration)
      .getStatus(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UniverseApi - axios parameter creator
 * @export
 */
export const UniverseApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
     * @summary Get ancestries
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseAncestries: async (
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/ancestries/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
     * @summary Get asteroid belt information
     * @param {number} asteroidBeltId asteroid_belt_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseAsteroidBeltsAsteroidBeltId: async (
      asteroidBeltId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'asteroidBeltId' is not null or undefined
      assertParamExists(
        "getUniverseAsteroidBeltsAsteroidBeltId",
        "asteroidBeltId",
        asteroidBeltId
      );
      const localVarPath =
        `/universe/asteroid_belts/{asteroid_belt_id}/`.replace(
          `{${"asteroid_belt_id"}}`,
          encodeURIComponent(String(asteroidBeltId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
     * @summary Get bloodlines
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseBloodlines: async (
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/bloodlines/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
     * @summary Get item categories
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseCategories: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/categories/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
     * @summary Get item category information
     * @param {number} categoryId An Eve item category ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseCategoriesCategoryId: async (
      categoryId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'categoryId' is not null or undefined
      assertParamExists(
        "getUniverseCategoriesCategoryId",
        "categoryId",
        categoryId
      );
      const localVarPath = `/universe/categories/{category_id}/`.replace(
        `{${"category_id"}}`,
        encodeURIComponent(String(categoryId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
     * @summary Get constellations
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseConstellations: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/constellations/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
     * @summary Get constellation information
     * @param {number} constellationId constellation_id integer
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseConstellationsConstellationId: async (
      constellationId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'constellationId' is not null or undefined
      assertParamExists(
        "getUniverseConstellationsConstellationId",
        "constellationId",
        constellationId
      );
      const localVarPath =
        `/universe/constellations/{constellation_id}/`.replace(
          `{${"constellation_id"}}`,
          encodeURIComponent(String(constellationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
     * @summary Get factions
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseFactions: async (
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/factions/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
     * @summary Get graphics
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseGraphics: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/graphics/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
     * @summary Get graphic information
     * @param {number} graphicId graphic_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseGraphicsGraphicId: async (
      graphicId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphicId' is not null or undefined
      assertParamExists("getUniverseGraphicsGraphicId", "graphicId", graphicId);
      const localVarPath = `/universe/graphics/{graphic_id}/`.replace(
        `{${"graphic_id"}}`,
        encodeURIComponent(String(graphicId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
     * @summary Get item groups
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseGroups: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/groups/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
     * @summary Get item group information
     * @param {number} groupId An Eve item group ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseGroupsGroupId: async (
      groupId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists("getUniverseGroupsGroupId", "groupId", groupId);
      const localVarPath = `/universe/groups/{group_id}/`.replace(
        `{${"group_id"}}`,
        encodeURIComponent(String(groupId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
     * @summary Get moon information
     * @param {number} moonId moon_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseMoonsMoonId: async (
      moonId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'moonId' is not null or undefined
      assertParamExists("getUniverseMoonsMoonId", "moonId", moonId);
      const localVarPath = `/universe/moons/{moon_id}/`.replace(
        `{${"moon_id"}}`,
        encodeURIComponent(String(moonId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
     * @summary Get planet information
     * @param {number} planetId planet_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniversePlanetsPlanetId: async (
      planetId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'planetId' is not null or undefined
      assertParamExists("getUniversePlanetsPlanetId", "planetId", planetId);
      const localVarPath = `/universe/planets/{planet_id}/`.replace(
        `{${"planet_id"}}`,
        encodeURIComponent(String(planetId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
     * @summary Get character races
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseRaces: async (
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/races/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
     * @summary Get regions
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseRegions: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/regions/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
     * @summary Get region information
     * @param {number} regionId region_id integer
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseRegionsRegionId: async (
      regionId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'regionId' is not null or undefined
      assertParamExists("getUniverseRegionsRegionId", "regionId", regionId);
      const localVarPath = `/universe/regions/{region_id}/`.replace(
        `{${"region_id"}}`,
        encodeURIComponent(String(regionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
     * @summary Get stargate information
     * @param {number} stargateId stargate_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseStargatesStargateId: async (
      stargateId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stargateId' is not null or undefined
      assertParamExists(
        "getUniverseStargatesStargateId",
        "stargateId",
        stargateId
      );
      const localVarPath = `/universe/stargates/{stargate_id}/`.replace(
        `{${"stargate_id"}}`,
        encodeURIComponent(String(stargateId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
     * @summary Get star information
     * @param {number} starId star_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseStarsStarId: async (
      starId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'starId' is not null or undefined
      assertParamExists("getUniverseStarsStarId", "starId", starId);
      const localVarPath = `/universe/stars/{star_id}/`.replace(
        `{${"star_id"}}`,
        encodeURIComponent(String(starId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
     * @summary Get station information
     * @param {number} stationId station_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseStationsStationId: async (
      stationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stationId' is not null or undefined
      assertParamExists("getUniverseStationsStationId", "stationId", stationId);
      const localVarPath = `/universe/stations/{station_id}/`.replace(
        `{${"station_id"}}`,
        encodeURIComponent(String(stationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
     * @summary List all public structures
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {'market' | 'manufacturing_basic'} [filter] Only list public structures that have this service online
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseStructures: async (
      datasource?: "tranquility",
      filter?: "market" | "manufacturing_basic",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/structures/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get structure information
     * @param {number} structureId An Eve structure ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseStructuresStructureId: async (
      structureId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'structureId' is not null or undefined
      assertParamExists(
        "getUniverseStructuresStructureId",
        "structureId",
        structureId
      );
      const localVarPath = `/universe/structures/{structure_id}/`.replace(
        `{${"structure_id"}}`,
        encodeURIComponent(String(structureId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-universe.read_structures.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
     * @summary Get system jumps
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseSystemJumps: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/system_jumps/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
     * @summary Get system kills
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseSystemKills: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/system_kills/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
     * @summary Get solar systems
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseSystems: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/systems/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
     * @summary Get solar system information
     * @param {number} systemId system_id integer
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseSystemsSystemId: async (
      systemId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'systemId' is not null or undefined
      assertParamExists("getUniverseSystemsSystemId", "systemId", systemId);
      const localVarPath = `/universe/systems/{system_id}/`.replace(
        `{${"system_id"}}`,
        encodeURIComponent(String(systemId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
     * @summary Get types
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseTypes: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/universe/types/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
     * @summary Get type information
     * @param {number} typeId An Eve item type ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseTypesTypeId: async (
      typeId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'typeId' is not null or undefined
      assertParamExists("getUniverseTypesTypeId", "typeId", typeId);
      const localVarPath = `/universe/types/{type_id}/`.replace(
        `{${"type_id"}}`,
        encodeURIComponent(String(typeId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/`
     * @summary Bulk names to IDs
     * @param {Array<string>} names The names to resolve
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUniverseIds: async (
      names: Array<string>,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'names' is not null or undefined
      assertParamExists("postUniverseIds", "names", names);
      const localVarPath = `/universe/ids/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter["Accept-Language"] = String(acceptLanguage);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        names,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Resolve a set of IDs to names and categories. Supported ID\'s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/v3/universe/names/`
     * @summary Get names and categories for a set of IDs
     * @param {Array<number>} ids The ids to resolve
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUniverseNames: async (
      ids: Array<number>,
      datasource?: "tranquility",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'ids' is not null or undefined
      assertParamExists("postUniverseNames", "ids", ids);
      const localVarPath = `/universe/names/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        ids,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UniverseApi - functional programming interface
 * @export
 */
export const UniverseApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UniverseApiAxiosParamCreator(configuration);
  return {
    /**
     * Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
     * @summary Get ancestries
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseAncestries(
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetUniverseAncestries200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseAncestries(
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
     * @summary Get asteroid belt information
     * @param {number} asteroidBeltId asteroid_belt_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseAsteroidBeltsAsteroidBeltId(
      asteroidBeltId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseAsteroidBeltsAsteroidBeltIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseAsteroidBeltsAsteroidBeltId(
          asteroidBeltId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
     * @summary Get bloodlines
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseBloodlines(
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetUniverseBloodlines200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseBloodlines(
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
     * @summary Get item categories
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseCategories(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseCategories(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
     * @summary Get item category information
     * @param {number} categoryId An Eve item category ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseCategoriesCategoryId(
      categoryId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseCategoriesCategoryIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseCategoriesCategoryId(
          categoryId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
     * @summary Get constellations
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseConstellations(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseConstellations(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
     * @summary Get constellation information
     * @param {number} constellationId constellation_id integer
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseConstellationsConstellationId(
      constellationId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseConstellationsConstellationIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseConstellationsConstellationId(
          constellationId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
     * @summary Get factions
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseFactions(
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetUniverseFactions200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseFactions(
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
     * @summary Get graphics
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseGraphics(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseGraphics(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
     * @summary Get graphic information
     * @param {number} graphicId graphic_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseGraphicsGraphicId(
      graphicId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseGraphicsGraphicIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseGraphicsGraphicId(
          graphicId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
     * @summary Get item groups
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseGroups(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseGroups(
          datasource,
          ifNoneMatch,
          page,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
     * @summary Get item group information
     * @param {number} groupId An Eve item group ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseGroupsGroupId(
      groupId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseGroupsGroupIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseGroupsGroupId(
          groupId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
     * @summary Get moon information
     * @param {number} moonId moon_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseMoonsMoonId(
      moonId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseMoonsMoonIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseMoonsMoonId(
          moonId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
     * @summary Get planet information
     * @param {number} planetId planet_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniversePlanetsPlanetId(
      planetId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniversePlanetsPlanetIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniversePlanetsPlanetId(
          planetId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
     * @summary Get character races
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseRaces(
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetUniverseRaces200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseRaces(
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
     * @summary Get regions
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseRegions(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseRegions(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
     * @summary Get region information
     * @param {number} regionId region_id integer
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseRegionsRegionId(
      regionId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseRegionsRegionIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseRegionsRegionId(
          regionId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
     * @summary Get stargate information
     * @param {number} stargateId stargate_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseStargatesStargateId(
      stargateId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseStargatesStargateIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseStargatesStargateId(
          stargateId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
     * @summary Get star information
     * @param {number} starId star_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseStarsStarId(
      starId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseStarsStarIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseStarsStarId(
          starId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
     * @summary Get station information
     * @param {number} stationId station_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseStationsStationId(
      stationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseStationsStationIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseStationsStationId(
          stationId,
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
     * @summary List all public structures
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {'market' | 'manufacturing_basic'} [filter] Only list public structures that have this service online
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseStructures(
      datasource?: "tranquility",
      filter?: "market" | "manufacturing_basic",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseStructures(
          datasource,
          filter,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get structure information
     * @param {number} structureId An Eve structure ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseStructuresStructureId(
      structureId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseStructuresStructureIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseStructuresStructureId(
          structureId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
     * @summary Get system jumps
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseSystemJumps(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetUniverseSystemJumps200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseSystemJumps(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
     * @summary Get system kills
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseSystemKills(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetUniverseSystemKills200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseSystemKills(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
     * @summary Get solar systems
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseSystems(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseSystems(
          datasource,
          ifNoneMatch,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
     * @summary Get solar system information
     * @param {number} systemId system_id integer
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseSystemsSystemId(
      systemId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseSystemsSystemIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseSystemsSystemId(
          systemId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
     * @summary Get types
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseTypes(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseTypes(
          datasource,
          ifNoneMatch,
          page,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
     * @summary Get type information
     * @param {number} typeId An Eve item type ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniverseTypesTypeId(
      typeId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetUniverseTypesTypeIdOk>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUniverseTypesTypeId(
          typeId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/`
     * @summary Bulk names to IDs
     * @param {Array<string>} names The names to resolve
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUniverseIds(
      names: Array<string>,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PostUniverseIdsOk>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postUniverseIds(
        names,
        acceptLanguage,
        datasource,
        language,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Resolve a set of IDs to names and categories. Supported ID\'s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/v3/universe/names/`
     * @summary Get names and categories for a set of IDs
     * @param {Array<number>} ids The ids to resolve
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUniverseNames(
      ids: Array<number>,
      datasource?: "tranquility",
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PostUniverseNames200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUniverseNames(
          ids,
          datasource,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UniverseApi - factory interface
 * @export
 */
export const UniverseApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UniverseApiFp(configuration);
  return {
    /**
     * Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
     * @summary Get ancestries
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseAncestries(
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<Array<GetUniverseAncestries200Ok>> {
      return localVarFp
        .getUniverseAncestries(
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
     * @summary Get asteroid belt information
     * @param {number} asteroidBeltId asteroid_belt_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseAsteroidBeltsAsteroidBeltId(
      asteroidBeltId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetUniverseAsteroidBeltsAsteroidBeltIdOk> {
      return localVarFp
        .getUniverseAsteroidBeltsAsteroidBeltId(
          asteroidBeltId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
     * @summary Get bloodlines
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseBloodlines(
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<Array<GetUniverseBloodlines200Ok>> {
      return localVarFp
        .getUniverseBloodlines(
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
     * @summary Get item categories
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseCategories(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getUniverseCategories(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
     * @summary Get item category information
     * @param {number} categoryId An Eve item category ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseCategoriesCategoryId(
      categoryId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<GetUniverseCategoriesCategoryIdOk> {
      return localVarFp
        .getUniverseCategoriesCategoryId(
          categoryId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
     * @summary Get constellations
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseConstellations(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getUniverseConstellations(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
     * @summary Get constellation information
     * @param {number} constellationId constellation_id integer
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseConstellationsConstellationId(
      constellationId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<GetUniverseConstellationsConstellationIdOk> {
      return localVarFp
        .getUniverseConstellationsConstellationId(
          constellationId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
     * @summary Get factions
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseFactions(
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<Array<GetUniverseFactions200Ok>> {
      return localVarFp
        .getUniverseFactions(
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
     * @summary Get graphics
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseGraphics(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getUniverseGraphics(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
     * @summary Get graphic information
     * @param {number} graphicId graphic_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseGraphicsGraphicId(
      graphicId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetUniverseGraphicsGraphicIdOk> {
      return localVarFp
        .getUniverseGraphicsGraphicId(
          graphicId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
     * @summary Get item groups
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseGroups(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getUniverseGroups(datasource, ifNoneMatch, page, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
     * @summary Get item group information
     * @param {number} groupId An Eve item group ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseGroupsGroupId(
      groupId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<GetUniverseGroupsGroupIdOk> {
      return localVarFp
        .getUniverseGroupsGroupId(
          groupId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
     * @summary Get moon information
     * @param {number} moonId moon_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseMoonsMoonId(
      moonId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetUniverseMoonsMoonIdOk> {
      return localVarFp
        .getUniverseMoonsMoonId(moonId, datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
     * @summary Get planet information
     * @param {number} planetId planet_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniversePlanetsPlanetId(
      planetId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetUniversePlanetsPlanetIdOk> {
      return localVarFp
        .getUniversePlanetsPlanetId(planetId, datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
     * @summary Get character races
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseRaces(
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<Array<GetUniverseRaces200Ok>> {
      return localVarFp
        .getUniverseRaces(
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
     * @summary Get regions
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseRegions(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getUniverseRegions(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
     * @summary Get region information
     * @param {number} regionId region_id integer
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseRegionsRegionId(
      regionId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<GetUniverseRegionsRegionIdOk> {
      return localVarFp
        .getUniverseRegionsRegionId(
          regionId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
     * @summary Get stargate information
     * @param {number} stargateId stargate_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseStargatesStargateId(
      stargateId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetUniverseStargatesStargateIdOk> {
      return localVarFp
        .getUniverseStargatesStargateId(
          stargateId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
     * @summary Get star information
     * @param {number} starId star_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseStarsStarId(
      starId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetUniverseStarsStarIdOk> {
      return localVarFp
        .getUniverseStarsStarId(starId, datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
     * @summary Get station information
     * @param {number} stationId station_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseStationsStationId(
      stationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetUniverseStationsStationIdOk> {
      return localVarFp
        .getUniverseStationsStationId(
          stationId,
          datasource,
          ifNoneMatch,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
     * @summary List all public structures
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {'market' | 'manufacturing_basic'} [filter] Only list public structures that have this service online
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseStructures(
      datasource?: "tranquility",
      filter?: "market" | "manufacturing_basic",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Set<number>> {
      return localVarFp
        .getUniverseStructures(datasource, filter, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get structure information
     * @param {number} structureId An Eve structure ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseStructuresStructureId(
      structureId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<GetUniverseStructuresStructureIdOk> {
      return localVarFp
        .getUniverseStructuresStructureId(
          structureId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
     * @summary Get system jumps
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseSystemJumps(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetUniverseSystemJumps200Ok>> {
      return localVarFp
        .getUniverseSystemJumps(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
     * @summary Get system kills
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseSystemKills(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<GetUniverseSystemKills200Ok>> {
      return localVarFp
        .getUniverseSystemKills(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
     * @summary Get solar systems
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseSystems(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getUniverseSystems(datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
     * @summary Get solar system information
     * @param {number} systemId system_id integer
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseSystemsSystemId(
      systemId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<GetUniverseSystemsSystemIdOk> {
      return localVarFp
        .getUniverseSystemsSystemId(
          systemId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
     * @summary Get types
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseTypes(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getUniverseTypes(datasource, ifNoneMatch, page, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
     * @summary Get type information
     * @param {number} typeId An Eve item type ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniverseTypesTypeId(
      typeId: number,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      ifNoneMatch?: string,
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<GetUniverseTypesTypeIdOk> {
      return localVarFp
        .getUniverseTypesTypeId(
          typeId,
          acceptLanguage,
          datasource,
          ifNoneMatch,
          language,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/`
     * @summary Bulk names to IDs
     * @param {Array<string>} names The names to resolve
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUniverseIds(
      names: Array<string>,
      acceptLanguage?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      datasource?: "tranquility",
      language?:
        | "en"
        | "en-us"
        | "de"
        | "fr"
        | "ja"
        | "ru"
        | "zh"
        | "ko"
        | "es",
      options?: any
    ): AxiosPromise<PostUniverseIdsOk> {
      return localVarFp
        .postUniverseIds(names, acceptLanguage, datasource, language, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Resolve a set of IDs to names and categories. Supported ID\'s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/v3/universe/names/`
     * @summary Get names and categories for a set of IDs
     * @param {Array<number>} ids The ids to resolve
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUniverseNames(
      ids: Array<number>,
      datasource?: "tranquility",
      options?: any
    ): AxiosPromise<Array<PostUniverseNames200Ok>> {
      return localVarFp
        .postUniverseNames(ids, datasource, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UniverseApi - object-oriented interface
 * @export
 * @class UniverseApi
 * @extends {BaseAPI}
 */
export class UniverseApi extends BaseAPI {
  /**
   * Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
   * @summary Get ancestries
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseAncestries(
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseAncestries(
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
   * @summary Get asteroid belt information
   * @param {number} asteroidBeltId asteroid_belt_id integer
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseAsteroidBeltsAsteroidBeltId(
    asteroidBeltId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseAsteroidBeltsAsteroidBeltId(
        asteroidBeltId,
        datasource,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
   * @summary Get bloodlines
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseBloodlines(
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseBloodlines(
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
   * @summary Get item categories
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseCategories(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseCategories(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
   * @summary Get item category information
   * @param {number} categoryId An Eve item category ID
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseCategoriesCategoryId(
    categoryId: number,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseCategoriesCategoryId(
        categoryId,
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
   * @summary Get constellations
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseConstellations(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseConstellations(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
   * @summary Get constellation information
   * @param {number} constellationId constellation_id integer
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseConstellationsConstellationId(
    constellationId: number,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseConstellationsConstellationId(
        constellationId,
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
   * @summary Get factions
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseFactions(
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseFactions(
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
   * @summary Get graphics
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseGraphics(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseGraphics(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
   * @summary Get graphic information
   * @param {number} graphicId graphic_id integer
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseGraphicsGraphicId(
    graphicId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseGraphicsGraphicId(graphicId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
   * @summary Get item groups
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseGroups(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseGroups(datasource, ifNoneMatch, page, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
   * @summary Get item group information
   * @param {number} groupId An Eve item group ID
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseGroupsGroupId(
    groupId: number,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseGroupsGroupId(
        groupId,
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
   * @summary Get moon information
   * @param {number} moonId moon_id integer
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseMoonsMoonId(
    moonId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseMoonsMoonId(moonId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
   * @summary Get planet information
   * @param {number} planetId planet_id integer
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniversePlanetsPlanetId(
    planetId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniversePlanetsPlanetId(planetId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
   * @summary Get character races
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseRaces(
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseRaces(
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
   * @summary Get regions
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseRegions(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseRegions(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
   * @summary Get region information
   * @param {number} regionId region_id integer
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseRegionsRegionId(
    regionId: number,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseRegionsRegionId(
        regionId,
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
   * @summary Get stargate information
   * @param {number} stargateId stargate_id integer
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseStargatesStargateId(
    stargateId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseStargatesStargateId(
        stargateId,
        datasource,
        ifNoneMatch,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
   * @summary Get star information
   * @param {number} starId star_id integer
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseStarsStarId(
    starId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseStarsStarId(starId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
   * @summary Get station information
   * @param {number} stationId station_id integer
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseStationsStationId(
    stationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseStationsStationId(stationId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
   * @summary List all public structures
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {'market' | 'manufacturing_basic'} [filter] Only list public structures that have this service online
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseStructures(
    datasource?: "tranquility",
    filter?: "market" | "manufacturing_basic",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseStructures(datasource, filter, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
   * @summary Get structure information
   * @param {number} structureId An Eve structure ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseStructuresStructureId(
    structureId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseStructuresStructureId(
        structureId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
   * @summary Get system jumps
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseSystemJumps(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseSystemJumps(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
   * @summary Get system kills
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseSystemKills(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseSystemKills(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
   * @summary Get solar systems
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseSystems(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseSystems(datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
   * @summary Get solar system information
   * @param {number} systemId system_id integer
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseSystemsSystemId(
    systemId: number,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseSystemsSystemId(
        systemId,
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
   * @summary Get types
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseTypes(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseTypes(datasource, ifNoneMatch, page, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
   * @summary Get type information
   * @param {number} typeId An Eve item type ID
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public getUniverseTypesTypeId(
    typeId: number,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    ifNoneMatch?: string,
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .getUniverseTypesTypeId(
        typeId,
        acceptLanguage,
        datasource,
        ifNoneMatch,
        language,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/`
   * @summary Bulk names to IDs
   * @param {Array<string>} names The names to resolve
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public postUniverseIds(
    names: Array<string>,
    acceptLanguage?:
      | "en"
      | "en-us"
      | "de"
      | "fr"
      | "ja"
      | "ru"
      | "zh"
      | "ko"
      | "es",
    datasource?: "tranquility",
    language?: "en" | "en-us" | "de" | "fr" | "ja" | "ru" | "zh" | "ko" | "es",
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .postUniverseIds(names, acceptLanguage, datasource, language, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Resolve a set of IDs to names and categories. Supported ID\'s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/v3/universe/names/`
   * @summary Get names and categories for a set of IDs
   * @param {Array<number>} ids The ids to resolve
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverseApi
   */
  public postUniverseNames(
    ids: Array<number>,
    datasource?: "tranquility",
    options?: AxiosRequestConfig
  ) {
    return UniverseApiFp(this.configuration)
      .postUniverseNames(ids, datasource, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserInterfaceApi - axios parameter creator
 * @export
 */
export const UserInterfaceApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/`
     * @summary Set Autopilot Waypoint
     * @param {boolean} addToBeginning Whether this solar system should be added to the beginning of all waypoints
     * @param {boolean} clearOtherWaypoints Whether clean other waypoints beforing adding this one
     * @param {number} destinationId The destination to travel to, can be solar system, station or structure\&#39;s id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUiAutopilotWaypoint: async (
      addToBeginning: boolean,
      clearOtherWaypoints: boolean,
      destinationId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'addToBeginning' is not null or undefined
      assertParamExists(
        "postUiAutopilotWaypoint",
        "addToBeginning",
        addToBeginning
      );
      // verify required parameter 'clearOtherWaypoints' is not null or undefined
      assertParamExists(
        "postUiAutopilotWaypoint",
        "clearOtherWaypoints",
        clearOtherWaypoints
      );
      // verify required parameter 'destinationId' is not null or undefined
      assertParamExists(
        "postUiAutopilotWaypoint",
        "destinationId",
        destinationId
      );
      const localVarPath = `/ui/autopilot/waypoint/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-ui.write_waypoint.v1"],
        configuration
      );

      if (addToBeginning !== undefined) {
        localVarQueryParameter["add_to_beginning"] = addToBeginning;
      }

      if (clearOtherWaypoints !== undefined) {
        localVarQueryParameter["clear_other_waypoints"] = clearOtherWaypoints;
      }

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (destinationId !== undefined) {
        localVarQueryParameter["destination_id"] = destinationId;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/`
     * @summary Open Contract Window
     * @param {number} contractId The contract to open
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUiOpenwindowContract: async (
      contractId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists("postUiOpenwindowContract", "contractId", contractId);
      const localVarPath = `/ui/openwindow/contract/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-ui.open_window.v1"],
        configuration
      );

      if (contractId !== undefined) {
        localVarQueryParameter["contract_id"] = contractId;
      }

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/`
     * @summary Open Information Window
     * @param {number} targetId The target to open
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUiOpenwindowInformation: async (
      targetId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'targetId' is not null or undefined
      assertParamExists("postUiOpenwindowInformation", "targetId", targetId);
      const localVarPath = `/ui/openwindow/information/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-ui.open_window.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (targetId !== undefined) {
        localVarQueryParameter["target_id"] = targetId;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/`
     * @summary Open Market Details
     * @param {number} typeId The item type to open in market window
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUiOpenwindowMarketdetails: async (
      typeId: number,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'typeId' is not null or undefined
      assertParamExists("postUiOpenwindowMarketdetails", "typeId", typeId);
      const localVarPath = `/ui/openwindow/marketdetails/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-ui.open_window.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (typeId !== undefined) {
        localVarQueryParameter["type_id"] = typeId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/`
     * @summary Open New Mail Window
     * @param {PostUiOpenwindowNewmailNewMail} newMail The details of mail to create
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUiOpenwindowNewmail: async (
      newMail: PostUiOpenwindowNewmailNewMail,
      datasource?: "tranquility",
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'newMail' is not null or undefined
      assertParamExists("postUiOpenwindowNewmail", "newMail", newMail);
      const localVarPath = `/ui/openwindow/newmail/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-ui.open_window.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        newMail,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserInterfaceApi - functional programming interface
 * @export
 */
export const UserInterfaceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UserInterfaceApiAxiosParamCreator(configuration);
  return {
    /**
     * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/`
     * @summary Set Autopilot Waypoint
     * @param {boolean} addToBeginning Whether this solar system should be added to the beginning of all waypoints
     * @param {boolean} clearOtherWaypoints Whether clean other waypoints beforing adding this one
     * @param {number} destinationId The destination to travel to, can be solar system, station or structure\&#39;s id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUiAutopilotWaypoint(
      addToBeginning: boolean,
      clearOtherWaypoints: boolean,
      destinationId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUiAutopilotWaypoint(
          addToBeginning,
          clearOtherWaypoints,
          destinationId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/`
     * @summary Open Contract Window
     * @param {number} contractId The contract to open
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUiOpenwindowContract(
      contractId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUiOpenwindowContract(
          contractId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/`
     * @summary Open Information Window
     * @param {number} targetId The target to open
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUiOpenwindowInformation(
      targetId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUiOpenwindowInformation(
          targetId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/`
     * @summary Open Market Details
     * @param {number} typeId The item type to open in market window
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUiOpenwindowMarketdetails(
      typeId: number,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUiOpenwindowMarketdetails(
          typeId,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/`
     * @summary Open New Mail Window
     * @param {PostUiOpenwindowNewmailNewMail} newMail The details of mail to create
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUiOpenwindowNewmail(
      newMail: PostUiOpenwindowNewmailNewMail,
      datasource?: "tranquility",
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUiOpenwindowNewmail(
          newMail,
          datasource,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UserInterfaceApi - factory interface
 * @export
 */
export const UserInterfaceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserInterfaceApiFp(configuration);
  return {
    /**
     * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/`
     * @summary Set Autopilot Waypoint
     * @param {boolean} addToBeginning Whether this solar system should be added to the beginning of all waypoints
     * @param {boolean} clearOtherWaypoints Whether clean other waypoints beforing adding this one
     * @param {number} destinationId The destination to travel to, can be solar system, station or structure\&#39;s id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUiAutopilotWaypoint(
      addToBeginning: boolean,
      clearOtherWaypoints: boolean,
      destinationId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .postUiAutopilotWaypoint(
          addToBeginning,
          clearOtherWaypoints,
          destinationId,
          datasource,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/`
     * @summary Open Contract Window
     * @param {number} contractId The contract to open
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUiOpenwindowContract(
      contractId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .postUiOpenwindowContract(contractId, datasource, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/`
     * @summary Open Information Window
     * @param {number} targetId The target to open
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUiOpenwindowInformation(
      targetId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .postUiOpenwindowInformation(targetId, datasource, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/`
     * @summary Open Market Details
     * @param {number} typeId The item type to open in market window
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUiOpenwindowMarketdetails(
      typeId: number,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .postUiOpenwindowMarketdetails(typeId, datasource, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/`
     * @summary Open New Mail Window
     * @param {PostUiOpenwindowNewmailNewMail} newMail The details of mail to create
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUiOpenwindowNewmail(
      newMail: PostUiOpenwindowNewmailNewMail,
      datasource?: "tranquility",
      token?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .postUiOpenwindowNewmail(newMail, datasource, token, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserInterfaceApi - object-oriented interface
 * @export
 * @class UserInterfaceApi
 * @extends {BaseAPI}
 */
export class UserInterfaceApi extends BaseAPI {
  /**
   * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/`
   * @summary Set Autopilot Waypoint
   * @param {boolean} addToBeginning Whether this solar system should be added to the beginning of all waypoints
   * @param {boolean} clearOtherWaypoints Whether clean other waypoints beforing adding this one
   * @param {number} destinationId The destination to travel to, can be solar system, station or structure\&#39;s id
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserInterfaceApi
   */
  public postUiAutopilotWaypoint(
    addToBeginning: boolean,
    clearOtherWaypoints: boolean,
    destinationId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return UserInterfaceApiFp(this.configuration)
      .postUiAutopilotWaypoint(
        addToBeginning,
        clearOtherWaypoints,
        destinationId,
        datasource,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/`
   * @summary Open Contract Window
   * @param {number} contractId The contract to open
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserInterfaceApi
   */
  public postUiOpenwindowContract(
    contractId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return UserInterfaceApiFp(this.configuration)
      .postUiOpenwindowContract(contractId, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/`
   * @summary Open Information Window
   * @param {number} targetId The target to open
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserInterfaceApi
   */
  public postUiOpenwindowInformation(
    targetId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return UserInterfaceApiFp(this.configuration)
      .postUiOpenwindowInformation(targetId, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/`
   * @summary Open Market Details
   * @param {number} typeId The item type to open in market window
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserInterfaceApi
   */
  public postUiOpenwindowMarketdetails(
    typeId: number,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return UserInterfaceApiFp(this.configuration)
      .postUiOpenwindowMarketdetails(typeId, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/`
   * @summary Open New Mail Window
   * @param {PostUiOpenwindowNewmailNewMail} newMail The details of mail to create
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserInterfaceApi
   */
  public postUiOpenwindowNewmail(
    newMail: PostUiOpenwindowNewmailNewMail,
    datasource?: "tranquility",
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return UserInterfaceApiFp(this.configuration)
      .postUiOpenwindowNewmail(newMail, datasource, token, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns a character\'s wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/wallet/)
     * @summary Get a character\'s wallet balance
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterWallet: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists("getCharacterWallet", "characterId", characterId);
      const localVarPath = `/characters/{character_id}/wallet/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-wallet.read_character_wallet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve the given character\'s wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
     * @summary Get character wallet journal
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterWalletJournal: async (
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterWalletJournal",
        "characterId",
        characterId
      );
      const localVarPath = `/characters/{character_id}/wallet/journal/`.replace(
        `{${"character_id"}}`,
        encodeURIComponent(String(characterId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-wallet.read_character_wallet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
     * @summary Get wallet transactions
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {number} [fromId] Only show transactions happened before the one referenced by this id
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterWalletTransactions: async (
      characterId: number,
      datasource?: "tranquility",
      fromId?: number,
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'characterId' is not null or undefined
      assertParamExists(
        "getCharacterWalletTransactions",
        "characterId",
        characterId
      );
      const localVarPath =
        `/characters/{character_id}/wallet/transactions/`.replace(
          `{${"character_id"}}`,
          encodeURIComponent(String(characterId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-wallet.read_character_wallet.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (fromId !== undefined) {
        localVarQueryParameter["from_id"] = fromId;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a corporation\'s wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant
     * @summary Returns a corporation\'s wallet balance
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdWallets: async (
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdWallets",
        "corporationId",
        corporationId
      );
      const localVarPath = `/corporations/{corporation_id}/wallets/`.replace(
        `{${"corporation_id"}}`,
        encodeURIComponent(String(corporationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-wallet.read_corporation_wallets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve the given corporation\'s wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant
     * @summary Get corporation wallet journal
     * @param {number} corporationId An EVE corporation ID
     * @param {number} division Wallet key of the division to fetch journals from
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdWalletsDivisionJournal: async (
      corporationId: number,
      division: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdWalletsDivisionJournal",
        "corporationId",
        corporationId
      );
      // verify required parameter 'division' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdWalletsDivisionJournal",
        "division",
        division
      );
      const localVarPath =
        `/corporations/{corporation_id}/wallets/{division}/journal/`
          .replace(
            `{${"corporation_id"}}`,
            encodeURIComponent(String(corporationId))
          )
          .replace(`{${"division"}}`, encodeURIComponent(String(division)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-wallet.read_corporation_wallets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant
     * @summary Get corporation wallet transactions
     * @param {number} corporationId An EVE corporation ID
     * @param {number} division Wallet key of the division to fetch journals from
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {number} [fromId] Only show journal entries happened before the transaction referenced by this id
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdWalletsDivisionTransactions: async (
      corporationId: number,
      division: number,
      datasource?: "tranquility",
      fromId?: number,
      ifNoneMatch?: string,
      token?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'corporationId' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdWalletsDivisionTransactions",
        "corporationId",
        corporationId
      );
      // verify required parameter 'division' is not null or undefined
      assertParamExists(
        "getCorporationsCorporationIdWalletsDivisionTransactions",
        "division",
        division
      );
      const localVarPath =
        `/corporations/{corporation_id}/wallets/{division}/transactions/`
          .replace(
            `{${"corporation_id"}}`,
            encodeURIComponent(String(corporationId))
          )
          .replace(`{${"division"}}`, encodeURIComponent(String(division)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication evesso required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "evesso",
        ["esi-wallet.read_corporation_wallets.v1"],
        configuration
      );

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (fromId !== undefined) {
        localVarQueryParameter["from_id"] = fromId;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a character\'s wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/wallet/)
     * @summary Get a character\'s wallet balance
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterWallet(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterWallet(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve the given character\'s wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
     * @summary Get character wallet journal
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterWalletJournal(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdWalletJournal200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterWalletJournal(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
     * @summary Get wallet transactions
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {number} [fromId] Only show transactions happened before the one referenced by this id
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCharacterWalletTransactions(
      characterId: number,
      datasource?: "tranquility",
      fromId?: number,
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCharactersCharacterIdWalletTransactions200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCharacterWalletTransactions(
          characterId,
          datasource,
          fromId,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a corporation\'s wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant
     * @summary Returns a corporation\'s wallet balance
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdWallets(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetCorporationsCorporationIdWallets200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdWallets(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve the given corporation\'s wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant
     * @summary Get corporation wallet journal
     * @param {number} corporationId An EVE corporation ID
     * @param {number} division Wallet key of the division to fetch journals from
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdWalletsDivisionJournal(
      corporationId: number,
      division: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<
        Array<GetCorporationsCorporationIdWalletsDivisionJournal200Ok>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdWalletsDivisionJournal(
          corporationId,
          division,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant
     * @summary Get corporation wallet transactions
     * @param {number} corporationId An EVE corporation ID
     * @param {number} division Wallet key of the division to fetch journals from
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {number} [fromId] Only show journal entries happened before the transaction referenced by this id
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCorporationsCorporationIdWalletsDivisionTransactions(
      corporationId: number,
      division: number,
      datasource?: "tranquility",
      fromId?: number,
      ifNoneMatch?: string,
      token?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<
        Array<GetCorporationsCorporationIdWalletsDivisionTransactions200Ok>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCorporationsCorporationIdWalletsDivisionTransactions(
          corporationId,
          division,
          datasource,
          fromId,
          ifNoneMatch,
          token,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WalletApiFp(configuration);
  return {
    /**
     * Returns a character\'s wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/wallet/)
     * @summary Get a character\'s wallet balance
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterWallet(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .getCharacterWallet(
          characterId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve the given character\'s wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
     * @summary Get character wallet journal
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterWalletJournal(
      characterId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdWalletJournal200Ok>> {
      return localVarFp
        .getCharacterWalletJournal(
          characterId,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
     * @summary Get wallet transactions
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {number} [fromId] Only show transactions happened before the one referenced by this id
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCharacterWalletTransactions(
      characterId: number,
      datasource?: "tranquility",
      fromId?: number,
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCharactersCharacterIdWalletTransactions200Ok>> {
      return localVarFp
        .getCharacterWalletTransactions(
          characterId,
          datasource,
          fromId,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a corporation\'s wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant
     * @summary Returns a corporation\'s wallet balance
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdWallets(
      corporationId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<Array<GetCorporationsCorporationIdWallets200Ok>> {
      return localVarFp
        .getCorporationsCorporationIdWallets(
          corporationId,
          datasource,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve the given corporation\'s wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant
     * @summary Get corporation wallet journal
     * @param {number} corporationId An EVE corporation ID
     * @param {number} division Wallet key of the division to fetch journals from
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdWalletsDivisionJournal(
      corporationId: number,
      division: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      token?: string,
      options?: any
    ): AxiosPromise<
      Array<GetCorporationsCorporationIdWalletsDivisionJournal200Ok>
    > {
      return localVarFp
        .getCorporationsCorporationIdWalletsDivisionJournal(
          corporationId,
          division,
          datasource,
          ifNoneMatch,
          page,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant
     * @summary Get corporation wallet transactions
     * @param {number} corporationId An EVE corporation ID
     * @param {number} division Wallet key of the division to fetch journals from
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {number} [fromId] Only show journal entries happened before the transaction referenced by this id
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCorporationsCorporationIdWalletsDivisionTransactions(
      corporationId: number,
      division: number,
      datasource?: "tranquility",
      fromId?: number,
      ifNoneMatch?: string,
      token?: string,
      options?: any
    ): AxiosPromise<
      Array<GetCorporationsCorporationIdWalletsDivisionTransactions200Ok>
    > {
      return localVarFp
        .getCorporationsCorporationIdWalletsDivisionTransactions(
          corporationId,
          division,
          datasource,
          fromId,
          ifNoneMatch,
          token,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
  /**
   * Returns a character\'s wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/wallet/)
   * @summary Get a character\'s wallet balance
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getCharacterWallet(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return WalletApiFp(this.configuration)
      .getCharacterWallet(characterId, datasource, ifNoneMatch, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve the given character\'s wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
   * @summary Get character wallet journal
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getCharacterWalletJournal(
    characterId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return WalletApiFp(this.configuration)
      .getCharacterWalletJournal(
        characterId,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
   * @summary Get wallet transactions
   * @param {number} characterId An EVE character ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {number} [fromId] Only show transactions happened before the one referenced by this id
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getCharacterWalletTransactions(
    characterId: number,
    datasource?: "tranquility",
    fromId?: number,
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return WalletApiFp(this.configuration)
      .getCharacterWalletTransactions(
        characterId,
        datasource,
        fromId,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a corporation\'s wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant
   * @summary Returns a corporation\'s wallet balance
   * @param {number} corporationId An EVE corporation ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getCorporationsCorporationIdWallets(
    corporationId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return WalletApiFp(this.configuration)
      .getCorporationsCorporationIdWallets(
        corporationId,
        datasource,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve the given corporation\'s wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant
   * @summary Get corporation wallet journal
   * @param {number} corporationId An EVE corporation ID
   * @param {number} division Wallet key of the division to fetch journals from
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getCorporationsCorporationIdWalletsDivisionJournal(
    corporationId: number,
    division: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return WalletApiFp(this.configuration)
      .getCorporationsCorporationIdWalletsDivisionJournal(
        corporationId,
        division,
        datasource,
        ifNoneMatch,
        page,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant
   * @summary Get corporation wallet transactions
   * @param {number} corporationId An EVE corporation ID
   * @param {number} division Wallet key of the division to fetch journals from
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {number} [fromId] Only show journal entries happened before the transaction referenced by this id
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {string} [token] Access token to use if unable to set a header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getCorporationsCorporationIdWalletsDivisionTransactions(
    corporationId: number,
    division: number,
    datasource?: "tranquility",
    fromId?: number,
    ifNoneMatch?: string,
    token?: string,
    options?: AxiosRequestConfig
  ) {
    return WalletApiFp(this.configuration)
      .getCorporationsCorporationIdWalletsDivisionTransactions(
        corporationId,
        division,
        datasource,
        fromId,
        ifNoneMatch,
        token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WarsApi - axios parameter creator
 * @export
 */
export const WarsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
     * @summary List wars
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [maxWarId] Only return wars with ID smaller than this
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWars: async (
      datasource?: "tranquility",
      ifNoneMatch?: string,
      maxWarId?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/wars/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (maxWarId !== undefined) {
        localVarQueryParameter["max_war_id"] = maxWarId;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get war information
     * @param {number} warId ID for a war
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWarsWarId: async (
      warId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'warId' is not null or undefined
      assertParamExists("getWarsWarId", "warId", warId);
      const localVarPath = `/wars/{war_id}/`.replace(
        `{${"war_id"}}`,
        encodeURIComponent(String(warId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
     * @summary List kills for a war
     * @param {number} warId A valid war ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWarsWarIdKillmails: async (
      warId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'warId' is not null or undefined
      assertParamExists("getWarsWarIdKillmails", "warId", warId);
      const localVarPath = `/wars/{war_id}/killmails/`.replace(
        `{${"war_id"}}`,
        encodeURIComponent(String(warId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (datasource !== undefined) {
        localVarQueryParameter["datasource"] = datasource;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter["If-None-Match"] = String(ifNoneMatch);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WarsApi - functional programming interface
 * @export
 */
export const WarsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WarsApiAxiosParamCreator(configuration);
  return {
    /**
     * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
     * @summary List wars
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [maxWarId] Only return wars with ID smaller than this
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWars(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      maxWarId?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWars(
        datasource,
        ifNoneMatch,
        maxWarId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get war information
     * @param {number} warId ID for a war
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWarsWarId(
      warId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWarsWarIdOk>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWarsWarId(
        warId,
        datasource,
        ifNoneMatch,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
     * @summary List kills for a war
     * @param {number} warId A valid war ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWarsWarIdKillmails(
      warId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GetWarsWarIdKillmails200Ok>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWarsWarIdKillmails(
          warId,
          datasource,
          ifNoneMatch,
          page,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * WarsApi - factory interface
 * @export
 */
export const WarsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WarsApiFp(configuration);
  return {
    /**
     * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
     * @summary List wars
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [maxWarId] Only return wars with ID smaller than this
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWars(
      datasource?: "tranquility",
      ifNoneMatch?: string,
      maxWarId?: number,
      options?: any
    ): AxiosPromise<Array<number>> {
      return localVarFp
        .getWars(datasource, ifNoneMatch, maxWarId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get war information
     * @param {number} warId ID for a war
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWarsWarId(
      warId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      options?: any
    ): AxiosPromise<GetWarsWarIdOk> {
      return localVarFp
        .getWarsWarId(warId, datasource, ifNoneMatch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
     * @summary List kills for a war
     * @param {number} warId A valid war ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWarsWarIdKillmails(
      warId: number,
      datasource?: "tranquility",
      ifNoneMatch?: string,
      page?: number,
      options?: any
    ): AxiosPromise<Array<GetWarsWarIdKillmails200Ok>> {
      return localVarFp
        .getWarsWarIdKillmails(warId, datasource, ifNoneMatch, page, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WarsApi - object-oriented interface
 * @export
 * @class WarsApi
 * @extends {BaseAPI}
 */
export class WarsApi extends BaseAPI {
  /**
   * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
   * @summary List wars
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [maxWarId] Only return wars with ID smaller than this
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WarsApi
   */
  public getWars(
    datasource?: "tranquility",
    ifNoneMatch?: string,
    maxWarId?: number,
    options?: AxiosRequestConfig
  ) {
    return WarsApiFp(this.configuration)
      .getWars(datasource, ifNoneMatch, maxWarId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
   * @summary Get war information
   * @param {number} warId ID for a war
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WarsApi
   */
  public getWarsWarId(
    warId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    options?: AxiosRequestConfig
  ) {
    return WarsApiFp(this.configuration)
      .getWarsWarId(warId, datasource, ifNoneMatch, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
   * @summary List kills for a war
   * @param {number} warId A valid war ID
   * @param {'tranquility'} [datasource] The server name you would like data from
   * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
   * @param {number} [page] Which page of results to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WarsApi
   */
  public getWarsWarIdKillmails(
    warId: number,
    datasource?: "tranquility",
    ifNoneMatch?: string,
    page?: number,
    options?: AxiosRequestConfig
  ) {
    return WarsApiFp(this.configuration)
      .getWarsWarIdKillmails(warId, datasource, ifNoneMatch, page, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
